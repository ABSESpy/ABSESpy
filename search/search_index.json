{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"ABSESpy","text":"<p>Date: February. 16, 2025, Version: 0.7.x</p> <p>Useful links: Install | Source Repository | Issues &amp; Ideas | Q&amp;A Support</p> <p><code>ABSESpy</code> is an agent-based framework that makes modeling social-ecological systems easier.</p> <ul> <li> <p> The thing for me?</p> <p>Still wondering if <code>ABSESpy</code> is the right tool? We have a checklist for you guidance.</p> <p> Guidance checklist</p> </li> <li> <p> Set up in 5 minutes</p> <p>Install <code>ABSESpy</code> with <code>pip</code>, then checkout our quick start tutorial.</p> <p> Getting started</p> </li> <li> <p> Start modeling</p> <p>We provide detailed tutorials for users to begin developing their own ABMs.</p> <p> Tutorials</p> </li> <li> <p> API documentation</p> <p>For advanced users, check out source codes.</p> <p> API References</p> </li> </ul>"},{"location":"#keep-in-touch-with-us","title":"Keep in touch with us","text":"<p>Mailing group </p>"},{"location":"api/agents/","title":"Actor (Agent)","text":"<p>               Bases: <code>GeoAgent</code>, <code>_BaseObj</code>, <code>_LinkNodeActor</code></p> <p>An actor in a social-ecological system (or \"Agent\" in an agent-based model.)</p> <p>Attributes:</p> Name Type Description <code>breed</code> <p>The breed of this actor (by default, class name).</p> <code>layer</code> <code>Optional[PatchModule]</code> <p>The layer where the actor is located.</p> <code>indices</code> <code>Optional[Pos]</code> <p>The indices of the cell where the actor is located.</p> <code>pos</code> <code>Optional[Pos]</code> <p>The position of the cell where the actor is located.</p> <code>on_earth</code> <code>bool</code> <p>Whether the actor is standing on a cell.</p> <code>at</code> <code>PatchCell | None</code> <p>The cell where the actor is located.</p> <code>link</code> <code>_LinkProxy</code> <p>The link manipulating proxy.</p> <code>move</code> <code>_Movements</code> <p>The movement manipulating proxy.</p> <p>Methods:</p> Name Description <code>get</code> <p>Gets the value of an attribute from the actor or its cell.</p> <code>set</code> <p>Sets the value of an attribute on the actor or its cell.</p> <code>die</code> <p>Kills the actor.</p> Source code in <code>abses/actor.py</code> <pre><code>def __init__(\n    self, model: MainModel[Any, Any], observer: bool = True, **kwargs\n) -&gt; None:\n    _BaseObj.__init__(self, model, observer=observer)\n    crs = kwargs.pop(\"crs\", model.nature.crs)\n    geometry = kwargs.pop(\"geometry\", None)\n    mg.GeoAgent.__init__(self, model=model, geometry=geometry, crs=crs)\n    _LinkNodeActor.__init__(self)\n    self._cell: Optional[PatchCell] = None\n    self._alive: bool = True\n    self._birth_tick: int = self.time.tick\n    self._setup()\n</code></pre> <p>Either select the agent according to specified criteria.</p> <p>Parameters:</p> Name Type Description Default <code>selection</code> <code>Union[str, Dict[str, Any]]</code> <p>Either a string or a dictionary of key-value pairs. Each represents agent attributes to be checked against.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether the agent is selected or not</p> Source code in <code>abses/selection.py</code> <pre><code>def selecting(actor, selection: Union[str, Dict[str, Any]]) -&gt; bool:\n    \"\"\"Either select the agent according to specified criteria.\n\n    Parameters:\n        selection:\n            Either a string or a dictionary of key-value pairs.\n            Each represents agent attributes to be checked against.\n\n    Returns:\n        Whether the agent is selected or not\n    \"\"\"\n    if isinstance(selection, str):\n        selection = parsing_string_selection(selection)\n    results = []\n    for k, v in selection.items():\n        attr = getattr(actor, k, None)\n        if attr is None:\n            results.append(False)\n        elif attr == v or str(attr) == v:\n            results.append(True)\n        else:\n            results.append(False)\n    return all(results)\n</code></pre>"},{"location":"api/agents/#abses.actor.Actor.geo_type","title":"geo_type  <code>property</code>","text":"<pre><code>geo_type\n</code></pre> <p>The type of the geo info.</p>"},{"location":"api/agents/#abses.actor.Actor.geometry","title":"geometry  <code>property</code> <code>writable</code>","text":"<pre><code>geometry\n</code></pre> <p>The geometry of the actor.</p>"},{"location":"api/agents/#abses.actor.Actor.alive","title":"alive  <code>property</code>","text":"<pre><code>alive\n</code></pre> <p>Whether the actor is alive.</p>"},{"location":"api/agents/#abses.actor.Actor.layer","title":"layer  <code>property</code>","text":"<pre><code>layer\n</code></pre> <p>Get the layer where the actor is located.</p>"},{"location":"api/agents/#abses.actor.Actor.on_earth","title":"on_earth  <code>property</code>","text":"<pre><code>on_earth\n</code></pre> <p>Whether agent stands on a cell.</p>"},{"location":"api/agents/#abses.actor.Actor.at","title":"at  <code>deletable</code> <code>property</code> <code>writable</code>","text":"<pre><code>at\n</code></pre> <p>Get the cell where the agent is located.</p>"},{"location":"api/agents/#abses.actor.Actor.pos","title":"pos  <code>property</code> <code>writable</code>","text":"<pre><code>pos\n</code></pre> <p>Position of the actor.</p>"},{"location":"api/agents/#abses.actor.Actor.indices","title":"indices  <code>property</code>","text":"<pre><code>indices\n</code></pre> <p>Indices of the actor.</p>"},{"location":"api/agents/#abses.actor.Actor.move","title":"move  <code>cached</code> <code>property</code>","text":"<pre><code>move\n</code></pre> <p>A proxy for manipulating actor's location.</p> <ol> <li><code>move.to()</code>: moves the actor to another cell.</li> <li><code>move.off()</code>: removes the actor from the current layer.</li> <li><code>move.by()</code>: moves the actor by a distance.</li> <li><code>move.random()</code>: moves the actor to a random cell.</li> </ol>"},{"location":"api/agents/#abses.actor.Actor.age","title":"age","text":"<pre><code>age()\n</code></pre> <p>Get the age of the actor.</p> Source code in <code>abses/actor.py</code> <pre><code>@alive_required\ndef age(self) -&gt; int:\n    \"\"\"Get the age of the actor.\"\"\"\n    return self.time.tick - self._birth_tick\n</code></pre>"},{"location":"api/agents/#abses.actor.Actor.get","title":"get","text":"<pre><code>get(attr, target=None, default=...)\n</code></pre> <p>Gets attribute value from target.</p> <p>Parameters:</p> Name Type Description Default <code>attr</code> <code>str</code> <p>The name of the attribute to get.</p> required <code>target</code> <code>Optional[TargetName]</code> <p>The target to get the attribute from. If None, the agent itself is the target. If the target is an agent, get the attribute from the agent. If the target is a cell, get the attribute from the cell.</p> <code>None</code> <code>default</code> <code>Any</code> <p>Default value if attribute not found.</p> <code>...</code> <p>Returns:</p> Type Description <code>Any</code> <p>The value of the attribute.</p> Source code in <code>abses/actor.py</code> <pre><code>@alive_required\ndef get(\n    self, attr: str, target: Optional[TargetName] = None, default: Any = ...\n) -&gt; Any:\n    \"\"\"\n    Gets attribute value from target.\n\n    Args:\n        attr: The name of the attribute to get.\n        target: The target to get the attribute from.\n            If None, the agent itself is the target.\n            If the target is an agent, get the attribute from the agent.\n            If the target is a cell, get the attribute from the cell.\n        default: Default value if attribute not found.\n\n    Returns:\n        The value of the attribute.\n    \"\"\"\n    if attr in self.dynamic_variables:\n        return self.dynamic_var(attr)\n    return super().get(attr=attr, target=target, default=default)\n</code></pre>"},{"location":"api/agents/#abses.actor.Actor.set","title":"set","text":"<pre><code>set(*args, **kwargs)\n</code></pre> <p>Sets the value of an attribute.</p> <p>Parameters:</p> Name Type Description Default <code>attr</code> <p>The name of the attribute to set.</p> required <code>value</code> <p>The value to set the attribute to.</p> required <code>target</code> <p>The target to set the attribute on. If None, the agent itself is the target. 1. If the target is an agent, set the attribute on the agent. 2. If the target is a cell, set the attribute on the cell.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>If the attribute is not a string.</p> <code>ABSESpyError</code> <p>If the attribute is protected.</p> Source code in <code>abses/actor.py</code> <pre><code>@alive_required\ndef set(self, *args, **kwargs) -&gt; None:\n    \"\"\"\n    Sets the value of an attribute.\n\n    Args:\n        attr: The name of the attribute to set.\n        value: The value to set the attribute to.\n        target: The target to set the attribute on. If None, the agent itself is the target.\n            1. If the target is an agent, set the attribute on the agent.\n            2. If the target is a cell, set the attribute on the cell.\n\n    Raises:\n        TypeError: If the attribute is not a string.\n        ABSESpyError: If the attribute is protected.\n    \"\"\"\n    super().set(*args, **kwargs)\n</code></pre>"},{"location":"api/agents/#abses.actor.Actor.remove","title":"remove","text":"<pre><code>remove()\n</code></pre> <p>Remove the actor from the model.</p> Source code in <code>abses/actor.py</code> <pre><code>def remove(self) -&gt; None:\n    \"\"\"Remove the actor from the model.\"\"\"\n    self.die()\n</code></pre>"},{"location":"api/agents/#abses.actor.Actor.die","title":"die","text":"<pre><code>die()\n</code></pre> <p>Kills the agent (self)</p> Source code in <code>abses/actor.py</code> <pre><code>@alive_required\ndef die(self) -&gt; None:\n    \"\"\"Kills the agent (self)\"\"\"\n    self.link.clean()  # \u4ece\u94fe\u63a5\u4e2d\u79fb\u9664\n    if self.on_earth:  # \u5982\u679c\u5728\u5730\u4e0a\uff0c\u90a3\u4e48\u4ece\u5730\u5757\u4e0a\u79fb\u9664\n        self.move.off()\n    super().remove()  # \u4ece\u603b\u6a21\u578b\u91cc\u79fb\u9664\n    self._alive = False  # \u8bbe\u7f6e\u4e3a\u6b7b\u4ea1\u72b6\u6001\n    del self\n</code></pre>"},{"location":"api/agents/#abses.actor.Actor.setup","title":"setup","text":"<pre><code>setup()\n</code></pre> <p>Overwrite this method. It should be called when the actor is initialized.</p> Source code in <code>abses/actor.py</code> <pre><code>def setup(self) -&gt; None:\n    \"\"\"Overwrite this method.\n    It should be called when the actor is initialized.\n    \"\"\"\n</code></pre>"},{"location":"api/agents/#abses.actor.Actor.moving","title":"moving","text":"<pre><code>moving(cell)\n</code></pre> <p>Called when the actor is about to move.</p> <p>Parameters:</p> Name Type Description Default <code>cell</code> <code>PatchCell</code> <p>The target cell to move to.</p> required <p>Returns:</p> Type Description <code>Optional[bool]</code> <p>Optional boolean indicating whether the actor can move to the cell.</p> <code>Optional[bool]</code> <p>If None, the move is allowed by default.</p> Source code in <code>abses/actor.py</code> <pre><code>def moving(self, cell: PatchCell) -&gt; Optional[bool]:\n    \"\"\"\n    Called when the actor is about to move.\n\n    Args:\n        cell: The target cell to move to.\n\n    Returns:\n        Optional boolean indicating whether the actor can move to the cell.\n        If None, the move is allowed by default.\n    \"\"\"\n</code></pre>"},{"location":"api/api/","title":"API Reference Guide Map","text":"<p>Following diagram shows the basic structure of the <code>ABSESpy</code>'s API.</p> <p></p> <p>You may wanna check out:</p>"},{"location":"api/api/#implementation","title":"Implementation","text":"<p>Have a basic idea on how to implement your own model based on <code>ABSESpy</code>.</p> <ul> <li>\ud83c\udf0d Generally, the default <code>BaseNature</code> is enough in most cases, but you may want to create a layer (<code>PatchModule</code>) as a world where actors live.</li> <li>\ud83d\uddfa\ufe0f Wait, if you want more flexibility to operate the grid cells, it's a good idea to customize <code>PatchCell</code>.</li> <li>\ud83e\udd16 Now, introducing your custom agents (actors in social-ecological system context) by custom a subclass of <code>Actor</code>.</li> <li>(\ud83e\udd77 Advanced skill) Considering what decisions your agents need to make, apply our advanced decision-making framework. You may need to check the docs of <code>Decision</code>.</li> <li>\ud83e\uddea Finally, using <code>Experiment</code> for batch runs and testing different parameters.</li> </ul>"},{"location":"api/api/#operation","title":"Operation","text":"<p>Useful operations snippets and API for better implementation.</p> <ul> <li>\ud83d\udcc1 Learn to create, manage, and operate your agents by referring <code>AgentsContainer</code> and <code>ActorsList</code>.</li> <li>\ud83d\udd59 Relate your model to real time by <code>TimeDriver</code>.</li> <li>\ud83d\udeb6 Actors can be easily moved by referring <code>Movements</code></li> <li>\ud83d\udd17 You may also want to implement interlinks between the actors by referring <code>Links</code>.</li> <li>\ud83c\udfb2 Randomize your agents' performance in batch by checkout <code>ListRandom</code> or use <code>Mesa</code>'s API to do random for a specific Actor.</li> </ul>"},{"location":"api/cells/","title":"agents","text":"<p>               Bases: <code>_LinkNodeCell</code>, <code>_BaseObj</code></p> <p>A patch cell of a <code>RasterLayer</code>. Subclassing this class to create a custom cell. When class attribute <code>max_agents</code> is assigned, the <code>agents</code> property will be limited to the number of agents.</p> <p>Attributes:</p> Name Type Description <code>agents</code> <code>_CellAgentsContainer</code> <p>The agents located at here.</p> <code>layer</code> <code>PatchModule</code> <p>The <code>RasterLayer</code> where this <code>PatchCell</code> belongs.</p> Source code in <code>abses/cells.py</code> <pre><code>def __init__(\n    self,\n    layer: PatchModule,\n    indices: Pos,\n    pos: Optional[Pos] = None,\n):\n    _BaseObj.__init__(self, model=layer.model, observer=True)\n    _LinkNodeCell.__init__(self)\n    self.indices = indices\n    self.pos = pos\n    self._set_layer(layer=layer)\n</code></pre>"},{"location":"api/cells/#abses.cells.PatchCell.layer","title":"layer  <code>property</code>","text":"<pre><code>layer\n</code></pre> <p><code>RasterLayer</code> where this <code>PatchCell</code> belongs.</p>"},{"location":"api/cells/#abses.cells.PatchCell.agents","title":"agents  <code>property</code>","text":"<pre><code>agents\n</code></pre> <p>The agents located at here.</p>"},{"location":"api/cells/#abses.cells.PatchCell.coordinate","title":"coordinate  <code>property</code>","text":"<pre><code>coordinate\n</code></pre> <p>The position of this cell.</p>"},{"location":"api/cells/#abses.cells.PatchCell.geo_type","title":"geo_type  <code>property</code>","text":"<pre><code>geo_type\n</code></pre> <p>Return the geo_type</p>"},{"location":"api/cells/#abses.cells.PatchCell.crs","title":"crs  <code>property</code>","text":"<pre><code>crs\n</code></pre> <p>The crs of this cell, the same as the layer.</p>"},{"location":"api/cells/#abses.cells.PatchCell.get","title":"get","text":"<pre><code>get(attr, target=None, default=None)\n</code></pre> <p>Gets the value of an attribute or registered property. Automatically update the value if it is the dynamic variable of the layer.</p> <p>Parameters:</p> Name Type Description Default <code>attr</code> <code>str</code> <p>The name of attribute to get.</p> required <code>target</code> <code>Optional[TargetName]</code> <p>Optional target name.</p> <code>None</code> <code>default</code> <code>Any</code> <p>Default value if attribute is not found.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>The value of the attribute.</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>Attribute value of the associated patch cell.</p> Source code in <code>abses/cells.py</code> <pre><code>def get(\n    self,\n    attr: str,\n    target: Optional[TargetName] = None,\n    default: Any = None,\n) -&gt; Any:\n    \"\"\"Gets the value of an attribute or registered property.\n    Automatically update the value if it is the dynamic variable of the layer.\n\n    Parameters:\n        attr: The name of attribute to get.\n        target: Optional target name.\n        default: Default value if attribute is not found.\n\n    Returns:\n        Any: The value of the attribute.\n\n    Raises:\n        AttributeError: Attribute value of the associated patch cell.\n    \"\"\"\n    if attr in self.layer.dynamic_variables:\n        self.layer.dynamic_var(attr_name=attr)\n    return super().get(attr=attr, target=target, default=default)\n</code></pre>"},{"location":"api/cells/#abses.cells.PatchCell.neighboring","title":"neighboring","text":"<pre><code>neighboring(\n    moore=False,\n    radius=1,\n    include_center=False,\n    annular=False,\n)\n</code></pre> <p>Get the grid around the patch.</p> <p>Parameters:</p> Name Type Description Default <code>moore</code> <code>bool</code> <p>Whether to include the Moore neighborhood.</p> <code>False</code> <code>radius</code> <code>int</code> <p>The radius of the neighborhood.</p> <code>1</code> <code>include_center</code> <code>bool</code> <p>Whether to include the center cell.</p> <code>False</code> <code>annular</code> <code>bool</code> <p>Whether to use an annular neighborhood.</p> <code>False</code> <p>Returns:</p> Type Description <code>ActorsList[PatchCell]</code> <p>ActorsList[PatchCell]: The neighboring cells.</p> Source code in <code>abses/cells.py</code> <pre><code>def neighboring(\n    self,\n    moore: bool = False,\n    radius: int = 1,\n    include_center: bool = False,\n    annular: bool = False,\n) -&gt; ActorsList[PatchCell]:\n    \"\"\"Get the grid around the patch.\n\n    Parameters:\n        moore: Whether to include the Moore neighborhood.\n        radius: The radius of the neighborhood.\n        include_center: Whether to include the center cell.\n        annular: Whether to use an annular neighborhood.\n\n    Returns:\n        ActorsList[PatchCell]: The neighboring cells.\n    \"\"\"\n    return self.layer.get_neighboring_by_indices(\n        self.indices,\n        moore=moore,\n        radius=radius,\n        include_center=include_center,\n        annular=annular,\n    )\n</code></pre>"},{"location":"api/container/","title":"Actors' Container","text":"<p>               Bases: <code>_AgentsContainer</code></p> <p>AgentsContainer for the MainModel.</p> Source code in <code>abses/container.py</code> <pre><code>def __init__(self, model: MainModel[Any, Any], max_len: None | int = None):\n    if not isinstance(model, Model):\n        raise TypeError(f\"{model} is not a Mesa Model.\")\n    self._model: MainModel = model\n    self._agents = model._all_agents\n    self._max_length = max_len\n</code></pre> <p>               Bases: <code>_AgentsContainer</code></p> <p>Container for agents located at cells.</p> Source code in <code>abses/container.py</code> <pre><code>def __init__(\n    self, model: MainModel[Any, Any], cell: PatchCell, max_len: int | None = None\n):\n    super().__init__(model, max_len)\n    self._agents = AgentSet([], random=model.random)\n    self._cell = cell\n</code></pre>"},{"location":"api/container/#abses.container._ModelAgentsContainer.new_from_graph","title":"new_from_graph","text":"<pre><code>new_from_graph(graph, link_name, actor_cls=Actor, **kwargs)\n</code></pre> <p>Create a set of new agents from networkx graph.</p> Source code in <code>abses/container.py</code> <pre><code>def new_from_graph(\n    self,\n    graph: \"nx.Graph\",\n    link_name: str,\n    actor_cls: Type[Actor] = Actor,\n    **kwargs,\n):\n    \"\"\"Create a set of new agents from networkx graph.\"\"\"\n    actors = []\n    mapping = {}\n    for node, attr in graph.nodes(data=True):\n        unique_id = get_node_unique_id(node=node)\n        actor = self._new_one(unique_id=unique_id, agent_cls=actor_cls, **attr)\n        actors.append(actor)\n        mapping[unique_id] = actor\n    self.model.human.add_links_from_graph(\n        graph, link_name=link_name, mapping_dict=mapping, **kwargs\n    )\n    return ActorsList(model=self.model, objs=actors)\n</code></pre>"},{"location":"api/container/#abses.container._ModelAgentsContainer.new_from_gdf","title":"new_from_gdf","text":"<pre><code>new_from_gdf(gdf, agent_cls=Actor, attrs=False, **kwargs)\n</code></pre> <p>Create actors from a <code>geopandas.GeoDataFrame</code> object.</p> <p>Parameters:</p> Name Type Description Default <code>gdf</code> <code>GeoDataFrame</code> <p>The <code>geopandas.GeoDataFrame</code> object to convert.</p> required <code>unique_id</code> <p>A column name, to be converted to unique index of created geo-agents (Social-ecological system Actors).</p> required <code>agent_cls</code> <code>type[Actor]</code> <p>Agent class to create.</p> <code>Actor</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the column specified by <code>unique_id</code> is not unique.</p> <p>Returns:</p> Type Description <code>ActorsList[Actor]</code> <p>An <code>ActorsList</code> with all new created actors stored.</p> Source code in <code>abses/container.py</code> <pre><code>def new_from_gdf(\n    self,\n    gdf: gpd.GeoDataFrame,\n    agent_cls: type[Actor] = Actor,\n    attrs: IncludeFlag = False,\n    **kwargs,\n) -&gt; ActorsList[Actor]:\n    # TODO: \u8fd9\u4e2a\u65b9\u6cd5\u9700\u8981\u9002\u914d\u5230\u6700\u65b0\u7684 Mesa \u7248\u672c\n    \"\"\"Create actors from a `geopandas.GeoDataFrame` object.\n\n    Parameters:\n        gdf:\n            The `geopandas.GeoDataFrame` object to convert.\n        unique_id:\n            A column name, to be converted to unique index\n            of created geo-agents (Social-ecological system Actors).\n        agent_cls:\n            Agent class to create.\n\n    Raises:\n        ValueError:\n            If the column specified by `unique_id` is not unique.\n\n    Returns:\n        An `ActorsList` with all new created actors stored.\n    \"\"\"\n    # \u68c0\u67e5\u5750\u6807\u53c2\u8003\u7cfb\u662f\u5426\u4e00\u81f4\n    self._check_crs(gdf)\n    # \u770b\u4e00\u4e0b\u54ea\u4e9b\u5c5e\u6027\u662f\u9700\u8981\u52a0\u5165\u5230\u4e3b\u4f53\u7684\n    geo_col = gdf.geometry.name\n    set_attributes = clean_attrs(gdf.columns, attrs, exclude=geo_col)\n    if not isinstance(set_attributes, dict):\n        set_attributes = {col: col for col in set_attributes}\n    # \u521b\u5efa\u4e3b\u4f53\n    agents = []\n    for _, row in gdf.iterrows():\n        geometry = row[geo_col]\n        new_agent = self._new_one(geometry=geometry, agent_cls=agent_cls, **kwargs)\n        new_agent.crs = self.crs\n\n        for col, name in set_attributes.items():\n            setattr(new_agent, name, row[col])\n        agents.append(new_agent)\n    # \u6dfb\u52a0\u4e3b\u4f53\u5230\u6a21\u578b\u5bb9\u5668\u91cc\n    return ActorsList(model=self.model, objs=agents)\n</code></pre>"},{"location":"api/container/#abses.container._CellAgentsContainer.remove","title":"remove","text":"<pre><code>remove(agent=None)\n</code></pre> <p>Remove the given agent from the cell. Generally, it stores all the agents on this cell. Therefore, it is not recommended to use this method directly. Consider to use <code>actor.move.off()</code> to let the actor leave this cell instead.</p> <p>Parameters:</p> Name Type Description Default <code>agent</code> <code>Optional[Actor]</code> <p>The agent (actor) to remove.</p> <code>None</code> <p>Raises:</p> Type Description <code>ABSESpyError</code> <p>If the agent is not on this cell.</p> Source code in <code>abses/container.py</code> <pre><code>def remove(self, agent: Optional[Actor] = None) -&gt; None:\n    \"\"\"Remove the given agent from the cell.\n    Generally, it stores all the agents on this cell.\n    Therefore, it is not recommended to use this method directly.\n    Consider to use `actor.move.off()` to let the actor leave this cell instead.\n\n    Parameters:\n        agent:\n            The agent (actor) to remove.\n\n    Raises:\n        ABSESpyError:\n            If the agent is not on this cell.\n    \"\"\"\n    if agent is None:\n        self._agents.clear()\n        return\n    assert isinstance(agent, Actor), f\"{agent} is not an Actor.\"\n    if agent.at is not self._cell:\n        raise ABSESpyError(f\"{agent} is not on this cell.\")\n    self._agents.remove(agent)\n    del agent.at\n</code></pre>"},{"location":"api/experiment/","title":"Experiment","text":"<p>Experiment class.</p> Source code in <code>abses/experiment.py</code> <pre><code>def __init__(\n    self,\n    model_cls: Type[MainModel],\n    cfg: Configurations,\n    seed: Optional[int] = None,\n    **kwargs,\n):\n    if not issubclass(model_cls, MainModel):\n        raise TypeError(f\"Type {type(model_cls)} is invalid.\")\n    self._job_id = 0\n    self._extra_kwargs = kwargs\n    self._overrides: Dict[str, Any] = {}\n    self._base_seed = seed\n    self._manager = ExperimentManager(model_cls)\n    self.cfg = cfg\n</code></pre>"},{"location":"api/experiment/#abses.experiment.Experiment.model_cls","title":"model_cls  <code>property</code>","text":"<pre><code>model_cls\n</code></pre> <p>Model class.</p>"},{"location":"api/experiment/#abses.experiment.Experiment.cfg","title":"cfg  <code>property</code> <code>writable</code>","text":"<pre><code>cfg\n</code></pre> <p>Configuration</p>"},{"location":"api/experiment/#abses.experiment.Experiment.hydra_config","title":"hydra_config  <code>property</code>","text":"<pre><code>hydra_config\n</code></pre> <p>Hydra config.</p>"},{"location":"api/experiment/#abses.experiment.Experiment.folder","title":"folder  <code>property</code>","text":"<pre><code>folder\n</code></pre> <p>Output dir path.</p>"},{"location":"api/experiment/#abses.experiment.Experiment.outpath","title":"outpath  <code>property</code>","text":"<pre><code>outpath\n</code></pre> <p>Output dir path.</p>"},{"location":"api/experiment/#abses.experiment.Experiment.overrides","title":"overrides  <code>property</code> <code>writable</code>","text":"<pre><code>overrides\n</code></pre> <p>Overrides</p>"},{"location":"api/experiment/#abses.experiment.Experiment.job_id","title":"job_id  <code>property</code>","text":"<pre><code>job_id\n</code></pre> <p>Job id. Each job means a combination of the configuration. If the experiment is running in Hydra, it will return the hydra's job id.</p>"},{"location":"api/experiment/#abses.experiment.Experiment.new","title":"new  <code>classmethod</code>","text":"<pre><code>new(model_cls, cfg, **kwargs)\n</code></pre> <p>Create a new experiment for the singleton class <code>Experiment</code>. This method will delete all currently available exp results and settings. Then, it initialize a new instance of experiment.</p> <p>Parameters:</p> Name Type Description Default <code>model_cls</code> <code>Type[MainModel]</code> <p>Using which model class to initialize the experiment.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>If the model class <code>model_cls</code> is not a valid <code>ABSESpy</code> model.</p> <p>Returns:</p> Type Description <code>'Experiment'</code> <p>An experiment.</p> Source code in <code>abses/experiment.py</code> <pre><code>@classmethod\ndef new(\n    cls, model_cls: Type[MainModel], cfg: Configurations, **kwargs\n) -&gt; \"Experiment\":\n    \"\"\"Create a new experiment for the singleton class `Experiment`.\n    This method will delete all currently available exp results and settings.\n    Then, it initialize a new instance of experiment.\n\n    Parameters:\n        model_cls:\n            Using which model class to initialize the experiment.\n\n    Raises:\n        TypeError:\n            If the model class `model_cls` is not a valid `ABSESpy` model.\n\n    Returns:\n        An experiment.\n    \"\"\"\n    ExperimentManager(model_cls).clean()\n    return cls(model_cls, cfg, **kwargs)\n</code></pre>"},{"location":"api/experiment/#abses.experiment.Experiment.is_hydra_job","title":"is_hydra_job  <code>staticmethod</code>","text":"<pre><code>is_hydra_job()\n</code></pre> <p>Returns True if the experiment is running in Hydra.</p> Source code in <code>abses/experiment.py</code> <pre><code>@staticmethod\ndef is_hydra_job() -&gt; bool:\n    \"\"\"Returns True if the experiment is running in Hydra.\"\"\"\n    return GlobalHydra().is_initialized()\n</code></pre>"},{"location":"api/experiment/#abses.experiment.Experiment.summary","title":"summary","text":"<pre><code>summary()\n</code></pre> <p>Summary of the experiment.</p> Source code in <code>abses/experiment.py</code> <pre><code>def summary(self) -&gt; pd.DataFrame:\n    \"\"\"Summary of the experiment.\"\"\"\n    return self._manager.get_datasets(seed=bool(self._base_seed))\n</code></pre>"},{"location":"api/experiment/#abses.experiment.Experiment.batch_run","title":"batch_run","text":"<pre><code>batch_run(\n    repeats=1,\n    parallels=None,\n    display_progress=True,\n    overrides=None,\n)\n</code></pre> <p>Run the experiment multiple times.</p> Source code in <code>abses/experiment.py</code> <pre><code>def batch_run(\n    self,\n    repeats: int = 1,\n    parallels: Optional[int] = None,\n    display_progress: bool = True,\n    overrides: Optional[Dict[str, str | Iterable[Number]]] = None,\n) -&gt; None:\n    \"\"\"Run the experiment multiple times.\"\"\"\n    cfg = deepcopy(self._cfg)\n\n    if not overrides:\n        # \u5982\u679c\u6ca1\u6709\u8986\u5199\uff0c\u76f4\u63a5\u8fd0\u884c\n        self._batch_run_repeats(cfg, repeats, parallels, display_progress)\n        return\n\n    # \u83b7\u53d6\u6240\u6709\u914d\u7f6e\u7ec4\u5408\n    all_configs = list(self._overriding(cfg, overrides))\n    # \u4f7f\u7528\u4e00\u4e2a\u603b\u8fdb\u5ea6\u6761\n    for config, overrides_ in tqdm(\n        all_configs,\n        disable=not display_progress,\n        desc=f\"{len(all_configs)} jobs (repeats {repeats} times each).\",\n        position=0,\n    ):\n        self.overrides = overrides_\n        # \u5185\u5c42\u4efb\u52a1\u53ea\u663e\u793a\u7b80\u5355\u4fe1\u606f\uff0c\u4e0d\u663e\u793a\u8fdb\u5ea6\u6761\n        self._batch_run_repeats(\n            config,\n            repeats,\n            parallels,\n            display_progress=False,  # \u5173\u95ed\u5185\u5c42\u8fdb\u5ea6\u6761\n        )\n        self._job_id += 1\n    self.overrides = {}\n</code></pre>"},{"location":"api/experiment/#abses.experiment.Experiment.add_hooks","title":"add_hooks","text":"<pre><code>add_hooks(hooks)\n</code></pre> <p>Add hooks to the experiment.</p> Source code in <code>abses/experiment.py</code> <pre><code>def add_hooks(\n    self,\n    hooks: List[HookFunc] | Dict[str, HookFunc] | HookFunc,\n) -&gt; None:\n    \"\"\"Add hooks to the experiment.\"\"\"\n    if hasattr(hooks, \"__call__\"):\n        hooks = [cast(HookFunc, hooks)]\n    if isinstance(hooks, (list, tuple)):\n        for hook in hooks:\n            self._manager.add_a_hook(hook_func=hook)\n    elif isinstance(hooks, dict):\n        for hook_name, hook_func in hooks.items():\n            self._manager.add_a_hook(\n                hook_func=hook_func, hook_name=hook_name\n            )\n    else:\n        raise TypeError(f\"Invalid hooks type: {type(hooks)}.\")\n</code></pre>"},{"location":"api/human/","title":"human","text":""},{"location":"api/human/#major-human-module","title":"Major human module","text":"<p>               Bases: <code>CompositeModule</code>, <code>HumanModule</code>, <code>_LinkContainer</code></p> <p>The Base Human Module.</p> Source code in <code>abses/human.py</code> <pre><code>def __init__(self, model: MainModel[Any, Any], name: str = \"human\"):\n    HumanModule.__init__(self, model, name)\n    CompositeModule.__init__(self, model, name=name)\n    _LinkContainer.__init__(self)\n</code></pre>"},{"location":"api/human/#human-submodule","title":"Human submodule","text":"<p>               Bases: <code>Module</code></p> <p>The <code>Human</code> sub-module base class.</p> Note <p>Look at this tutorial to understand the model structure.</p> <p>Attributes:</p> Name Type Description <code>agents</code> <code>_AgentsContainer</code> <p>The agents container of this ABSESpy model.</p> <code>collections</code> <code>Set[str]</code> <p>Actor collections defined.</p> Source code in <code>abses/human.py</code> <pre><code>def __init__(self, model: MainModel[Any, Any], name: Optional[str] = None):\n    Module.__init__(self, model, name)\n    self._refers: Dict[str, Dict[str, Any]] = {}\n</code></pre>"},{"location":"api/human/#abses.human.HumanModule.agents","title":"agents  <code>property</code>","text":"<pre><code>agents\n</code></pre> <p>The agents container of this ABSESpy model.</p>"},{"location":"api/human/#abses.human.HumanModule.collections","title":"collections  <code>property</code>","text":"<pre><code>collections\n</code></pre> <p>Actor collections defined.</p>"},{"location":"api/human/#abses.human.HumanModule.actors","title":"actors","text":"<pre><code>actors(name=None)\n</code></pre> <p>Different selections of agents</p> Source code in <code>abses/human.py</code> <pre><code>def actors(self, name: Optional[str] = None) -&gt; ActorsList[Actor]:\n    \"\"\"Different selections of agents\"\"\"\n    if name is None:\n        return ActorsList(model=self.model, objs=self.agents)\n    if name not in self._refers:\n        raise KeyError(f\"{name} is not defined.\")\n    selection = self._refers[name]\n    return self.agents.select(**selection)\n</code></pre>"},{"location":"api/human/#abses.human.HumanModule.define","title":"define","text":"<pre><code>define(refer_name, **kwargs)\n</code></pre> <p>Define a query of actors and save it into collections.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <p>defined name of this group of actors.</p> required <code>selection</code> <p>Selection query of <code>Actor</code>.</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If the name is already defined.</p> <p>Returns:</p> Type Description <code>ActorsList[Actor]</code> <p>The list of actors who are satisfied the query condition.</p> Example <pre><code># Create 5 actors to query\nmodel=MainModel()\nmodel.agents.new(Actor, 5)\n\nmodule = HumanModule(model=model)\nactors = module.define(name='first', selection='ids=0')\n&gt;&gt;&gt; len(actors)\n&gt;&gt;&gt; 1\n\n&gt;&gt;&gt; module.actors('first') == actors\n&gt;&gt;&gt; True\n</code></pre> Source code in <code>abses/human.py</code> <pre><code>def define(\n    self,\n    refer_name: str,\n    **kwargs,\n) -&gt; ActorsList[Actor]:\n    \"\"\"Define a query of actors and save it into collections.\n\n    Parameters:\n        name:\n            defined name of this group of actors.\n        selection:\n            Selection query of `Actor`.\n\n    Raises:\n        KeyError:\n            If the name is already defined.\n\n    Returns:\n        The list of actors who are satisfied the query condition.\n\n    Example:\n        ```\n        # Create 5 actors to query\n        model=MainModel()\n        model.agents.new(Actor, 5)\n\n        module = HumanModule(model=model)\n        actors = module.define(name='first', selection='ids=0')\n        &gt;&gt;&gt; len(actors)\n        &gt;&gt;&gt; 1\n\n        &gt;&gt;&gt; module.actors('first') == actors\n        &gt;&gt;&gt; True\n        ```\n    \"\"\"\n    if refer_name in self._refers:\n        raise KeyError(f\"{refer_name} is already defined.\")\n    selected = self.agents.select(**kwargs)\n    self._refers[refer_name] = kwargs.copy()\n    return selected\n</code></pre>"},{"location":"api/layer/","title":"layer","text":"<p>               Bases: <code>Module</code>, <code>RasterLayer</code></p> <p>Base class for managing raster-based spatial modules in ABSESpy.</p> <p>Inherits from both Module and RasterLayer to provide comprehensive spatial data management. Extends mesa-geo's RasterLayer with additional capabilities for: - Agent placement and management - Integration with xarray/rasterio for data I/O - Dynamic attribute handling - Spatial operations and analysis</p> <p>Attributes:</p> Name Type Description <code>cell_properties</code> <code>set[str]</code> <p>Set of accessible cell attributes (decorated by @raster_attribute).</p> <code>attributes</code> <code>set[str]</code> <p>All accessible attributes including cell_properties.</p> <code>shape2d</code> <code>Coordinate</code> <p>Raster dimensions as (height, width).</p> <code>shape3d</code> <code>Coordinate</code> <p>Raster dimensions as (1, height, width) for rasterio compatibility.</p> <code>array_cells</code> <code>NDArray[T]</code> <p>NumPy array of PatchCell objects.</p> <code>coords</code> <code>Coordinate</code> <p>Coordinate system dictionary with 'x' and 'y' arrays.</p> <code>random</code> <code>ListRandom</code> <p>Random selection proxy for cells.</p> <code>mask</code> <code>ndarray</code> <p>Boolean array indicating accessible cells.</p> <code>cells_lst</code> <code>ActorsList[PatchCell]</code> <p>ActorsList containing all cells.</p> <code>plot</code> <code>_VizNature</code> <p>Visualization interface for the module.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>MainModel[Any, Any]</code> <p>Parent model instance.</p> required <code>name</code> <code>Optional[str]</code> <p>Module identifier. Defaults to lowercase class name.</p> <code>None</code> <code>cell_cls</code> <code>Type[PatchCell]</code> <p>Class to use for creating cells. Defaults to PatchCell.</p> <code>PatchCell</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed to RasterLayer initialization.</p> <code>{}</code> Source code in <code>abses/patch.py</code> <pre><code>def __init__(\n    self,\n    model: MainModel[Any, Any],\n    name: Optional[str] = None,\n    cell_cls: Type[PatchCell] = PatchCell,\n    **kwargs: Any,\n):\n    \"\"\"Initializes a new PatchModule instance.\n\n    Args:\n        model: Parent model instance.\n        name: Module identifier. Defaults to lowercase class name.\n        cell_cls: Class to use for creating cells. Defaults to PatchCell.\n        **kwargs: Additional arguments passed to RasterLayer initialization.\n    \"\"\"\n    Module.__init__(self, model, name=name)\n    RasterLayer.__init__(self, model=model, cell_cls=cell_cls, **kwargs)\n    logger.info(\"Initializing a new Model Layer...\")\n    self._mask: np.ndarray = np.ones(self.shape2d).astype(bool)\n</code></pre>"},{"location":"api/layer/#abses.nature.PatchModule.cells_lst","title":"cells_lst  <code>cached</code> <code>property</code>","text":"<pre><code>cells_lst\n</code></pre> <p>The cells stored in this layer.</p>"},{"location":"api/layer/#abses.nature.PatchModule.mask","title":"mask  <code>property</code> <code>writable</code>","text":"<pre><code>mask\n</code></pre> <p>Where is not accessible.</p>"},{"location":"api/layer/#abses.nature.PatchModule.cell_properties","title":"cell_properties  <code>property</code>","text":"<pre><code>cell_properties\n</code></pre> <p>The accessible attributes of cells stored in this layer. All <code>PatchCell</code> methods decorated by <code>raster_attribute</code> should be appeared here.</p>"},{"location":"api/layer/#abses.nature.PatchModule.xda","title":"xda  <code>property</code>","text":"<pre><code>xda\n</code></pre> <p>Get the xarray raster layer with spatial coordinates.</p>"},{"location":"api/layer/#abses.nature.PatchModule.plot","title":"plot  <code>cached</code> <code>property</code>","text":"<pre><code>plot\n</code></pre> <p>Plotting</p>"},{"location":"api/layer/#abses.nature.PatchModule.attributes","title":"attributes  <code>property</code>","text":"<pre><code>attributes\n</code></pre> <p>All accessible attributes from this layer.</p>"},{"location":"api/layer/#abses.nature.PatchModule.shape2d","title":"shape2d  <code>property</code>","text":"<pre><code>shape2d\n</code></pre> <p>Raster shape in 2D (height, width). This is useful when working with 2d <code>numpy.array</code>.</p>"},{"location":"api/layer/#abses.nature.PatchModule.shape3d","title":"shape3d  <code>property</code>","text":"<pre><code>shape3d\n</code></pre> <p>Raster shape in 3D (1, heigh, width). This is useful when working with <code>rasterio</code> band.</p>"},{"location":"api/layer/#abses.nature.PatchModule.cells","title":"cells  <code>cached</code> <code>property</code>","text":"<pre><code>cells\n</code></pre> <p>The cells stored in this layer.</p>"},{"location":"api/layer/#abses.nature.PatchModule.array_cells","title":"array_cells  <code>cached</code> <code>property</code>","text":"<pre><code>array_cells\n</code></pre> <p>Array type of the <code>PatchCell</code> stored in this module.</p>"},{"location":"api/layer/#abses.nature.PatchModule.coords","title":"coords  <code>property</code>","text":"<pre><code>coords\n</code></pre> <p>Coordinate system of the raster data.</p> <p>This is useful when working with <code>xarray.DataArray</code>.</p>"},{"location":"api/layer/#abses.nature.PatchModule.agents","title":"agents  <code>property</code>","text":"<pre><code>agents\n</code></pre> <p>Return a list of all agents in the module.</p>"},{"location":"api/layer/#abses.nature.PatchModule.random","title":"random  <code>property</code>","text":"<pre><code>random\n</code></pre> <p>Randomly</p>"},{"location":"api/layer/#abses.nature.PatchModule.transform_coord","title":"transform_coord","text":"<pre><code>transform_coord(row, col)\n</code></pre> <p>Converts grid indices to real-world coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>row</code> <code>int</code> <p>Grid row index.</p> required <code>col</code> <code>int</code> <p>Grid column index.</p> required <p>Returns:</p> Type Description <code>Coordinate</code> <p>Tuple of (x, y) real-world coordinates.</p> <p>Raises:</p> Type Description <code>IndexError</code> <p>If indices are out of bounds.</p> Source code in <code>abses/patch.py</code> <pre><code>def transform_coord(self, row: int, col: int) -&gt; Coordinate:\n    \"\"\"Converts grid indices to real-world coordinates.\n\n    Args:\n        row: Grid row index.\n        col: Grid column index.\n\n    Returns:\n        Tuple of (x, y) real-world coordinates.\n\n    Raises:\n        IndexError: If indices are out of bounds.\n    \"\"\"\n    if self.indices_out_of_bounds(pos=(row, col)):\n        raise IndexError(f\"Out of bounds: {row, col}\")\n    return self.transform * (col, row)\n</code></pre>"},{"location":"api/layer/#abses.nature.PatchModule.dynamic_var","title":"dynamic_var","text":"<pre><code>dynamic_var(attr_name, dtype='numpy')\n</code></pre> <p>Update and get dynamic variable.</p> <p>Parameters:</p> Name Type Description Default <code>attr_name</code> <code>str</code> <p>The dynamic variable to retrieve.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>2D numpy.ndarray data of the variable.</p> Source code in <code>abses/patch.py</code> <pre><code>def dynamic_var(\n    self,\n    attr_name: str,\n    dtype: Literal[\"numpy\", \"xarray\"] = \"numpy\",\n) -&gt; np.ndarray:\n    \"\"\"Update and get dynamic variable.\n\n    Parameters:\n        attr_name:\n            The dynamic variable to retrieve.\n\n    Returns:\n        2D numpy.ndarray data of the variable.\n    \"\"\"\n    # \u83b7\u53d6\u52a8\u6001\u53d8\u91cf\uff0c\u53ca\u5176\u9644\u52a0\u5c5e\u6027\n    array = super().dynamic_var(attr_name)\n    assert isinstance(array, (np.ndarray, xr.DataArray, xr.Dataset))\n    kwargs = super().dynamic_variables[attr_name].attrs\n    # \u5c06\u77e9\u9635\u8f6c\u6362\u4e3a\u4e09\u7ef4\uff0c\u5e76\u66f4\u65b0\u7a7a\u95f4\u6570\u636e\n    self.apply_raster(array, attr_name=attr_name, **kwargs)\n    if dtype == \"numpy\":\n        return self.get_raster(attr_name, update=False)\n    if dtype == \"xarray\":\n        return self.get_xarray(attr_name, update=False)\n    raise ValueError(f\"Unknown expected dtype {dtype}.\")\n</code></pre>"},{"location":"api/layer/#abses.nature.PatchModule.get_xarray","title":"get_xarray","text":"<pre><code>get_xarray(attr_name=None, update=True)\n</code></pre> <p>Creates an xarray DataArray representation with spatial coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>attr_name</code> <code>Optional[str]</code> <p>Attribute to retrieve. If None, returns all attributes.</p> <code>None</code> <code>update</code> <code>bool</code> <p>If True, updates dynamic variables before retrieval.</p> <code>True</code> <p>Returns:</p> Type Description <code>DataArray</code> <p>xarray.DataArray with spatial coordinates and CRS information.</p> Source code in <code>abses/patch.py</code> <pre><code>def get_xarray(\n    self,\n    attr_name: Optional[str] = None,\n    update: bool = True,\n) -&gt; xr.DataArray:\n    \"\"\"Creates an xarray DataArray representation with spatial coordinates.\n\n    Args:\n        attr_name: Attribute to retrieve. If None, returns all attributes.\n        update: If True, updates dynamic variables before retrieval.\n\n    Returns:\n        xarray.DataArray with spatial coordinates and CRS information.\n    \"\"\"\n    data = self.get_raster(attr_name=attr_name, update=update)\n    if attr_name:\n        name = attr_name\n        data = data.reshape(self.shape2d)\n        coords = self.coords\n    else:\n        coords = {\"variable\": list(self.attributes)}\n        coords |= self.coords\n        name = self.name\n    return xr.DataArray(\n        data=data,\n        name=name,\n        coords=coords,\n    ).rio.write_crs(self.crs)\n</code></pre>"},{"location":"api/layer/#abses.nature.PatchModule.select","title":"select","text":"<pre><code>select(where=None)\n</code></pre> <p>Selects cells based on specified criteria.</p> <p>Parameters:</p> Name Type Description Default <code>where</code> <code>Optional[CellFilter]</code> <p>Selection filter. Can be: - None: Select all cells - str: Select by attribute name - numpy.ndarray: Boolean mask array - Shapely.Geometry: Select cells intersecting geometry</p> <code>None</code> <p>Returns:</p> Type Description <code>ActorsList[PatchCell]</code> <p>ActorsList containing selected cells.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If where parameter is of unsupported type.</p> Example Source code in <code>abses/patch.py</code> <pre><code>def select(\n    self,\n    where: Optional[CellFilter] = None,\n) -&gt; ActorsList[PatchCell]:\n    \"\"\"Selects cells based on specified criteria.\n\n    Args:\n        where: Selection filter. Can be:\n            - None: Select all cells\n            - str: Select by attribute name\n            - numpy.ndarray: Boolean mask array\n            - Shapely.Geometry: Select cells intersecting geometry\n\n    Returns:\n        ActorsList containing selected cells.\n\n    Raises:\n        TypeError: If where parameter is of unsupported type.\n\n    Example:\n        &gt;&gt;&gt; # Select cells with elevation &gt; 100\n        &gt;&gt;&gt; high_cells = module.select(module.get_raster(\"elevation\") &gt; 100)\n        &gt;&gt;&gt; # Select cells within polygon\n        &gt;&gt;&gt; cells = module.select(polygon)\n    \"\"\"\n    if isinstance(where, Geometry):\n        mask_ = self._select_by_geometry(geometry=where)\n    elif isinstance(where, (np.ndarray, str, xr.DataArray)) or where is None:\n        mask_ = self._attr_or_array(where).reshape(self.shape2d)\n    else:\n        raise TypeError(f\"{type(where)} is not supported for selecting cells.\")\n    mask_ = np.nan_to_num(mask_, nan=0.0).astype(bool)\n    return ActorsList(self.model, self.array_cells[mask_])\n</code></pre>"},{"location":"api/layer/#abses.nature.PatchModule.select--select-cells-with-elevation-100","title":"Select cells with elevation &gt; 100","text":"<p>high_cells = module.select(module.get_raster(\"elevation\") &gt; 100)</p>"},{"location":"api/layer/#abses.nature.PatchModule.select--select-cells-within-polygon","title":"Select cells within polygon","text":"<p>cells = module.select(polygon)</p>"},{"location":"api/layer/#abses.nature.PatchModule.apply","title":"apply","text":"<pre><code>apply(ufunc, *args, **kwargs)\n</code></pre> <p>Apply a function to array cells.</p> <p>Parameters:</p> Name Type Description Default <code>ufunc</code> <code>Callable[..., Any]</code> <p>A function to apply.</p> required <code>*args</code> <code>Any</code> <p>Positional arguments to pass to the function.</p> <code>()</code> <code>**kwargs</code> <code>Any</code> <p>Keyword arguments to pass to the function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>The result of the function applied to the array cells.</p> Source code in <code>abses/patch.py</code> <pre><code>def apply(self, ufunc: Callable[..., Any], *args: Any, **kwargs: Any) -&gt; np.ndarray:\n    \"\"\"Apply a function to array cells.\n\n    Parameters:\n        ufunc:\n            A function to apply.\n        *args:\n            Positional arguments to pass to the function.\n        **kwargs:\n            Keyword arguments to pass to the function.\n\n    Returns:\n        The result of the function applied to the array cells.\n    \"\"\"\n    func = functools.partial(ufunc, *args, **kwargs)\n    return np.vectorize(func)(self.array_cells, *args, **kwargs)\n</code></pre>"},{"location":"api/layer/#abses.nature.PatchModule.coord_iter","title":"coord_iter","text":"<pre><code>coord_iter()\n</code></pre> <p>An iterator that returns coordinates as well as cell contents.</p> Source code in <code>abses/patch.py</code> <pre><code>def coord_iter(self) -&gt; Iterator[tuple[Coordinate, PatchCell]]:\n    \"\"\"\n    An iterator that returns coordinates as well as cell contents.\n    \"\"\"\n    return np.ndenumerate(self.array_cells)\n</code></pre>"},{"location":"api/layer/#abses.nature.PatchModule.apply_raster","title":"apply_raster","text":"<pre><code>apply_raster(data, attr_name=None, **kwargs)\n</code></pre> <p>Applies raster data to cells as attributes.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Raster</code> <p>Input raster data. Can be: - numpy.ndarray: 2D array matching module shape - xarray.DataArray: With spatial coordinates - xarray.Dataset: With named variables</p> required <code>attr_name</code> <code>Optional[str]</code> <p>Name for the new attribute. Required for xarray.Dataset.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional options: cover_crs: Whether to override input data CRS resampling_method: Method for resampling (\"nearest\", etc.) flipud: Whether to flip data vertically</p> <code>{}</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If attr_name not provided for Dataset input.</p> <code>ValueError</code> <p>If data shape doesn't match module shape.</p> Example Source code in <code>abses/patch.py</code> <pre><code>def apply_raster(\n    self, data: Raster, attr_name: Optional[str] = None, **kwargs: Any\n) -&gt; None:\n    \"\"\"Applies raster data to cells as attributes.\n\n    Args:\n        data: Input raster data. Can be:\n            - numpy.ndarray: 2D array matching module shape\n            - xarray.DataArray: With spatial coordinates\n            - xarray.Dataset: With named variables\n        attr_name: Name for the new attribute. Required for xarray.Dataset.\n        **kwargs: Additional options:\n            cover_crs: Whether to override input data CRS\n            resampling_method: Method for resampling (\"nearest\", etc.)\n            flipud: Whether to flip data vertically\n\n    Raises:\n        ValueError: If attr_name not provided for Dataset input.\n        ValueError: If data shape doesn't match module shape.\n\n    Example:\n        &gt;&gt;&gt; # Apply elevation data\n        &gt;&gt;&gt; module.apply_raster(elevation_array, attr_name=\"elevation\")\n        &gt;&gt;&gt; # Apply data from xarray\n        &gt;&gt;&gt; module.apply_raster(xda, resampling_method=\"bilinear\")\n    \"\"\"\n    if isinstance(data, np.ndarray):\n        self._add_attribute(data, attr_name, **kwargs)\n    elif isinstance(data, xr.DataArray):\n        self._add_dataarray(data, attr_name, **kwargs)\n    elif isinstance(data, xr.Dataset):\n        if attr_name is None:\n            raise ValueError(\"Attribute name is required for xr.Dataset.\")\n        dataarray = data[attr_name]\n        self._add_dataarray(dataarray, attr_name, **kwargs)\n</code></pre>"},{"location":"api/layer/#abses.nature.PatchModule.apply_raster--apply-elevation-data","title":"Apply elevation data","text":"<p>module.apply_raster(elevation_array, attr_name=\"elevation\")</p>"},{"location":"api/layer/#abses.nature.PatchModule.apply_raster--apply-data-from-xarray","title":"Apply data from xarray","text":"<p>module.apply_raster(xda, resampling_method=\"bilinear\")</p>"},{"location":"api/layer/#abses.nature.PatchModule.get_raster","title":"get_raster","text":"<pre><code>get_raster(attr_name=None, update=True)\n</code></pre> <p>Obtaining the Raster layer by attribute.</p> <p>Parameters:</p> Name Type Description Default <code>attr_name</code> <code>Optional[str]</code> <p>The attribute to retrieve. If None (by default), retrieve all attributes as a 3D array.</p> <code>None</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>A 3D array of attribute.</p> Source code in <code>abses/patch.py</code> <pre><code>def get_raster(\n    self,\n    attr_name: Optional[str] = None,\n    update: bool = True,\n) -&gt; np.ndarray:\n    \"\"\"Obtaining the Raster layer by attribute.\n\n    Parameters:\n        attr_name:\n            The attribute to retrieve.\n            If None (by default), retrieve all attributes as a 3D array.\n\n    Returns:\n        A 3D array of attribute.\n    \"\"\"\n    if attr_name in self.dynamic_variables and update:\n        return self.dynamic_var(attr_name=attr_name).reshape(self.shape3d)\n    if attr_name is not None and attr_name not in self.attributes:\n        raise ValueError(\n            f\"Attribute {attr_name} does not exist. \"\n            f\"Choose from {self.attributes}, or set `attr_name` to `None` to retrieve all.\"\n        )\n    if attr_name is None:\n        assert bool(self.attributes), \"No attribute available.\"\n        attr_names = self.attributes\n    else:\n        attr_names = {attr_name}\n    data = []\n    for name in attr_names:\n        array = np.vectorize(getattr)(self.array_cells, name)\n        data.append(array)\n    return np.stack(data)\n</code></pre>"},{"location":"api/layer/#abses.nature.PatchModule.reproject","title":"reproject","text":"<pre><code>reproject(xda, resampling='nearest', **kwargs)\n</code></pre> <p>Reproject the xarray data to the same CRS as this layer.</p> Source code in <code>abses/patch.py</code> <pre><code>def reproject(\n    self,\n    xda: xr.DataArray,\n    resampling: Resampling | str = \"nearest\",\n    **kwargs,\n) -&gt; xr.DataArray:\n    \"\"\"Reproject the xarray data to the same CRS as this layer.\"\"\"\n    if isinstance(resampling, str):\n        resampling = getattr(Resampling, resampling)\n    return xda.rio.reproject_match(self.xda, resampling=resampling, **kwargs)\n</code></pre>"},{"location":"api/layer/#abses.nature.PatchModule.get_neighboring_cells","title":"get_neighboring_cells","text":"<pre><code>get_neighboring_cells(\n    pos, moore, include_center=False, radius=1\n)\n</code></pre> <p>Gets neighboring cells around a position.</p> <p>Parameters:</p> Name Type Description Default <code>pos</code> <code>Coordinate</code> <p>Center position (x, y).</p> required <code>moore</code> <code>bool</code> <p>If True, uses Moore neighborhood (8 neighbors).   If False, uses von Neumann neighborhood (4 neighbors).</p> required <code>include_center</code> <code>bool</code> <p>Whether to include the center cell.</p> <code>False</code> <code>radius</code> <code>int</code> <p>Neighborhood radius in cells.</p> <code>1</code> <p>Returns:</p> Type Description <code>ActorsList[PatchCell]</code> <p>ActorsList containing neighboring cells.</p> Example Source code in <code>abses/patch.py</code> <pre><code>def get_neighboring_cells(\n    self,\n    pos: Coordinate,\n    moore: bool,\n    include_center: bool = False,\n    radius: int = 1,\n) -&gt; ActorsList[PatchCell]:\n    \"\"\"Gets neighboring cells around a position.\n\n    Args:\n        pos: Center position (x, y).\n        moore: If True, uses Moore neighborhood (8 neighbors).\n              If False, uses von Neumann neighborhood (4 neighbors).\n        include_center: Whether to include the center cell.\n        radius: Neighborhood radius in cells.\n\n    Returns:\n        ActorsList containing neighboring cells.\n\n    Example:\n        &gt;&gt;&gt; # Get Moore neighborhood with radius 2\n        &gt;&gt;&gt; neighbors = module.get_neighboring_cells((5,5), moore=True, radius=2)\n    \"\"\"\n    cells = super().get_neighboring_cells(pos, moore, include_center, radius)\n    return ActorsList(self.model, cells)\n</code></pre>"},{"location":"api/layer/#abses.nature.PatchModule.get_neighboring_cells--get-moore-neighborhood-with-radius-2","title":"Get Moore neighborhood with radius 2","text":"<p>neighbors = module.get_neighboring_cells((5,5), moore=True, radius=2)</p>"},{"location":"api/layer/#abses.nature.PatchModule.get_neighboring_by_indices","title":"get_neighboring_by_indices  <code>cached</code>","text":"<pre><code>get_neighboring_by_indices(\n    indices,\n    moore,\n    include_center=False,\n    radius=1,\n    annular=False,\n)\n</code></pre> <p>Getting neighboring positions of the given coordinate.</p> <p>Parameters:</p> Name Type Description Default <code>indices</code> <code>Coordinate</code> <p>The indices to get the neighborhood.</p> required <code>moore</code> <code>bool</code> <p>Whether to use Moore neighborhood. If False, use Von Neumann neighborhood.</p> required <code>include_center</code> <code>bool</code> <p>Whether to include the center cell. Default is False.</p> <code>False</code> <code>radius</code> <code>int</code> <p>The radius of the neighborhood. Default is 1.</p> <code>1</code> <code>annular</code> <code>bool</code> <p>Whether to use annular (ring) neighborhood. Default is False.</p> <code>False</code> <p>Returns:</p> Type Description <code>ActorsList[PatchCell]</code> <p>An <code>ActorsList</code> of neighboring cells.</p> Source code in <code>abses/patch.py</code> <pre><code>@functools.lru_cache(maxsize=1000)\ndef get_neighboring_by_indices(\n    self,\n    indices: Coordinate,\n    moore: bool,\n    include_center: bool = False,\n    radius: int = 1,\n    annular: bool = False,\n) -&gt; ActorsList[PatchCell]:\n    \"\"\"Getting neighboring positions of the given coordinate.\n\n    Parameters:\n        indices:\n            The indices to get the neighborhood.\n        moore:\n            Whether to use Moore neighborhood.\n            If False, use Von Neumann neighborhood.\n        include_center:\n            Whether to include the center cell.\n            Default is False.\n        radius:\n            The radius of the neighborhood.\n            Default is 1.\n        annular:\n            Whether to use annular (ring) neighborhood.\n            Default is False.\n\n    Returns:\n        An `ActorsList` of neighboring cells.\n    \"\"\"\n    row, col = indices\n    mask_arr = np.zeros(self.shape2d, dtype=bool)\n    mask_arr[row, col] = True\n    mask_arr = get_buffer(mask_arr, radius=radius, moor=moore, annular=annular)\n    mask_arr[row, col] = include_center\n    return ActorsList(self.model, self.array_cells[mask_arr])\n</code></pre>"},{"location":"api/layer/#abses.nature.PatchModule.indices_out_of_bounds","title":"indices_out_of_bounds","text":"<pre><code>indices_out_of_bounds(pos)\n</code></pre> <p>Determines whether position is off the grid.</p> <p>Parameters:</p> Name Type Description Default <code>pos</code> <code>Coordinate</code> <p>Position to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if position is off the grid, False otherwise.</p> Source code in <code>abses/patch.py</code> <pre><code>def indices_out_of_bounds(self, pos: Coordinate) -&gt; bool:\n    \"\"\"\n    Determines whether position is off the grid.\n\n    Parameters:\n        pos: Position to check.\n\n    Returns:\n        True if position is off the grid, False otherwise.\n    \"\"\"\n\n    row, col = pos\n    return row &lt; 0 or row &gt;= self.height or col &lt; 0 or col &gt;= self.width\n</code></pre>"},{"location":"api/links/","title":"Agents' Interlinks","text":"<p>Proxy class for managing links on a node.</p> <p>Provides convenient methods for creating, checking and removing links.</p> <p>Attributes:</p> Name Type Description <code>node</code> <code>LinkingNode</code> <p>The node this proxy manages links for.</p> <code>model</code> <code>MainModel</code> <p>The main model instance.</p> <code>human</code> <code>_LinkContainer</code> <p>The link container instance.</p> Source code in <code>abses/links.py</code> <pre><code>def __init__(self, node: LinkingNode, model: MainModel) -&gt; None:\n    self.node: LinkingNode = node\n    self.model: MainModel = model\n    self.human: _LinkContainer = model.human\n</code></pre>"},{"location":"api/links/#abses.links._LinkProxy.owning","title":"owning","text":"<pre><code>owning(direction=None)\n</code></pre> <p>Links that this object has.</p> <p>Parameters:</p> Name Type Description Default <code>direction</code> <code>Direction</code> <p>The direction of the link ('in' or 'out'). If None, return both out links and in links.</p> <code>None</code> <p>Returns:</p> Type Description <code>Tuple[str, ...]</code> <p>The links that this object has.</p> Source code in <code>abses/links.py</code> <pre><code>def owning(self, direction: Direction = None) -&gt; Tuple[str, ...]:\n    \"\"\"Links that this object has.\n\n    Parameters:\n        direction:\n            The direction of the link ('in' or 'out').\n            If None, return both out links and in links.\n\n    Returns:\n        The links that this object has.\n    \"\"\"\n    return self.human.owns_links(self.node, direction=direction)\n</code></pre>"},{"location":"api/links/#abses.links._LinkProxy.get","title":"get","text":"<pre><code>get(link_name=None, direction='out', default=...)\n</code></pre> <p>Gets nodes linked to this node.</p> <p>Parameters:</p> Name Type Description Default <code>link_name</code> <code>Optional[str]</code> <p>Type of links to get. If None, gets all types.</p> <code>None</code> <code>direction</code> <code>Direction</code> <p>Direction of links to get: - \"out\": outgoing links - \"in\": incoming links - None: both directions</p> <code>'out'</code> <code>default</code> <code>Any</code> <p>Value to return if link type not found.</p> <code>...</code> <p>Returns:</p> Type Description <code>ActorsList[LinkingNode]</code> <p>List of linked nodes.</p> Source code in <code>abses/links.py</code> <pre><code>def get(\n    self,\n    link_name: Optional[str] = None,\n    direction: Direction = \"out\",\n    default: Any = ...,\n) -&gt; ActorsList[LinkingNode]:\n    \"\"\"Gets nodes linked to this node.\n\n    Args:\n        link_name: Type of links to get. If None, gets all types.\n        direction: Direction of links to get:\n            - \"out\": outgoing links\n            - \"in\": incoming links\n            - None: both directions\n        default: Value to return if link type not found.\n\n    Returns:\n        List of linked nodes.\n    \"\"\"\n    agents = self.human.linked(\n        self.node, link_name, direction=direction, default=default\n    )\n    return ActorsList(self.model, agents)\n</code></pre>"},{"location":"api/links/#abses.links._LinkProxy.has","title":"has","text":"<pre><code>has(link_name, node=None)\n</code></pre> <p>Check if the node has the link.</p> <p>Parameters:</p> Name Type Description Default <code>link_name</code> <code>str</code> <p>The name of the link.</p> required <code>node</code> <code>Optional[LinkingNode]</code> <p>The node to check if it has the link with the current node. If None, check if the current node has any link.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple[bool, bool]</code> <p>A tuple of two booleans. The first element is True if the link exists from me to other. The second element is True if the link exists from other to me.</p> Source code in <code>abses/links.py</code> <pre><code>def has(\n    self, link_name: str, node: Optional[LinkingNode] = None\n) -&gt; Tuple[bool, bool]:\n    \"\"\"Check if the node has the link.\n\n    Parameters:\n        link_name:\n            The name of the link.\n        node:\n            The node to check if it has the link with the current node.\n            If None, check if the current node has any link.\n\n    Returns:\n        tuple:\n            A tuple of two booleans.\n            The first element is True if the link exists from me to other.\n            The second element is True if the link exists from other to me.\n    \"\"\"\n    if node is None:\n        has_in = link_name in self.owning(\"in\")\n        has_out = link_name in self.owning(\"out\")\n        return has_out, has_in\n    return self.human.has_link(link_name, self.node, node)\n</code></pre>"},{"location":"api/links/#abses.links._LinkProxy.to","title":"to","text":"<pre><code>to(node, link_name, mutual=False)\n</code></pre> <p>Creates an outgoing link to another node.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>LinkingNode</code> <p>The target node to link to.</p> required <code>link_name</code> <code>str</code> <p>The type of link to create.</p> required <code>mutual</code> <code>bool</code> <p>If True, creates links in both directions.</p> <code>False</code> Source code in <code>abses/links.py</code> <pre><code>def to(self, node: LinkingNode, link_name: str, mutual: bool = False) -&gt; None:\n    \"\"\"Creates an outgoing link to another node.\n\n    Args:\n        node: The target node to link to.\n        link_name: The type of link to create.\n        mutual: If True, creates links in both directions.\n    \"\"\"\n    self.human.add_a_link(\n        link_name=link_name, source=self.node, target=node, mutual=mutual\n    )\n</code></pre>"},{"location":"api/links/#abses.links._LinkProxy.by","title":"by","text":"<pre><code>by(node, link_name, mutual=False)\n</code></pre> <p>Make this node linked by another node.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>LinkingNode</code> <p>The node to link by.</p> required <code>link_name</code> <code>str</code> <p>The name of the link.</p> required <code>mutual</code> <code>bool</code> <p>If the link is mutual. Defaults to False.</p> <code>False</code> Source code in <code>abses/links.py</code> <pre><code>def by(self, node: LinkingNode, link_name: str, mutual: bool = False) -&gt; None:\n    \"\"\"Make this node linked by another node.\n\n    Parameters:\n        node:\n            The node to link by.\n        link_name:\n            The name of the link.\n        mutual:\n            If the link is mutual. Defaults to False.\n    \"\"\"\n    self.human.add_a_link(\n        link_name=link_name, source=node, target=self.node, mutual=mutual\n    )\n</code></pre>"},{"location":"api/links/#abses.links._LinkProxy.unlink","title":"unlink","text":"<pre><code>unlink(node, link_name, mutual=False)\n</code></pre> <p>Remove the link between me and another node.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>LinkingNode</code> <p>The node to unlink with.</p> required <code>link_name</code> <code>str</code> <p>The name of the link.</p> required <code>mutual</code> <code>bool</code> <p>If delete link mutually. Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>ABSESpyError</code> <p>If the link from source to target does not exist.</p> Source code in <code>abses/links.py</code> <pre><code>def unlink(self, node: LinkingNode, link_name: str, mutual: bool = False):\n    \"\"\"Remove the link between me and another node.\n\n    Parameters:\n        node:\n            The node to unlink with.\n        link_name:\n            The name of the link.\n        mutual:\n            If delete link mutually. Defaults to False.\n\n    Raises:\n        ABSESpyError:\n            If the link from source to target does not exist.\n    \"\"\"\n    self.human.remove_a_link(\n        link_name=link_name, source=self.node, target=node, mutual=mutual\n    )\n</code></pre>"},{"location":"api/links/#abses.links._LinkProxy.clean","title":"clean","text":"<pre><code>clean(link_name=None, direction=None)\n</code></pre> <p>Clean all the related links from this node.</p> <p>Parameters:</p> Name Type Description Default <code>link_name</code> <code>Optional[str]</code> <p>The name of the link. If None, clean all related links for the node.</p> <code>None</code> <code>direction</code> <code>Direction</code> <p>The direction of the link ('in' or 'out'). If None, clean both directions (both out links and in links).</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the direction is not 'in' or 'out'.</p> Source code in <code>abses/links.py</code> <pre><code>def clean(self, link_name: Optional[str] = None, direction: Direction = None):\n    \"\"\"Clean all the related links from this node.\n\n    Parameters:\n        link_name:\n            The name of the link.\n            If None, clean all related links for the node.\n        direction:\n            The direction of the link ('in' or 'out').\n            If None, clean both directions (both out links and in links).\n\n    Raises:\n        ValueError:\n            If the direction is not 'in' or 'out'.\n    \"\"\"\n    self.human.clean_links_of(self.node, link_name=link_name, direction=direction)\n</code></pre>"},{"location":"api/model/","title":"model","text":"<p>               Bases: <code>Generic[H, N]</code>, <code>Model</code>, <code>_Notice</code>, <code>_States</code></p> <p>Base class of a main ABSESpy model.</p> <p>A MainModel instance represents the core simulation environment that coordinates human and natural subsystems.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name of the model (defaults to lowercase class name).</p> <code>settings</code> <code>DictConfig</code> <p>Structured parameters for all model components. Allows nested access like model.nature.params.parameter_name.</p> <code>human</code> <code>Union[H, BaseHuman]</code> <p>The Human subsystem module.</p> <code>nature</code> <code>Union[N, BaseNature]</code> <p>The Nature subsystem module.</p> <code>time</code> <code>TimeDriver</code> <p>Time driver controlling simulation progression.</p> <code>params</code> <code>DictConfig</code> <p>Model parameters (alias: .p).</p> <code>run_id</code> <code>int | None</code> <p>Identifier for current model run (useful in batch runs).</p> <code>agents</code> <code>_ModelAgentsContainer</code> <p>Container for all active agents. Provides methods for agent management.</p> <code>actors</code> <code>ActorsList[Actor]</code> <p>List of all agents currently on the earth (in a PatchCell).</p> <code>outpath</code> <code>Path</code> <p>Directory path for model outputs.</p> <code>version</code> <code>str</code> <p>Current version of the model.</p> <code>datasets</code> <code>DictConfig</code> <p>Available datasets (alias: .ds).</p> <code>plot</code> <code>_VizModel</code> <p>Visualization interface for the model.</p> <p>Parameters:</p> Name Type Description Default <code>parameters</code> <code>DictConfig</code> <p>Configuration dictionary for model parameters.</p> <code>DictConfig({})</code> <code>human_class</code> <code>Optional[Type[H]]</code> <p>Class to use for human subsystem (defaults to BaseHuman).</p> <code>None</code> <code>nature_class</code> <code>Optional[Type[N]]</code> <p>Class to use for nature subsystem (defaults to BaseNature).</p> <code>None</code> <code>run_id</code> <code>Optional[int]</code> <p>Identifier for this model run.</p> <code>None</code> <code>outpath</code> <code>Optional[Path]</code> <p>Directory path for model outputs.</p> <code>None</code> <code>experiment</code> <code>Optional[Experiment]</code> <p>Associated experiment instance.</p> <code>None</code> <code>**kwargs</code> <code>Optional[Any]</code> <p>Additional model parameters.</p> <code>{}</code> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If human_class or nature_class are not valid subclasses.</p> Source code in <code>abses/main.py</code> <pre><code>def __init__(\n    self,\n    parameters: DictConfig = DictConfig({}),\n    human_class: Optional[Type[H]] = None,\n    nature_class: Optional[Type[N]] = None,\n    run_id: Optional[int] = None,\n    seed: Optional[int] = None,\n    outpath: Optional[Path] = None,\n    experiment: Optional[Experiment] = None,\n    **kwargs: Optional[Any],\n) -&gt; None:\n    \"\"\"Initializes a new MainModel instance.\n\n    Args:\n        parameters: Configuration dictionary for model parameters.\n        human_class: Class to use for human subsystem (defaults to BaseHuman).\n        nature_class: Class to use for nature subsystem (defaults to BaseNature).\n        run_id: Identifier for this model run.\n        outpath: Directory path for model outputs.\n        experiment: Associated experiment instance.\n        **kwargs: Additional model parameters.\n\n    Raises:\n        AssertionError: If human_class or nature_class are not valid subclasses.\n    \"\"\"\n    Model.__init__(self, seed=seed)\n    _Notice.__init__(self)\n    _States.__init__(self)\n    self._exp = experiment\n    self._run_id: Optional[int] = run_id\n    self.outpath = cast(Path, outpath)\n    dotlist = [f\"{k}={v}\" for k, v in kwargs.items()]\n    self._settings = OmegaConf.merge(parameters, OmegaConf.from_dotlist(dotlist))\n    self._setup_logger(parameters.get(\"log\", {}))\n    self.running: bool = True\n    self._version: str = __version__\n    self._check_subsystems(h_cls=human_class, n_cls=nature_class)\n    self._agents_handler = _ModelAgentsContainer(\n        model=self, max_len=kwargs.get(\"max_agents\", None)\n    )\n    self._time = TimeDriver(model=self)\n    self.datacollector: ABSESpyDataCollector = ABSESpyDataCollector(\n        parameters.get(\"reports\", {})\n    )\n    self._do_each(\"initialize\", order=(\"nature\", \"human\"))\n    self._do_each(\"set_state\", code=1)  # initial state\n</code></pre>"},{"location":"api/model/#abses.main.MainModel.exp","title":"exp  <code>property</code>","text":"<pre><code>exp\n</code></pre> <p>Returns the associated experiment.</p>"},{"location":"api/model/#abses.main.MainModel.outpath","title":"outpath  <code>property</code> <code>writable</code>","text":"<pre><code>outpath\n</code></pre> <p>Output path where to deposit assets.</p>"},{"location":"api/model/#abses.main.MainModel.run_id","title":"run_id  <code>property</code>","text":"<pre><code>run_id\n</code></pre> <p>The run id of the current model. It's useful in batch run. When running a single model, the run id is None.</p>"},{"location":"api/model/#abses.main.MainModel.name","title":"name  <code>property</code>","text":"<pre><code>name\n</code></pre> <p>name of the model. By default, it's the class name.</p>"},{"location":"api/model/#abses.main.MainModel.version","title":"version  <code>property</code>","text":"<pre><code>version\n</code></pre> <p>Report the current version of this model.</p>"},{"location":"api/model/#abses.main.MainModel.settings","title":"settings  <code>property</code>","text":"<pre><code>settings\n</code></pre> <p>Structured configuration for all model components.</p> <p>Allows nested parameter access. Example: If settings = {'nature': {'test': 3}}, Access via: - model.nature.params.test - model.nature.p.test</p> <p>Returns:</p> Type Description <code>DictConfig</code> <p>DictConfig containing all model settings.</p>"},{"location":"api/model/#abses.main.MainModel.agents","title":"agents  <code>property</code>","text":"<pre><code>agents\n</code></pre> <p>Container managing all agents in the model.</p> <p>Provides methods for: - Accessing agents: agents.select() - Creating agents: agents.new(Actor, num=3) - Registering agent types: agents.register(Actor) - Triggering events: agents.trigger()</p> <p>Returns:</p> Type Description <code>_ModelAgentsContainer</code> <p>The model's agent container instance.</p>"},{"location":"api/model/#abses.main.MainModel.actors","title":"actors  <code>property</code>","text":"<pre><code>actors\n</code></pre> <p>List of all agents currently on the earth.</p> <p>Returns:</p> Type Description <code>ActorsList[Actor]</code> <p>ActorsList containing all agents in PatchCells.</p>"},{"location":"api/model/#abses.main.MainModel.human","title":"human  <code>property</code>","text":"<pre><code>human\n</code></pre> <p>The Human subsystem.</p>"},{"location":"api/model/#abses.main.MainModel.nature","title":"nature  <code>property</code>","text":"<pre><code>nature\n</code></pre> <p>The Nature subsystem.</p>"},{"location":"api/model/#abses.main.MainModel.space","title":"space  <code>property</code>","text":"<pre><code>space\n</code></pre> <p>The space of the model.</p>"},{"location":"api/model/#abses.main.MainModel.time","title":"time  <code>property</code>","text":"<pre><code>time\n</code></pre> <p>The time driver &amp; controller</p>"},{"location":"api/model/#abses.main.MainModel.params","title":"params  <code>property</code>","text":"<pre><code>params\n</code></pre> <p>The global parameters of this model.</p>"},{"location":"api/model/#abses.main.MainModel.datasets","title":"datasets  <code>property</code>","text":"<pre><code>datasets\n</code></pre> <p>Available datasets for the model.</p> <p>Returns:</p> Type Description <code>DictConfig</code> <p>DictConfig containing dataset configurations.</p>"},{"location":"api/model/#abses.main.MainModel.plot","title":"plot  <code>cached</code> <code>property</code>","text":"<pre><code>plot\n</code></pre> <p>Visualization interface for the model.</p> <p>Returns:</p> Type Description <code>_VizModel</code> <p>_VizModel instance for creating model visualizations.</p>"},{"location":"api/model/#abses.main.MainModel.run_model","title":"run_model","text":"<pre><code>run_model(steps=None)\n</code></pre> <p>Executes the model simulation.</p> <p>Runs through the following phases: 1. Setup phase (model.setup()) 2. Step phase (model.step()) - repeated 3. End phase (model.end())</p> <p>Parameters:</p> Name Type Description Default <code>steps</code> <code>Optional[int]</code> <p>Number of steps to run. If None, runs until self.running is False.</p> <code>None</code> Source code in <code>abses/main.py</code> <pre><code>def run_model(self, steps: Optional[int] = None) -&gt; None:\n    \"\"\"Executes the model simulation.\n\n    Runs through the following phases:\n    1. Setup phase (model.setup())\n    2. Step phase (model.step()) - repeated\n    3. End phase (model.end())\n\n    Args:\n        steps: Number of steps to run. If None, runs until self.running is False.\n    \"\"\"\n    self._setup()\n    while self.running is True:\n        self.time.go()\n        self._step()\n        if self.time.tick == steps:\n            self.running = False\n    self._end()\n</code></pre>"},{"location":"api/model/#abses.main.MainModel.setup","title":"setup","text":"<pre><code>setup()\n</code></pre> <p>Users can custom what to do when the model is setup and going to start running.</p> Source code in <code>abses/main.py</code> <pre><code>def setup(self) -&gt; None:\n    \"\"\"Users can custom what to do when the model is setup and going to start running.\"\"\"\n</code></pre>"},{"location":"api/model/#abses.main.MainModel.step","title":"step","text":"<pre><code>step()\n</code></pre> <p>A step of the model.</p> Source code in <code>abses/main.py</code> <pre><code>def step(self) -&gt; None:\n    \"\"\"A step of the model.\"\"\"\n</code></pre>"},{"location":"api/model/#abses.main.MainModel.end","title":"end","text":"<pre><code>end()\n</code></pre> <p>Users can custom what to do when the model is end.</p> Source code in <code>abses/main.py</code> <pre><code>def end(self) -&gt; None:\n    \"\"\"Users can custom what to do when the model is end.\"\"\"\n</code></pre>"},{"location":"api/model/#abses.main.MainModel.summary","title":"summary","text":"<pre><code>summary(verbose=False)\n</code></pre> <p>Generates a summary report of the model's current state.</p> <p>Parameters:</p> Name Type Description Default <code>verbose</code> <code>bool</code> <p>If True, includes additional details about model and agent variables.</p> <code>False</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame containing model statistics and state information.</p> Source code in <code>abses/main.py</code> <pre><code>def summary(self, verbose: bool = False) -&gt; pd.DataFrame:\n    \"\"\"Generates a summary report of the model's current state.\n\n    Args:\n        verbose: If True, includes additional details about model and agent variables.\n\n    Returns:\n        DataFrame containing model statistics and state information.\n    \"\"\"\n    print(f\"Using ABSESpy version: {self.version}\")\n    # Basic reports\n    to_report = {\"name\": self.name, \"state\": self.state, \"tick\": self.time.tick}\n    for breed in self.agents_by_type:\n        to_report[breed] = self.agents.has(breed)\n    if verbose:\n        to_report[\"model_vars\"] = self.datacollector.model_reporters.keys()\n        to_report[\"agent_vars\"] = self.datacollector.agent_reporters.keys()\n    return pd.Series(to_report)\n</code></pre>"},{"location":"api/move/","title":"Agents' Movement","text":"<p>A class that handles actor movement in the simulation.</p> <p>This class provides methods for moving actors between cells in the simulation grid. It handles basic movement operations like moving to specific coordinates, moving in directions, and random movement.</p> <p>Attributes:</p> Name Type Description <code>actor</code> <p>The actor instance this movement handler belongs to.</p> <code>model</code> <p>The model instance this movement handler operates in.</p> <code>seed</code> <p>Unique identifier for the actor, used for random number generation.</p> Source code in <code>abses/move.py</code> <pre><code>def __init__(self, actor: Actor) -&gt; None:\n    self.actor = actor\n    self.model = actor.model\n    self.seed = actor.unique_id\n</code></pre>"},{"location":"api/move/#abses.move._Movements.layer","title":"layer  <code>property</code>","text":"<pre><code>layer\n</code></pre> <p>The current layer of the operating actor.</p>"},{"location":"api/move/#abses.move._Movements.to","title":"to","text":"<pre><code>to(to=None, layer=None, indices=False)\n</code></pre> <p>Move the actor to a specific location.</p> <p>Parameters:</p> Name Type Description Default <code>to</code> <code>PatchCell | Coordinate | Literal['random'] | None</code> <p>The position to move to. If position is a Coordinate -a tuple of (row, col), it will be moved to the same layer. If pos is None, the actor will be removed from the world.</p> <code>None</code> <code>indices</code> <code>bool</code> <p>The indices to move to.</p> <code>False</code> <code>layer</code> <code>Optional[PatchModule]</code> <p>The layer where the actor is located. If layer is None, the actor will be moved to the same layer as the actor's current layer.</p> <code>None</code> <code>indices</code> <code>bool</code> <p>Whether the position is indices. If indices is True, the position is indices. If indices is False, the position is position.</p> <code>False</code> <p>Raises:</p> Type Description <code>ABSESpyError</code> <p>If the input layer is not consistent with the actor's layer. If the position is out of bounds. Or, if the pos is coordinate without layer.</p> Source code in <code>abses/move.py</code> <pre><code>def to(\n    self,\n    to: PatchCell | Coordinate | Literal[\"random\"] | None = None,\n    layer: Optional[PatchModule] = None,\n    indices: bool = False,\n) -&gt; None:\n    \"\"\"\n    Move the actor to a specific location.\n\n    Parameters:\n        to:\n            The position to move to.\n            If position is a Coordinate -a tuple of (row, col),\n            it will be moved to the same layer.\n            If pos is None, the actor will be removed from the world.\n        indices:\n            The indices to move to.\n        layer:\n            The layer where the actor is located.\n            If layer is None, the actor will be moved to the same layer as the actor's current layer.\n        indices:\n            Whether the position is indices.\n            If indices is True, the position is indices.\n            If indices is False, the position is position.\n\n    Raises:\n        ABSESpyError:\n            If the input layer is not consistent with the actor's layer.\n            If the position is out of bounds.\n            Or, if the pos is coordinate without layer.\n    \"\"\"\n    if isinstance(to, PatchCell):\n        self._layer_is_consistent(to.layer)\n        _put_agent_on_cell(self.actor, to)\n        return\n    if layer is None and self.layer is None:\n        raise ABSESpyError(\"No operating layer is specified.\")\n    layer = self._operating_layer(layer=layer)\n    if to == \"random\":\n        cell = cast(PatchCell, layer.cells_lst.random.choice())\n        _put_agent_on_cell(self.actor, cell)\n        return\n    if isinstance(to, tuple) and len(to) == 2:\n        x, y = to\n        if indices:\n            cell = layer.array_cells[x, y]\n        else:\n            cell = layer.cells[x][y]\n        _put_agent_on_cell(self.actor, cell)\n        return\n    # \u68c0\u67e5\u8fd9\u4e2a\u4f4d\u7f6e\u7684\u7c7b\u578b\uff0c\u8fd4\u56de\u56fe\u5c42\u548c\u4f4d\u7f6e\n    raise TypeError(f\"Invalid position type {to}.\")\n</code></pre>"},{"location":"api/move/#abses.move._Movements.off","title":"off","text":"<pre><code>off()\n</code></pre> <p>Remove the actor from the world.</p> <p>Raises:</p> Type Description <code>ABSESpyError</code> <p>If the actor is not located on a cell, thus cannot move.</p> Source code in <code>abses/move.py</code> <pre><code>def off(self) -&gt; None:\n    \"\"\"Remove the actor from the world.\n\n    Raises:\n        ABSESpyError:\n            If the actor is not located on a cell, thus cannot move.\n    \"\"\"\n    if self.actor.at is None:\n        return\n    if hasattr(self.actor.at, \"agents\"):\n        self.actor.at.agents.remove(self.actor)\n    del self.actor.at\n</code></pre>"},{"location":"api/move/#abses.move._Movements.by","title":"by","text":"<pre><code>by(direction, distance=1)\n</code></pre> <p>Move the actor by a specific distance.</p> <p>Parameters:</p> Name Type Description Default <code>direction</code> <code>MovingDirection</code> <p>The direction to move. It should be a direction string such as: \"left\", \"right\", \"up\", \"down\", \"up left\", \"up right\", \"down left\", \"down right\".</p> required <code>distance</code> <code>int</code> <p>The distance to move toward the direction.</p> <code>1</code> <p>Raises:</p> Type Description <code>ABSESpyError</code> <p>If the actor is not located on a cell, thus cannot move.</p> <code>ValueError</code> <p>If the direction is invalid.</p> Source code in <code>abses/move.py</code> <pre><code>@alive_required\ndef by(self, direction: MovingDirection, distance: int = 1) -&gt; None:\n    \"\"\"Move the actor by a specific distance.\n\n    Parameters:\n        direction:\n            The direction to move.\n            It should be a direction string such as:\n            \"left\", \"right\", \"up\", \"down\", \"up left\", \"up right\", \"down left\", \"down right\".\n        distance:\n            The distance to move toward the direction.\n\n    Raises:\n        ABSESpyError:\n            If the actor is not located on a cell, thus cannot move.\n        ValueError:\n            If the direction is invalid.\n    \"\"\"\n    if (self.actor.at is None) or (self.layer is None):\n        raise ABSESpyError(\"The actor is not located on a cell, thus cannot move.\")\n    old_row, old_col = self.actor.at.indices\n    if direction == \"left\":\n        new_indices = (old_row, old_col - distance)\n    elif direction == \"right\":\n        new_indices = (old_row, old_col + distance)\n    elif direction == \"up\":\n        new_indices = (old_row - distance, old_col)\n    elif direction == \"down\":\n        new_indices = (old_row + distance, old_col)\n    elif direction in {\"up left\", \"left up\"}:\n        new_indices = (old_row - distance, old_col - distance)\n    elif direction in {\"up right\", \"right up\"}:\n        new_indices = (old_row - distance, old_col + distance)\n    elif direction in {\"down left\", \"left down\"}:\n        new_indices = (old_row + distance, old_col - distance)\n    elif direction in {\"down right\", \"right down\"}:\n        new_indices = (old_row + distance, old_col + distance)\n    else:\n        raise ValueError(f\"Invalid direction {direction}.\")\n    cell = self.layer.array_cells[new_indices[0], new_indices[1]]\n    self.actor.move.to(cell, indices=True)\n</code></pre>"},{"location":"api/move/#abses.move._Movements.random","title":"random","text":"<pre><code>random(prob=None, **kwargs)\n</code></pre> <p>Move the actor to a random location nearby.</p> <p>Parameters:</p> Name Type Description Default <code>prob</code> <code>Optional[str]</code> <p>The probability to select a cell.</p> <code>None</code> <code>kwargs</code> <code>Any</code> <p>Passing keyword args to <code>PatchCell.neighboring</code>, used to select neighboring cells.</p> <code>{}</code> Source code in <code>abses/move.py</code> <pre><code>@alive_required\ndef random(self, prob: Optional[str] = None, **kwargs: Any) -&gt; None:\n    \"\"\"Move the actor to a random location nearby.\n\n    Parameters:\n        prob:\n            The probability to select a cell.\n        kwargs:\n            Passing keyword args to `PatchCell.neighboring`,\n            used to select neighboring cells.\n    \"\"\"\n    if self.actor.at is None:\n        raise ABSESpyError(\"The actor is not located on a cell.\")\n    cells = self.actor.at.neighboring(**kwargs)\n    self.actor.move.to(cells.random.choice(prob=prob))\n</code></pre>"},{"location":"api/nature/","title":"nature","text":"<p>               Bases: <code>CompositeModule</code>, <code>GeoSpace</code></p> <p>Base class for managing spatial components in an ABSESpy model.</p> <p>This class serves as a container for different raster layers (PatchModules). It is not a raster layer itself, but manages multiple PatchModule instances.</p> <p>Attributes:</p> Name Type Description <code>major_layer</code> <code>Optional[PatchModule]</code> <p>Primary raster layer of the model. Defaults to first created layer.</p> <code>total_bounds</code> <code>Optional[PatchModule]</code> <p>Spatial extent of the model's area of interest.</p> <code>crs</code> <code>Optional[PatchModule]</code> <p>Coordinate Reference System used by the nature module.</p> <code>layers</code> <code>Optional[PatchModule]</code> <p>Collection of all managed raster layers.</p> <code>modules</code> <code>Optional[PatchModule]</code> <p>Factory for creating and managing PatchModules.</p> Note <p>By default, an initialized ABSESpy model will create an instance of BaseNature as its 'nature' module.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>MainModel[Any, Any]</code> <p>Parent model instance this nature module belongs to.</p> required <code>name</code> <code>str</code> <p>Name identifier for this module (defaults to \"nature\").</p> <code>'nature'</code> Source code in <code>abses/nature.py</code> <pre><code>def __init__(\n    self, model: MainModel[Any, Any], name: str = \"nature\"\n) -&gt; None:\n    \"\"\"Initializes a new BaseNature instance.\n\n    Args:\n        model: Parent model instance this nature module belongs to.\n        name: Name identifier for this module (defaults to \"nature\").\n    \"\"\"\n    CompositeModule.__init__(self, model, name=name)\n    GeoSpace.__init__(self, crs=CRS)\n    self._major_layer: Optional[PatchModule] = None\n    self._modules: _PatchModuleFactory = _PatchModuleFactory(self)\n</code></pre>"},{"location":"api/nature/#abses.nature.BaseNature.major_layer","title":"major_layer  <code>property</code> <code>writable</code>","text":"<pre><code>major_layer\n</code></pre> <p>Primary raster layer of the nature module.</p> <p>Returns:</p> Type Description <code>Optional[PatchModule]</code> <p>The current major layer, or None if not set.</p>"},{"location":"api/nature/#abses.nature.BaseNature.create_module","title":"create_module","text":"<pre><code>create_module(\n    module_cls=None,\n    how=None,\n    major_layer=False,\n    write_crs=True,\n    **kwargs\n)\n</code></pre> <p>Creates a new raster layer (PatchModule) in this nature module.</p> <p>Parameters:</p> Name Type Description Default <code>module_cls</code> <code>Optional[Type[PatchModule]]</code> <p>Custom PatchModule subclass to instantiate. If None, uses base PatchModule.</p> <code>None</code> <code>how</code> <code>Optional[HowCreation]</code> <p>Method to use for creating the layer. Options: - \"from_resolution\": Create by specifying shape and resolution - \"from_file\": Create from a geo-tiff dataset - \"copy_layer\": Copy properties from existing layer If None, creates basic module without special initialization.</p> <code>None</code> <code>major_layer</code> <code>bool</code> <p>If True, sets created module as the major layer.</p> <code>False</code> <code>write_crs</code> <code>bool</code> <p>If True, assigns nature's CRS to module if module's CRS is None.</p> <code>True</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed to the creation method.</p> <code>{}</code> <p>Returns:</p> Type Description <code>PatchModule</code> <p>Newly created PatchModule instance.</p> Note <p>The first created module automatically becomes the major layer. The module is automatically added to nature's layers collection.</p> Source code in <code>abses/nature.py</code> <pre><code>def create_module(\n    self,\n    module_cls: Optional[Type[PatchModule]] = None,\n    how: Optional[HowCreation] = None,\n    major_layer: bool = False,\n    write_crs: bool = True,\n    **kwargs: Any,\n) -&gt; PatchModule:\n    \"\"\"Creates a new raster layer (PatchModule) in this nature module.\n\n    Args:\n        module_cls: Custom PatchModule subclass to instantiate. If None, uses base PatchModule.\n        how: Method to use for creating the layer. Options:\n            - \"from_resolution\": Create by specifying shape and resolution\n            - \"from_file\": Create from a geo-tiff dataset\n            - \"copy_layer\": Copy properties from existing layer\n            If None, creates basic module without special initialization.\n        major_layer: If True, sets created module as the major layer.\n        write_crs: If True, assigns nature's CRS to module if module's CRS is None.\n        **kwargs: Additional arguments passed to the creation method.\n\n    Returns:\n        Newly created PatchModule instance.\n\n    Note:\n        The first created module automatically becomes the major layer.\n        The module is automatically added to nature's layers collection.\n    \"\"\"\n    if self.modules.is_empty:\n        major_layer = True\n    module = self.modules.new(how=how, module_class=module_cls, **kwargs)\n    # \u5982\u679c\u662f\u7b2c\u4e00\u4e2a\u521b\u5efa\u7684\u6a21\u5757,\u5219\u5c06\u5176\u4f5c\u4e3a\u4e3b\u8981\u7684\u56fe\u5c42\n    if major_layer:\n        self.major_layer = module\n    if write_crs and module.crs is None:\n        logger.warning(\n            f\"{module.name}'s default CRS is None.\"\n            f\"Setting it to nature's CRS {self.crs}.\",\n        )\n        module.crs = self.crs\n    setattr(self, module.name, module)\n    self.add_layer(module)\n    return module\n</code></pre>"},{"location":"api/random/","title":"Random Module","text":"<p>Create a random generator from an <code>ActorsList</code></p> Source code in <code>abses/random.py</code> <pre><code>def __init__(\n    self, model: MainModel[Any, Any], actors: Iterable[Any]\n) -&gt; None:\n    self.model = model\n    self.actors = self._to_actors_list(actors)\n    self.seed = model.random.random() * 100\n    self.generator = np.random.default_rng(seed=int(self.seed))\n</code></pre>"},{"location":"api/random/#abses.random.ListRandom.clean_p","title":"clean_p","text":"<pre><code>clean_p(prob)\n</code></pre> <p>Clean the probabilities. Any negative values, NaN values, or zeros will be recognized as in-valid probabilities. For all valid probabilities, normalize them into a prob-array (the sum is equal to 1.0).</p> <p>Parameters:</p> Name Type Description Default <code>prob</code> <code>Union[ndarray, str]</code> <p>An array-like numbers of probabilities.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>The probabilities after cleaned.</p> <p>Example: <pre><code>&gt;&gt;&gt; clean_p([0, 0])\n&gt;&gt;&gt; [0.5, 0.5]\n\n&gt;&gt;&gt; clean_p([-1, np.nan])\n&gt;&gt;&gt; [0.5, 0.5]\n\n&gt;&gt;&gt; clean_p([3, 2])\n&gt;&gt;&gt; [0.6, 0.4]\n</code></pre></p> Source code in <code>abses/random.py</code> <pre><code>def clean_p(self, prob: Union[np.ndarray, str]) -&gt; np.ndarray:\n    \"\"\"Clean the probabilities.\n    Any negative values, NaN values, or zeros will be recognized as in-valid probabilities.\n    For all valid probabilities, normalize them into a prob-array (the sum is equal to 1.0).\n\n    Parameters:\n        prob:\n            An array-like numbers of probabilities.\n\n    Returns:\n        The probabilities after cleaned.\n\n    Example:\n    ```\n    &gt;&gt;&gt; clean_p([0, 0])\n    &gt;&gt;&gt; [0.5, 0.5]\n\n    &gt;&gt;&gt; clean_p([-1, np.nan])\n    &gt;&gt;&gt; [0.5, 0.5]\n\n    &gt;&gt;&gt; clean_p([3, 2])\n    &gt;&gt;&gt; [0.6, 0.4]\n    ```\n    \"\"\"\n    if isinstance(prob, str):\n        prob = self.actors.array(attr=prob)\n    else:\n        prob = np.array(make_list(prob))\n    length = len(prob)\n    prob = np.nan_to_num(prob)\n    prob[prob &lt; 0] = 0.0\n    total = prob.sum()\n    prob = prob / total if total else np.repeat(1 / length, length)\n    return prob\n</code></pre>"},{"location":"api/random/#abses.random.ListRandom.choice","title":"choice","text":"<pre><code>choice(\n    size: int = 1,\n    prob: np.ndarray | None = None,\n    replace: bool = False,\n    as_list: bool = True,\n    when_empty: WHEN_EMPTY = \"raise exception\",\n) -&gt; ActorsList[LinkingNode]\n</code></pre><pre><code>choice(\n    size: int = 1,\n    prob: np.ndarray | None = None,\n    replace: bool = False,\n    as_list: bool = False,\n    when_empty: WHEN_EMPTY = \"raise exception\",\n) -&gt; LinkingNode | ActorsList[LinkingNode]\n</code></pre> <pre><code>choice(\n    size=1,\n    prob=None,\n    replace=False,\n    as_list=False,\n    when_empty=\"raise exception\",\n    double_check=False,\n)\n</code></pre> <p>Randomly choose one or more actors from the current self object.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>int</code> <p>The number of actors to choose. Defaults to 1.</p> <code>1</code> <code>prob</code> <code>ndarray | None | str</code> <p>A list of probabilities for each actor to be chosen. If None, all actors have equal probability. If is a string, will use the value of this attribute as the prob. Defaults to None.</p> <code>None</code> <code>replace</code> <code>bool</code> <p>Whether to sample with replacement. Defaults to True.</p> <code>False</code> <code>as_list</code> <code>bool</code> <p>Whether to return the result as a list of actors. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Optional[LinkingNode | ActorsList[LinkingNode]]</code> <p>An Actor or an ActorList of multiple actors.</p> Notes <p>Given the parameter set size=1 and as_list=False, a single Actor object is returned. Given the parameter set size&gt;1 and as_list=False, a Self (ActorsList) object is returned.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If size is not a positive integer.</p> <code>ABSESpyError</code> <p>Not enough actors to choose in this <code>ActorsList</code>.</p> Source code in <code>abses/random.py</code> <pre><code>def choice(\n    self,\n    size: int = 1,\n    prob: np.ndarray | None | str = None,\n    replace: bool = False,\n    as_list: bool = False,\n    when_empty: WHEN_EMPTY = \"raise exception\",\n    double_check: bool = False,\n) -&gt; Optional[LinkingNode | ActorsList[LinkingNode]]:\n    \"\"\"Randomly choose one or more actors from the current self object.\n\n    Parameters:\n        size:\n            The number of actors to choose. Defaults to 1.\n        prob:\n            A list of probabilities for each actor to be chosen.\n            If None, all actors have equal probability.\n            If is a string, will use the value of this attribute as the prob.\n            Defaults to None.\n        replace:\n            Whether to sample with replacement. Defaults to True.\n        as_list:\n            Whether to return the result as a list of actors. Defaults to False.\n\n    Returns:\n        An Actor or an ActorList of multiple actors.\n\n    Notes:\n        Given the parameter set size=1 and as_list=False, a single Actor object is returned.\n        Given the parameter set size&gt;1 and as_list=False, a Self (ActorsList) object is returned.\n\n    Raises:\n        ValueError:\n            If size is not a positive integer.\n        ABSESpyError:\n            Not enough actors to choose in this `ActorsList`.\n    \"\"\"\n    instances_num = len(self.actors)\n    if instances_num == 0:\n        self._when_empty(when_empty=when_empty)\n        return None\n    if not isinstance(size, int):\n        raise ValueError(f\"{size} isn't an integer size.\")\n    if instances_num &lt; size and not replace:\n        raise ABSESpyError(\n            f\"Trying to choose {size} actors from {self.actors}.\"\n        )\n    # \u6709\u6982\u7387\u7684\u65f6\u5019\uff0c\u5148\u6e05\u7406\u6982\u7387\n    if prob is not None:\n        prob = self.clean_p(prob=prob)\n        valid_prob = prob.astype(bool)\n        # \u7279\u522b\u5904\u7406\u6709\u6982\u7387\u7684\u4e3b\u4f53\u6570\u91cf\u4e0d\u8db3\u9884\u671f\u7684\u60c5\u51b5\n        if valid_prob.sum() &lt; size and not replace:\n            return self._when_p_not_enough(double_check, valid_prob, size)\n    # \u5176\u4ed6\u60c5\u51b5\u5c31\u6b63\u5e38\u968f\u673a\u9009\u62e9\n    chosen = self.generator.choice(\n        self.actors, size=size, replace=replace, p=prob\n    )\n    return (\n        chosen[0]\n        if size == 1 and not as_list\n        else self._to_actors_list(chosen)\n    )\n</code></pre>"},{"location":"api/random/#abses.random.ListRandom.new","title":"new","text":"<pre><code>new(actor_cls, actor_attrs=None, **kwargs)\n</code></pre> <p>Randomly creating new agents for a given actor type.</p> Source code in <code>abses/random.py</code> <pre><code>def new(\n    self,\n    actor_cls: Type[Actor],\n    actor_attrs: Optional[Dict[str, Any]] = None,\n    **kwargs,\n) -&gt; ActorsList[Actor]:\n    \"\"\"Randomly creating new agents for a given actor type.\"\"\"\n    if actor_attrs is None:\n        actor_attrs = {}\n    cells = self.choice(as_list=True, **kwargs)\n    objs = cells.apply(\n        lambda c: c.agents.new(\n            breed_cls=actor_cls, singleton=True, **actor_attrs\n        )\n    )\n    return self._to_actors_list(objs)\n</code></pre>"},{"location":"api/random/#abses.random.ListRandom.link","title":"link","text":"<pre><code>link(link, p=1.0, mutual=True)\n</code></pre> <p>Random build links between actors.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>Name of the link.</p> required <code>p</code> <code>float</code> <p>Probability to generate a link.</p> <code>1.0</code> <p>Returns:</p> Type Description <code>List[Tuple[Actor, Actor]]</code> <p>A list of tuple, in each tuple, there are two actors who got linked.</p> Example <pre><code># generate three actors\nactors = model.agents.new(Actor, 3)\n# with `probability=1`, all possible actor-actor links would be generated.\n&gt;&gt;&gt; actors.random.link('test', p=1)\n&gt;&gt;&gt; a1, a2, a3 = actors\n&gt;&gt;&gt; assert a1.link.get('test) == [a2, a3]\n&gt;&gt;&gt; assert a2.link.get('test) == [a1, a3]\n&gt;&gt;&gt; assert a3.link.get('test) == [a1, a2]\n</code></pre> Source code in <code>abses/random.py</code> <pre><code>def link(\n    self, link: str, p: float = 1.0, mutual: bool = True\n) -&gt; List[Tuple[Actor, Actor]]:\n    \"\"\"Random build links between actors.\n\n    Parameters:\n        link:\n            Name of the link.\n        p:\n            Probability to generate a link.\n\n    Returns:\n        A list of tuple, in each tuple, there are two actors who got linked.\n\n    Example:\n        ```\n        # generate three actors\n        actors = model.agents.new(Actor, 3)\n        # with `probability=1`, all possible actor-actor links would be generated.\n        &gt;&gt;&gt; actors.random.link('test', p=1)\n        &gt;&gt;&gt; a1, a2, a3 = actors\n        &gt;&gt;&gt; assert a1.link.get('test) == [a2, a3]\n        &gt;&gt;&gt; assert a2.link.get('test) == [a1, a3]\n        &gt;&gt;&gt; assert a3.link.get('test) == [a1, a2]\n        ```\n    \"\"\"\n    linked_combs = []\n    for source, target in list(combinations(self.actors, 2)):\n        if np.random.random() &lt; p:\n            source.link.to(target, link_name=link, mutual=mutual)\n            linked_combs.append((source, target))\n    return linked_combs\n</code></pre>"},{"location":"api/random/#abses.random.ListRandom.assign","title":"assign","text":"<pre><code>assign(value, attr, when_empty='raise exception')\n</code></pre> <p>Randomly assign a value to each actor.</p> Source code in <code>abses/random.py</code> <pre><code>def assign(\n    self,\n    value: float | int,\n    attr: str,\n    when_empty: WHEN_EMPTY = \"raise exception\",\n) -&gt; np.ndarray:\n    \"\"\"Randomly assign a value to each actor.\"\"\"\n    num = len(self.actors)\n    if num == 0:\n        self._when_empty(when_empty=when_empty, operation=\"assign\")\n        return np.array([])\n    if num == 1:\n        values = np.array([value])\n    else:\n        # \u751f\u6210 n-1 \u4e2a\u968f\u673a\u5207\u5272\u70b9\n        cuts = np.sort(self.generator.uniform(0, value, num - 1))\n        # \u5c06 0 \u548c\u603b\u9762\u79ef X \u6dfb\u52a0\u5230\u5207\u5272\u70b9\u6570\u7ec4\u4e2d\uff0c\u65b9\u4fbf\u8ba1\u7b97\u6bcf\u6bb5\u533a\u95f4\u957f\u5ea6\n        full_range = np.append(np.append(0, cuts), value)\n        # \u8ba1\u7b97\u6bcf\u4e2a\u533a\u95f4\u7684\u957f\u5ea6\uff0c\u5373\u4e3a\u6bcf\u4e2a\u5bf9\u8c61\u7684\u5206\u914d\u9762\u79ef\n        values = np.diff(full_range)\n    # \u5c06\u5206\u914d\u7684\u503c\u8d4b\u4e88\u6bcf\u4e2a\u5bf9\u8c61\n    self.actors.update(attr, values)\n    return values\n</code></pre>"},{"location":"api/sequences/","title":"Actors Operation","text":"<p>               Bases: <code>List[Link]</code>, <code>Generic[Link]</code></p> <p>A list of actors in an agent-based model.</p> Source code in <code>abses/sequences.py</code> <pre><code>def __init__(\n    self, model: MainModel[Any, Any], objs: Iterable[Link] = ()\n) -&gt; None:\n    super().__init__(objs)\n    self._model = model\n</code></pre>"},{"location":"api/sequences/#abses.sequences.ActorsList.random","title":"random  <code>cached</code> <code>property</code>","text":"<pre><code>random\n</code></pre> <p>Random module</p>"},{"location":"api/sequences/#abses.sequences.ActorsList.plot","title":"plot  <code>cached</code> <code>property</code>","text":"<pre><code>plot\n</code></pre> <p>Plotting module</p>"},{"location":"api/sequences/#abses.sequences.ActorsList.to_dict","title":"to_dict","text":"<pre><code>to_dict()\n</code></pre> <p>Convert all actors in this list to a dictionary like {breed: ActorList}.</p> <p>Returns:</p> Type Description <code>Dict[str, ActorsList[Link]]</code> <p>key is the breed of actors, and values are corresponding actors.</p> Source code in <code>abses/sequences.py</code> <pre><code>def to_dict(self) -&gt; Dict[str, ActorsList[Link]]:\n    \"\"\"Convert all actors in this list to a dictionary like {breed: ActorList}.\n\n    Returns:\n        key is the breed of actors, and values are corresponding actors.\n    \"\"\"\n    dic: Dict[str, ActorsList[Link]] = {}\n    for actor in iter(self):\n        breed = actor.breed\n        if breed not in dic:\n            dic[breed] = ActorsList(self._model, [actor])\n        else:\n            dic[breed].append(actor)\n    return dic\n</code></pre>"},{"location":"api/sequences/#abses.sequences.ActorsList.select","title":"select","text":"<pre><code>select(selection=None, geo_type=None)\n</code></pre> <p>Returns a new :class:<code>ActorList</code> based on <code>selection</code>.</p> <p>Parameters:</p> Name Type Description Default <code>selection</code> <code>Optional[Selection]</code> <p>List with same length as the agent list. Positions that return True will be selected.</p> <code>None</code> <code>geo_type</code> <code>Optional[GeoType]</code> <p>Type of Actors' Geometry.</p> <code>None</code> <p>Returns:</p> Type Description <code>ActorsList[Link]</code> <p>A subset containing.</p> Source code in <code>abses/sequences.py</code> <pre><code>def select(\n    self,\n    selection: Optional[Selection] = None,\n    geo_type: Optional[GeoType] = None,\n) -&gt; ActorsList[Link]:\n    \"\"\"\n    Returns a new :class:`ActorList` based on `selection`.\n\n    Parameters:\n        selection:\n            List with same length as the agent list.\n            Positions that return True will be selected.\n        geo_type:\n            Type of Actors' Geometry.\n\n    Returns:\n        A subset containing.\n    \"\"\"\n    actors = self._subset(geo_type=geo_type)\n    if selection is None:\n        return actors\n    if isinstance(selection, (str, dict)):\n        bool_ = [selecting(actor, selection) for actor in actors]\n    elif isinstance(selection, (list, tuple, np.ndarray)):\n        bool_ = make_list(selection)\n    else:\n        raise TypeError(f\"Invalid selection type {type(selection)}\")\n    selected = [a for a, s in zip(actors, bool_) if s]\n    return ActorsList(self._model, selected)\n</code></pre>"},{"location":"api/sequences/#abses.sequences.ActorsList.better","title":"better","text":"<pre><code>better(metric, than=None)\n</code></pre> <p>Selects the elements of the sequence that are better than a given value or actor based on a specified metric.</p> <p>Parameters:</p> Name Type Description Default <code>metric</code> <code>str</code> <p>The name of the attribute to use as the metric for comparison.</p> required <code>than</code> <code>Optional[Union[Number, Actor]]</code> <p>The value or actor to compare against. If None, selects the elements with the highest value for the specified metric. If a number, selects the elements with a value greater than the specified number. If an Actor, selects the elements with a value greater than the specified Actor's value for the specified metric.</p> <code>None</code> <p>Returns:</p> Type Description <code>ActorsList[Link]</code> <p>A new sequence containing the selected elements.</p> <p>Raises:</p> Type Description <code>ABSESpyError</code> <p>If the <code>than</code> parameter is not a Number or an Actor.</p> Notes <p>This method compares the values of the specified metric for all elements in the sequence and selects the elements that are better than the specified value or actor. The comparison is based on the greater than operator (&gt;) for numbers and the difference between the values for actors.</p> Source code in <code>abses/sequences.py</code> <pre><code>def better(\n    self, metric: str, than: Optional[Union[Number, Actor]] = None\n) -&gt; ActorsList[Link]:\n    \"\"\"\n    Selects the elements of the sequence that are better than a given value or actor\n    based on a specified metric.\n\n    Parameters:\n        metric:\n            The name of the attribute to use as the metric for comparison.\n        than:\n            The value or actor to compare against. If None, selects the elements with the\n            highest value for the specified metric. If a number, selects the elements with\n            a value greater than the specified number. If an Actor, selects the elements\n            with a value greater than the specified Actor's value for the specified metric.\n\n    Returns:\n        A new sequence containing the selected elements.\n\n    Raises:\n        ABSESpyError:\n            If the `than` parameter is not a Number or an Actor.\n\n    Notes:\n        This method compares the values of the specified metric for all elements in the\n        sequence and selects the elements that are better than the specified value or actor.\n        The comparison is based on the greater than operator (&gt;) for numbers and the\n        difference between the values for actors.\n    \"\"\"\n    metrics = self.array(attr=metric)\n    if than is None:\n        return self.select(metrics == max(metrics))\n    if isinstance(than, Number):\n        return self.select(metrics &gt; than)\n    if isinstance(than, mg.GeoAgent):\n        diff = self.array(metric) - getattr(than, metric)\n        return self.select(diff &gt; 0)\n    raise ABSESpyError(f\"Invalid than type {type(than)}.\")\n</code></pre>"},{"location":"api/sequences/#abses.sequences.ActorsList.update","title":"update","text":"<pre><code>update(attr, values)\n</code></pre> <p>Update the specified attribute of each agent in the sequence with the corresponding value in the given iterable.</p> <p>Parameters:</p> Name Type Description Default <code>attr</code> <code>str</code> <p>The name of the attribute to update.</p> required <code>values</code> <code>Iterable[Any]</code> <p>An iterable of values to update the attribute with. Must be the same length as the sequence.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the length of the values iterable does not match the length of the sequence.</p> Source code in <code>abses/sequences.py</code> <pre><code>def update(self, attr: str, values: Iterable[Any]) -&gt; None:\n    \"\"\"Update the specified attribute of each agent in the sequence with the corresponding value in the given iterable.\n\n    Parameters:\n        attr:\n            The name of the attribute to update.\n        values:\n            An iterable of values to update the attribute with. Must be the same length as the sequence.\n\n    Raises:\n        ValueError:\n            If the length of the values iterable does not match the length of the sequence.\n    \"\"\"\n    self._is_same_length(cast(Sized, values), rep_error=True)\n    for agent, val in zip(self, values):\n        setattr(agent, attr, val)\n</code></pre>"},{"location":"api/sequences/#abses.sequences.ActorsList.split","title":"split","text":"<pre><code>split(where)\n</code></pre> <p>Split agents into N+1 groups.</p> <p>Parameters:</p> Name Type Description Default <code>where</code> <code>NDArray[Any]</code> <p>indexes [size=N] denotes where to split.</p> required <p>Returns:</p> Type Description <code>List[ActorsList[Link]]</code> <p>np.ndarray: N+1 groups: agents array</p> Source code in <code>abses/sequences.py</code> <pre><code>def split(self, where: NDArray[Any]) -&gt; List[ActorsList[Link]]:\n    \"\"\"Split agents into N+1 groups.\n\n    Parameters:\n        where:\n            indexes [size=N] denotes where to split.\n\n    Returns:\n        np.ndarray: N+1 groups: agents array\n    \"\"\"\n    split = np.hsplit(np.array(self), where)\n    return [ActorsList(self._model, group) for group in split]\n</code></pre>"},{"location":"api/sequences/#abses.sequences.ActorsList.array","title":"array","text":"<pre><code>array(attr)\n</code></pre> <p>Convert the specified attribute of all actors to a numpy array.</p> <p>Parameters:</p> Name Type Description Default <code>attr</code> <code>str</code> <p>The name of the attribute to convert to a numpy array.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>A numpy array containing the specified attribute of all actors.</p> Source code in <code>abses/sequences.py</code> <pre><code>def array(self, attr: str) -&gt; np.ndarray:\n    \"\"\"Convert the specified attribute of all actors to a numpy array.\n\n    Parameters:\n        attr:\n            The name of the attribute to convert to a numpy array.\n\n    Returns:\n        A numpy array containing the specified attribute of all actors.\n    \"\"\"\n    return np.array([getattr(actor, attr) for actor in self])\n</code></pre>"},{"location":"api/sequences/#abses.sequences.ActorsList.trigger","title":"trigger","text":"<pre><code>trigger(func_name, *args, **kwargs)\n</code></pre> <p>Call a method with the given name on all actors in the sequence.</p> <p>Parameters:</p> Name Type Description Default <code>func_name</code> <code>str</code> <p>The name of the method to call on each actor.</p> required <code>*args</code> <code>Any</code> <p>Positional arguments to pass to the method.</p> <code>()</code> <code>**kwargs</code> <code>Any</code> <p>Keyword arguments to pass to the method.</p> <code>{}</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>An array of the results of calling the method on each actor.</p> Source code in <code>abses/sequences.py</code> <pre><code>def trigger(self, func_name: str, *args: Any, **kwargs: Any) -&gt; np.ndarray:\n    \"\"\"Call a method with the given name on all actors in the sequence.\n\n    Parameters:\n        func_name:\n            The name of the method to call on each actor.\n        *args:\n            Positional arguments to pass to the method.\n        **kwargs:\n            Keyword arguments to pass to the method.\n\n    Returns:\n        An array of the results of calling the method on each actor.\n    \"\"\"\n    results = [\n        getattr(actor, func_name)(*args, **kwargs) for actor in iter(self)\n    ]\n    return np.array(results)\n</code></pre>"},{"location":"api/sequences/#abses.sequences.ActorsList.apply","title":"apply","text":"<pre><code>apply(ufunc, *args, **kwargs)\n</code></pre> <p>Apply ufunc to all actors in the sequence.</p> <p>Parameters:</p> Name Type Description Default <code>ufunc</code> <code>Callable</code> <p>The function to apply to each actor.</p> required <code>*args</code> <code>Any</code> <p>Positional arguments to pass to the function.</p> <code>()</code> <code>**kwargs</code> <code>Any</code> <p>Keyword arguments to pass to the function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>An array of the results of applying the function to each actor.</p> Source code in <code>abses/sequences.py</code> <pre><code>def apply(self, ufunc: Callable, *args: Any, **kwargs: Any) -&gt; np.ndarray:\n    \"\"\"Apply ufunc to all actors in the sequence.\n\n    Parameters:\n        ufunc:\n            The function to apply to each actor.\n        *args:\n            Positional arguments to pass to the function.\n        **kwargs:\n            Keyword arguments to pass to the function.\n\n    Returns:\n        An array of the results of applying the function to each actor.\n    \"\"\"\n    func = partial(ufunc, *args, **kwargs)\n    return np.array(list(map(func, self)))\n</code></pre>"},{"location":"api/sequences/#abses.sequences.ActorsList.get","title":"get","text":"<pre><code>get(attr, target=None, how='only', default=None)\n</code></pre> <p>Retrieve the attribute of an either specified or randomly chosen agent.</p> <p>Parameters:</p> Name Type Description Default <code>attr</code> <code>str</code> <p>The name of the attribute to retrieve.</p> required <code>how</code> <code>HOW</code> <p>The method to use to retrieve the attribute. Can be either \"only\" or \"random\".</p> <code>'only'</code> <p>Returns:</p> Type Description <code>Any</code> <p>The attribute of the specified agent.</p> Source code in <code>abses/sequences.py</code> <pre><code>def get(\n    self,\n    attr: str,\n    target: Optional[TargetName] = None,\n    how: HOW = \"only\",\n    default: Optional[Any] = None,\n) -&gt; Any:\n    \"\"\"Retrieve the attribute of an either specified or randomly chosen agent.\n\n    Parameters:\n        attr:\n            The name of the attribute to retrieve.\n        how:\n            The method to use to retrieve the attribute. Can be either \"only\" or \"random\".\n\n    Returns:\n        The attribute of the specified agent.\n    \"\"\"\n    if agent := self.item(how=how, index=0):\n        return agent.get(attr, target=target)\n    if default is not None:\n        return default\n    raise ValueError(\"No agent found or default value.\")\n</code></pre>"},{"location":"api/sequences/#abses.sequences.ActorsList.set","title":"set","text":"<pre><code>set(attr, value, target=None, new=False)\n</code></pre> <p>Set the attribute of all agents in the sequence to the specified value.</p> <p>Parameters:</p> Name Type Description Default <code>attr</code> <code>str</code> <p>The name of the attribute to set.</p> required <code>value</code> <code>Any</code> <p>The value to set the attribute to.</p> required Source code in <code>abses/sequences.py</code> <pre><code>def set(\n    self,\n    attr: str,\n    value: Any,\n    target: Optional[TargetName] = None,\n    new: bool = False,\n) -&gt; None:\n    \"\"\"Set the attribute of all agents in the sequence to the specified value.\n\n    Parameters:\n        attr:\n            The name of the attribute to set.\n        value:\n            The value to set the attribute to.\n    \"\"\"\n    for agent in iter(self):\n        agent.set(attr, value, target=target, new=new)\n</code></pre>"},{"location":"api/sequences/#abses.sequences.ActorsList.item","title":"item","text":"<pre><code>item(how='item', index=0)\n</code></pre> <p>Retrieve one agent if possible.</p> <p>Parameters:</p> Name Type Description Default <code>how</code> <code>HOW</code> <p>The method to use to retrieve the agent. Can be either \"only\", \"item\", or \"random\". If \"only\", it will return the only agent in the container. In this case, the container must have only one agent. If more than one or no agent is found, it will raise an error. If \"item\", it will return the agent at the given index. If \"random\", it will return a randomly chosen agent.</p> <code>'item'</code> <code>index</code> <code>int</code> <p>The index of the agent to retrieve.</p> <code>0</code> <p>Returns:</p> Type Description <code>Optional[Link]</code> <p>The agent if found, otherwise None.</p> Source code in <code>abses/sequences.py</code> <pre><code>def item(self, how: HOW = \"item\", index: int = 0) -&gt; Optional[Link]:\n    \"\"\"Retrieve one agent if possible.\n\n    Parameters:\n        how:\n            The method to use to retrieve the agent.\n            Can be either \"only\", \"item\", or \"random\".\n            If \"only\", it will return the only agent in the container.\n            In this case, the container must have only one agent.\n            If more than one or no agent is found, it will raise an error.\n            If \"item\", it will return the agent at the given index.\n            If \"random\", it will return a randomly chosen agent.\n        index:\n            The index of the agent to retrieve.\n\n    Returns:\n        The agent if found, otherwise None.\n    \"\"\"\n    if how == \"only\":\n        return get_only_agent(self)\n    if how == \"random\":\n        actor = self.random.choice(when_empty=\"return None\")\n        return cast(Optional[\"Actor\"], actor)\n    if how == \"item\":\n        return self[index] if len(self) &gt; index else None\n    raise ValueError(f\"Invalid how method '{how}'.\")\n</code></pre>"},{"location":"api/sequences/#abses.sequences.ActorsList.summary","title":"summary","text":"<pre><code>summary(\n    geometry: bool = True, **kwargs\n) -&gt; gpd.GeoDataFrame\n</code></pre><pre><code>summary(geometry: bool = False, **kwargs) -&gt; pd.DataFrame\n</code></pre> <pre><code>summary(geometry=False, **kwargs)\n</code></pre> <p>Returns a summarized dataframe of the actors.</p> Source code in <code>abses/sequences.py</code> <pre><code>def summary(\n    self, geometry: bool = False, **kwargs\n) -&gt; pd.DataFrame | gpd.GeoDataFrame:\n    \"\"\"Returns a summarized dataframe of the actors.\"\"\"\n    if len(self) == 0:\n        raise ValueError(\"No actors to retrieve summary information.\")\n    df = pd.concat([actor.summary(**kwargs) for actor in self], axis=1).T\n    if geometry:\n        crs = self._check_crs_consistent()\n        df[\"geometry\"] = self.array(\"geometry\")\n        return gpd.GeoDataFrame(df, geometry=\"geometry\", crs=crs)\n    return df\n</code></pre>"},{"location":"api/time/","title":"Time Operation","text":"<p>A decorator to run a method based on a time condition.</p> <p>Parameters:</p> Name Type Description Default <code>condition</code> <code>dict</code> <p>A dictionary containing conditions to check against the <code>time</code> attribute. The keys can be ['year', 'month', 'weekday', 'freqstr'].</p> required <code>when_run</code> <code>bool</code> <p>If True, the decorated method will run when the condition is met. If False, the decorated method will not run when the condition is met.</p> <code>True</code> Example <p><pre><code>class TestActor(Actor):\n    @time_condition(condition={\"month\": 1, \"day\": 1}, when_run=True)\n    def happy_new_year(self):\n        print(\"Today is 1th, January, Happy new year!\")\n\n\nparameters = {\"time\": {\"start\": \"1996-12-24\", \"days\": 1}}\n\n\nmodel = MainModel(parameters=parameters)\nagent = model.agents.new(TestActor, 1, singleton=True)\n\nfor _ in range(10):\n    print(f\"Time now is {model.time}\")\n    model.time.go()\n    agent.happy_new_year()\n</code></pre> It should be called again in the next year beginning (i.e., <code>1998-01-01</code>) if we run this model longer... It means, the function will be called when the condition is fully satisfied.</p> Source code in <code>abses/time.py</code> <pre><code>def time_condition(condition: dict, when_run: bool = True) -&gt; Callable:\n    \"\"\"\n    A decorator to run a method based on a time condition.\n\n    Parameters:\n        condition:\n            A dictionary containing conditions to check against the `time` attribute.\n            The keys can be ['year', 'month', 'weekday', 'freqstr'].\n        when_run:\n            If True, the decorated method will run when the condition is met.\n            If False, the decorated method will not run when the condition is met.\n\n    Example:\n        ```\n        class TestActor(Actor):\n            @time_condition(condition={\"month\": 1, \"day\": 1}, when_run=True)\n            def happy_new_year(self):\n                print(\"Today is 1th, January, Happy new year!\")\n\n\n        parameters = {\"time\": {\"start\": \"1996-12-24\", \"days\": 1}}\n\n\n        model = MainModel(parameters=parameters)\n        agent = model.agents.new(TestActor, 1, singleton=True)\n\n        for _ in range(10):\n            print(f\"Time now is {model.time}\")\n            model.time.go()\n            agent.happy_new_year()\n        ```\n        It should be called again in the next year beginning (i.e., `1998-01-01`) if we run this model longer... It means, the function will be called when the condition is fully satisfied.\n    \"\"\"\n\n    def decorator(func):\n        @wraps(func)\n        def wrapper(self, *args, **kwargs):\n            if not hasattr(self, \"time\"):\n                raise AttributeError(\n                    \"The object doesn't have a TimeDriver object as `time` attribute.\"\n                )\n            time = self.time\n            if not isinstance(time, TimeDriver):\n                raise TypeError(\"The `TimeDriver` must be existing.\")\n\n            satisfied = all(\n                getattr(time.dt, key, None) == value for key, value in condition.items()\n            )\n\n            if (satisfied and when_run) or (not satisfied and not when_run):\n                return func(self, *args, **kwargs)\n\n        return wrapper\n\n    return decorator\n</code></pre> <p>               Bases: <code>_Component</code></p> <p>TimeDriver provides the functionality to manage time.</p> <p>A wrapper around datetime that adds simulation-specific functionality while providing access to all datetime attributes and methods.</p> Source code in <code>abses/time.py</code> <pre><code>def __init__(self, model: MainModel):\n    super().__init__(model=model, name=\"time\")\n    self._model = model\n    self._tick = 0\n    self._dt = datetime.now()\n    self._start_dt = self._dt\n    self._end_dt: Optional[Union[datetime, int]] = None\n    self._history: deque[DateTime] = deque()\n    self._irregular = False\n    self._duration: Duration | None = None\n    self._parse_time_settings()\n    self._history.append(self._dt)\n    self._logging_setup()\n</code></pre>"},{"location":"api/time/#abses.time.TimeDriver.fmt","title":"fmt  <code>property</code>","text":"<pre><code>fmt\n</code></pre> <p>String format of datetime.</p>"},{"location":"api/time/#abses.time.TimeDriver.expected_ticks","title":"expected_ticks  <code>property</code>","text":"<pre><code>expected_ticks\n</code></pre> <p>Returns the expected ticks.</p>"},{"location":"api/time/#abses.time.TimeDriver.should_end","title":"should_end  <code>property</code>","text":"<pre><code>should_end\n</code></pre> <p>Should the model end or not.</p>"},{"location":"api/time/#abses.time.TimeDriver.tick","title":"tick  <code>property</code>","text":"<pre><code>tick\n</code></pre> <p>Returns the current tick.</p>"},{"location":"api/time/#abses.time.TimeDriver.ticking_mode","title":"ticking_mode  <code>property</code>","text":"<pre><code>ticking_mode\n</code></pre> <p>Current time advancement mode</p>"},{"location":"api/time/#abses.time.TimeDriver.history","title":"history  <code>property</code>","text":"<pre><code>history\n</code></pre> <p>Returns the history of the time driver.</p>"},{"location":"api/time/#abses.time.TimeDriver.irregular","title":"irregular  <code>property</code> <code>writable</code>","text":"<pre><code>irregular\n</code></pre> <p>Returns the irregular mode of the time driver.</p>"},{"location":"api/time/#abses.time.TimeDriver.duration","title":"duration  <code>property</code>","text":"<pre><code>duration\n</code></pre> <p>Returns the duration of the time driver.</p>"},{"location":"api/time/#abses.time.TimeDriver.start_dt","title":"start_dt  <code>property</code> <code>writable</code>","text":"<pre><code>start_dt\n</code></pre> <p>Returns the starting time for the model.</p>"},{"location":"api/time/#abses.time.TimeDriver.end_dt","title":"end_dt  <code>property</code> <code>writable</code>","text":"<pre><code>end_dt\n</code></pre> <p>The real-world time or the ticks when the model should be end.</p> <p>If the end time is a datetime object, it will be converted to a DateTime object. If the end time is an integer, it will be interpreted as a number of ticks.</p>"},{"location":"api/time/#abses.time.TimeDriver.dt","title":"dt  <code>property</code> <code>writable</code>","text":"<pre><code>dt\n</code></pre> <p>Current simulation time</p>"},{"location":"api/time/#abses.time.TimeDriver.to","title":"to","text":"<pre><code>to(time)\n</code></pre> <p>Specific the current time.</p> Source code in <code>abses/time.py</code> <pre><code>def to(self, time: str | datetime) -&gt; None:\n    \"\"\"Specific the current time.\"\"\"\n    if isinstance(time, str):\n        time = datetime.strptime(time, \"%Y\")\n    self.dt = time\n    self._history.clear()\n    self._history.append(self.dt)\n</code></pre>"},{"location":"api/time/#abses.time.TimeDriver.go","title":"go","text":"<pre><code>go(ticks=1, **kwargs)\n</code></pre> <p>Advance simulation time</p> Source code in <code>abses/time.py</code> <pre><code>def go(self, ticks: int = 1, **kwargs) -&gt; None:\n    \"\"\"Advance simulation time\"\"\"\n    if ticks &lt; 0:\n        raise ValueError(\"Ticks cannot be negative\")\n\n    for _ in range(ticks):\n        self._tick += 1\n\n        if self.ticking_mode == \"duration\" and self._duration:\n            self.dt += self._duration\n            self._history.append(self.dt)\n        elif self.ticking_mode == \"irregular\":\n            delta = pendulum.duration(**kwargs)\n            self.dt += delta\n            self._history.append(self.dt)\n        if self.should_end:\n            self._model.running = False\n            break\n</code></pre>"},{"location":"api/time/#abses.time.TimeDriver.parse_duration","title":"parse_duration","text":"<pre><code>parse_duration(duration)\n</code></pre> <p>Set the duration using pendulum.Duration.</p> <p>Parameters:</p> Name Type Description Default <code>duration</code> <code>DictConfig</code> <p>Duration configuration containing time units</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If any time unit is negative</p> <code>KeyError</code> <p>If any time unit is invalid</p> Source code in <code>abses/time.py</code> <pre><code>def parse_duration(self, duration: DictConfig) -&gt; None:\n    \"\"\"Set the duration using pendulum.Duration.\n\n    Args:\n        duration: Duration configuration containing time units\n\n    Raises:\n        ValueError: If any time unit is negative\n        KeyError: If any time unit is invalid\n    \"\"\"\n    # \u68c0\u67e5\u65f6\u95f4\u5355\u4f4d\u662f\u5426\u4e3a\u8d1f\u6570\n    for unit, value in duration.items():\n        if not isinstance(value, int):\n            continue\n        if value &lt; 0:\n            raise ValueError(f\"Time unit {unit} cannot be negative\")\n\n    # \u6784\u5efa\u6709\u6548\u7684\u65f6\u95f4\u6b65\u957f\n    valid_dict = {\n        attr: duration.get(attr, 0)\n        for attr in VALID_DT_ATTRS\n        if isinstance(duration.get(attr, 0), int)\n    }\n\n    if all(value == 0 for value in valid_dict.values()):\n        self._duration = None\n    else:\n        self._duration = pendulum.duration(**valid_dict)\n</code></pre>"},{"location":"examples/community/","title":"Community Examples","text":""},{"location":"examples/community/#model-from-community","title":"Model from community","text":"<p>In Progress</p> <p>As a new package, we don't have any model submission so far. You're warm welcome to submit your ABM project.</p> <p>Warning</p> <p>The community model is a result of contributions from <code>ABSESpy</code> users, and we do not guarantee the safety of its operation.</p>"},{"location":"examples/gallery/","title":"Gallery","text":""},{"location":"examples/gallery/#gallery","title":"Gallery","text":"<p>This showcases the use of <code>ABSESpy</code> for ABM. We divide the models into two types: heuristic models and real-world models.</p> <ul> <li> <p> South China Livelihood</p> <p>Here, we developed the model to explore the evolution of livelihood in the South of China.</p> <p> Checkout</p> </li> </ul>"},{"location":"examples/official/","title":"Official Examples","text":""},{"location":"examples/official/#official-examples","title":"Official Examples","text":"<p>This showcases the use of <code>ABSESpy</code> for ABM. We divide the models into two types: heuristic models<sup>1</sup> and real-world models. The major difference is that real-world models have datasets as input, so usually simulations of the real SESs.</p>"},{"location":"examples/official/#heuristic-models","title":"Heuristic models<sup>1</sup>","text":"<ul> <li> <p> Hotelling</p> <p>An adaptation of the Hotelling's Law model.</p> </li> <li> <p> Forest Fire</p> <p>An implementation of the <code>Fire</code> model.</p> </li> <li> <p> Predator-Prey</p> <p>An implementation of the Wolf-sheep ecosystem model.</p> </li> </ul>"},{"location":"examples/official/#real-world-models","title":"Real-world models","text":"<ul> <li> <p> South China Livelihood</p> <p>Here, we developed the model to explore the evolution of livelihood in the South of China.</p> </li> <li> <p> Yellow River Water Quota</p> <p>This agent-based model shows how water uses were change by water quota policy in the Yellow River Basin, China.</p> </li> </ul> <ol> <li> <p>Heuristic models are streamlined strategies used to tackle complex issues when precise formulas or solutions aren't feasible. These models rely on heuristic methods, practical tactics that may not always yield the best solution but offer a satisfactory one within an acceptable time limit.\u00a0\u21a9\u21a9</p> </li> </ol>"},{"location":"examples/official/south_china_livelihood/","title":"South China Livelihood Evolution","text":"<p>Warning</p> <p>This is a finished model with a in-production paper. Once the paper is accepted, source codes would be fully released. Please contact the author for any related inquiries.</p>"},{"location":"examples/official/south_china_livelihood/#overview","title":"Overview","text":"<p>This project's source code is available at this GitHub repo.</p> <p>This project constructs an agent-based model that simulates the spread of agriculture and the interaction between farmers (invaders) and hunter-gatherers (natives) in southern China. Based on three different kinds of subsistence economies (dryland farming, paddy farming, hunting and gathering), the model focuses on the cultural lifestyles of human groups, involving mobility, population limitations and growth rates, the possibility of diffusion and conversion, and competitive strength. Groups of farmers enter the map alongside native groups of hunter-gatherers and initiate their own development, possible conversion, and encountered conflict.</p> <p>Here is the overall workflow of the model:</p> <p></p>"},{"location":"examples/official/south_china_livelihood/#result-glance","title":"Result glance","text":"<p>The simulation results reveal the sluggish development of farmers under the complex interaction between different cultural groups. This is related to the abundant natural environment of southern China, which acts as a friction zone for the spread of agriculture. The results also provide evidence that once farming accumulates enough advantages in a suitable environment, its development will become rapid and unstoppable.</p> <p></p>"},{"location":"examples/official/yellow_river_water_quota/","title":"Yellow River Water Quota","text":"<p>Warning</p> <p>This is a finished model with a in-production paper. Once the paper is accepted, source codes would be fully released. Please contact the author for any related inquiries.</p>"},{"location":"examples/official/yellow_river_water_quota/#overview","title":"Overview","text":"<p>This project constructs an agent-based model that simulates agricultural irrigation in the Yellow River Basin. It considers agent adaptability through a public goods game framework, simulates interactions between irrigating agents and their environment, identifies the main driving mechanisms behind changes in agricultural irrigation water use.</p> <p>Here is the overall workflow of the model:</p> <p></p>"},{"location":"examples/official/yellow_river_water_quota/#result-glance","title":"Result glance","text":"<p>The simulation results reproduce the unified water quota policies significantly curbed surface water extraction in the Yellow River Basin. The main bodies of irrigation over-quota surface water extraction are concentrated in provinces such as Ningxia, Inner Mongolia, and Shandong, which have relatively accurate simulation capabilities.</p> <p></p>"},{"location":"home/Installation/","title":"Installation","text":""},{"location":"home/Installation/#installation","title":"Installation","text":""},{"location":"home/Installation/#with-pip","title":"with pip recommended","text":"<p><code>ABSESpy</code> is published as a Python package and can be installed with <code>pip</code> or your favorite PyPI package manager, ideally by using a virtual environment. Open up a terminal and install <code>ABSESpy</code> with:</p> Latest <pre><code>pip install abses\n</code></pre> <p>This will automatically install compatible versions of all dependencies.</p> <p>Tip</p> <p>If you don't have prior experience with Python, we recommend reading Using Python's pip to Manage Your Projects' Dependencies, which is a really good introduction on the mechanics of Python package management and helps you troubleshoot if you run into errors.</p>"},{"location":"home/Installation/#from-source-with-git","title":"From source with git","text":"<p>Material for MkDocs can be directly used from GitHub by cloning the repository into a subfolder of your project root which might be useful if you want to use the very latest version:</p> <pre><code>git clone https://github.com/SongshGeoLab/ABSESpy abses\n</code></pre> <p>Next, install the theme and its dependencies with:</p> <pre><code>pip install -e abses\n</code></pre>"},{"location":"home/acknowledge/","title":"acknowledge","text":""},{"location":"home/acknowledge/#sponsors","title":"Sponsors","text":"<ul> <li>This package has been supported by the National Natural Science Foundation of China (grant no. 42041007) and the National Natural Science Foundation of China Joint Fund for Scientific Research on Yellow River (grant no. U2243601).</li> </ul>"},{"location":"home/acknowledge/#thanks-to-all-contributors","title":"Thanks to all contributors","text":""},{"location":"home/comtributing/","title":"Comtributing","text":"<p>As an open source project, ABSESpy welcomes contributions of many forms, and from beginners to experts. If you are curious or just want to see what is happening, we post our development session agendas and development session notes on discussions In no particular order, examples include: - Code patches - Bug reports and patch reviews - New features - Documentation improvements - Tutorials submit a contribution - Find or create something you want to work on - Fork the ABSESpy repository - Clone your repository to your computer - Create a new branch for your work <code>git checkout -b YOUR_BRANCH</code> - Recommend run <code>git config pull.rebase true</code> to prevent messy merge commit - Install the environment <code>poetry install</code> - Edit your change such as code or docs. Save - Add your change file or added file by git <code>git add FILE_NAME</code> - Commit your changes with a message <code>git commit -m \"Fix: DESCRIBE\"</code>. The message should follow conventional commit - Make sure that your submission works with a few of the examples in the examples repository. And if implementing a new feature, include some documentation in docs folder. - Check if your change passes the <code>pre-commit</code>. - Push your change to your fork repository <code>git push origin BRANCH_NAME</code> - Create a pull request and describe your change.</p>"},{"location":"home/comtributing/#how-to-start","title":"How to start","text":"<p>Maybe you are confused about where to start. It's OK! We provide some suggestions depend on your experience:</p>"},{"location":"home/comtributing/#you-are-a-modeller","title":"You are a modeller","text":"<p>You already know how to build ABM model and want to build your own model by ABSESpy. You want to improve that and contribute your idea as an example. Awesome! Firstly you should get some tools and their knowledge. The code is based on <code>python</code> and manage the version by <code>git</code>. After that, talk to us about what you want to change, and open a small PR. Or update the example</p>"},{"location":"home/comtributing/#you-are-a-developer","title":"You are a developer","text":"<p>Great! You have the basics of open-source software development, but not much modelling experience. In this case, learn something about ABM (agent based model). And you can run a model in mesa-example which is a important ABM python package.</p>"},{"location":"home/comtributing/#you-are-both","title":"You are both","text":"<p>Wonderful! You can just start your work and read our workflow to prevent some error.</p>"},{"location":"home/comtributing/#test-and-code-standard","title":"Test and code standard","text":"<p>If you're changing previous features, please make sure of the following:</p> <ul> <li>Your changes pass the current tests.</li> <li>Your changes pass our style standards.</li> <li>Your changes don't break the models or your changes include updated models.</li> <li>Additional features or rewrites of current features are accompanied by tests.</li> <li>New features are demonstrated in a model, so folks can understand more easily. To ensure your code exclude the style error, we recommend <code>mypy</code> . <pre><code>pip install mypy\nmypy test.py\n</code></pre> This process will return the style error if it existed.</li> </ul> <p>To ensure your code will pass our style standards, we recommend <code>black</code>. <pre><code>pip install black\nblack test.py\n</code></pre> Black need a file named \"<code>pyproject.toml</code>\" which had included in our project.</p> <p>You also can use <code>ruff</code>.</p> <p>Test and manage your environment and dependencies by <code>tox</code>. It is a auto-testing tool to simplify multi-environments testing and dependency management. You can create, manage and run different testing environments by <code>tox.ini</code>.</p> <pre><code>pip instal tox\ntox -e your_environment\n</code></pre>"},{"location":"home/comtributing/#license","title":"License","text":"<p>The license of this project is located in [[ABSESpy/docs/home/license|license]]. By submitting a contribution to this project, you are agreeing that your contribution will be released under the terms of this license.</p>"},{"location":"home/comtributing/#maintainers","title":"Maintainers","text":"<p>Some notes useful for ABSESpy maintainers.</p>"},{"location":"home/comtributing/#releases","title":"Releases","text":"<p>To create a new release, follow these steps: 1. Ensure all pull requests (PRs) have a clear title and are labeled with at least one label. 2. Navigate to the Release section in the Github UI and click the Draft a new release button. 3. Use the Generate release notes button to automatically create release notes. Review them carefully for accuracy, and update labels and edit PR titles if necessary (step 1). 4. Write a Highlights section summarizing the most important features or changes in this release. 5. Copy the release notes and save them by clicking the grey Save draft button. 6. Open a new PR to update the version number. 7. Once this PR is merged, return to the Releases section and publish the draft release. 8. Finally, after release, open a new PR to update the version number.</p>"},{"location":"home/comtributing/#special-thanks","title":"Special Thanks","text":""},{"location":"home/contribution/","title":"Contributions","text":""},{"location":"home/contribution/#contributions-are-welcomed","title":"Contributions are welcomed","text":""},{"location":"home/contribution/#ask-questions","title":"Ask questions","text":"<ul> <li>Ask usage questions (\"How to do?\") on\u00a0GitHub Discussions.</li> <li>For less well-defined questions or ideas or to announce other projects of interest to users, use the\u00a0mailing list.</li> </ul>"},{"location":"home/contribution/#report-bugs-code-contributions","title":"Report bugs &amp; Code contributions","text":"<ul> <li>Report bugs, suggest features or view the source code\u00a0on GitHub issues.</li> <li>If you are brand new to\u00a0<code>ABSESpy</code>\u00a0or open-source development, we recommend going through the\u00a0GitHub issues tab\u00a0to find issues that interest you.</li> </ul>"},{"location":"home/dependencies/","title":"Dependencies","text":"<p><code>ABSESpy</code> framework is based on many excellent open-source projects:</p> Package Version Purpose python \"&gt;=3.9,&lt;3.12\" Core programming language used for development netcdf4 \"&gt;=1.6\" To read and write NetCDF and HDF5 files hydra-core \"~1.3\" For managing application configurations mesa-geo \"&gt;=0.6\" To create spatially explicit agent-based models xarray \"~2024\" To work with labelled multi-dimensional arrays fiona \"&gt;1.8\" For reading and writing vector data (shapefiles, etc) loguru \"~0.7\" For better logging rioxarray \"&gt;=0.13\" Operating raster data and xarray pendulum \"~2\" For time control geopandas \"~0\" For shapefile geo-data operating <p>Warning</p> <p>The above table may not be up-in-date, please refer full dependencies and their versions in the <code>pyproject.toml</code> file.</p>"},{"location":"home/get_started/","title":"Get Started","text":""},{"location":"home/get_started/#introduction","title":"Introduction","text":"<p><code>ABSESpy</code> has been designed to be a flexible and easy-to-use framework for agent-based modeling (ABM) of social-ecological systems (SES). It is built on top of the Mesa framework, which is a popular ABM framework in Python. <code>ABSESpy</code> provides a set of tools and utilities to help users to build, run, and analyze ABM models of SESs.</p> <p>This getting-started tutorial help you to run the simplest workflow with <code>ABSESpy</code> framework. If you have agent-based modeling experience and prefer to learn using <code>ABSESpy</code> by examples, you can check out the official examples.</p> <p>Following diagram shows the basic structure of the <code>ABSESpy</code>'s API. Take it easy, you don't have to be familiar with all the features in this beginning stage. You can always go to the API documentation page to find a specific feature.</p> <p></p>"},{"location":"home/get_started/#get-absespy-model-running","title":"Get <code>ABSESpy</code> model running","text":"<p>Assuming you've successfully installed <code>ABSESpy</code>, along with all its dependencies, and properly configured the environment to import the module into your workspace. Running the first blank model that performs no action is straightforward - simply import, initialize, and run...</p> model.py<pre><code>from abses import MainModel\n\nmodel = MainModel()\nmodel.run_model(steps=3)  # How many steps to run\n</code></pre> <p>Warning</p> <p>Without the arg <code>steps</code>, <code>.run_model</code> will run indefinitely unless stopped manually. Unless the ending condition can be found in the configurations.</p>"},{"location":"home/get_started/#custom-the-basic-modules","title":"Custom the basic modules","text":"<p>As the name \"socio-ecological system\" suggests, it usually includes two basic subsystems: social subsystem and ecological subsystem. Each of these subsystem has multiple processes, and a specific model can only care some of them according to the settings.</p> <p><code>ABSESpy</code> translates the structure into two modules: human and natural. Each of the two modules can attach a set of sub-modules for simulating specific processes (This usually needs to be included based on practical issues and expertise).</p> <p>Info</p> ABSESpy diagramSES diagram <p>      Diagram of how <code>ABSESpy</code> simulates a SES </p> <p>      Diagram of Socio-ecological System      </p> <p>Structures of <code>ABSESpy</code> mimic the basic structure of a social-ecosystem system (SES) (1).</p> <ol> <li>More information of SES can be learned in the wiki pages.</li> </ol> <p>Therefore, the default model <code>MainModel</code> provided by <code>ABSESpy</code> has <code>BaseNature</code> and <code>BaseHuman</code> as the two basic modules. They can be accessed through attributes <code>human</code> and <code>nature</code>.</p> <p>Example</p> humannature <pre><code>model = MainModel()\ntype(model.human)\n\n# output\n&gt;&gt;&gt; abses.human.BaseHuman\n</code></pre> <pre><code>model = MainModel()\ntype(model.nature)\n\n# output\n&gt;&gt;&gt; abses.nature.BaseNature\n</code></pre> <p>Users can custom the modules by inheriting <code>BaseNature</code>, <code>BaseHuman</code>, and <code>MainModel</code> from the three basic Components (1).</p> <ol> <li><code>ABSESpy</code> uses the term \"Component\" representing the modules, including not only <code>BaseNature</code> and <code>BaseHuman</code>, but also the sub-modules attached with <code>BaseNature</code> and <code>BaseHuman</code>.</li> </ol> <p>Generally, each users are four methods can</p> <p>Example</p> model.pyhuman.pynature.pyFile tree model.py<pre><code>from abses import MainModel\n# Import the custom modules.\nfrom human import CustomHuman\nfrom nature import CustomNature\n\nmodel = MainModel(human_class=Human, nature_class=Nature)\nmodel.run_model(steps=3)  # How many steps to run\n\n# output\n&gt;&gt;&gt; Setup the nature module.\n&gt;&gt;&gt; Setup the human module.\n&gt;&gt;&gt; Nature in the step 0.\n&gt;&gt;&gt; Human in the step 0.\n&gt;&gt;&gt; Nature in the step 1.\n&gt;&gt;&gt; Human in the step 1.\n&gt;&gt;&gt; Nature in the step 2.\n&gt;&gt;&gt; Human in the step 2.\n&gt;&gt;&gt; End of the nature module.\n&gt;&gt;&gt; End of the human module.\n</code></pre> human.py<pre><code>from abses import BaseHuman\n\nclass CustomHuman(BaseHuman):\n    \"\"\"A custom Human module.\n    \"\"\"\n\n    def initialize(self):\n        print(\"Initializing the human module.\")\n\n    def setup(self):\n        print(\"Setup the human module.\")\n\n    def step(self):\n        print(f\"Human in the step {self.time.tick}.\")\n\n    def end(self):\n        print(\"End of the human module.\")\n</code></pre> nature.py<pre><code>from abses import BaseNature\n\nclass CustomNature(BaseNature):\n    \"\"\"A custom Nature module.\n    \"\"\"\n\n    def initialize(self):\n        print(\"Initializing the nature module.\")\n\n    def setup(self):\n        print(\"Setup the nature module.\")\n\n    def step(self):\n        print(f\"Nature in the step {self.time.tick}.\")\n\n    def end(self):\n        print(\"End of the nature module.\")\n</code></pre> <pre><code>root\n\u2514\u2500\u2500 src\n    \u251c\u2500\u2500 human.py\n    \u251c\u2500\u2500 model.py\n    \u2514\u2500\u2500 nature.py\n</code></pre> <p>The following project structure is recommended for maintaining:</p> <ol> <li><code>root</code> is the project directory.</li> <li><code>src</code> contains all the source codebase.</li> <li><code>model.py</code> is your model.</li> <li>In the<code>human.py</code>, custom logics of the social subsystem.</li> <li>In the <code>nature.py</code>, custom logics of the eco-subsystem.</li> </ol> <p>In the above example, we customize the two components <code>Nature</code> and <code>Human</code>, then import them from source to be used as args for the model. We wrote four different methods for each component:</p> <ul> <li><code>initialize</code>: called when the model is initialized.</li> <li><code>setup</code>: called when the model is going to start running.</li> <li><code>step</code>: called in the each time step of the model.</li> <li><code>end</code>: called when the model has finished running.</li> </ul>"},{"location":"home/get_started/#create-and-manage-agents","title":"Create and manage agents","text":"<p>Agent-based model means, some actors will be included in the artificial SES. <code>ABSESpy</code> provides an <code>AgentsContainer</code> to store and manage the agents, which can be accessed through the attribute <code>model.agents</code>. Under the context of SES, an agent sometimes is also called a social <code>Actor</code> (1). For creating such actors, we need to import the class <code>Actor</code>, which can also be customized by inheriting.</p> <ol> <li>social actor - who is not only influenced by the system, but also has motility to make decisions for changing the system</li> </ol> <pre><code>from abses import Actor, MainModel\n\n\nclass MyActor(Actor):\n    \"\"\"A customized actor\"\"\"\n\n    def say_hi(self) -&gt; str:\n        print(f\"Hello, world! I'm a new {self.breed}!\")\n\n\nmodel = MainModel()\nactors = model.agents.new(Actor, 5)\nmy_actor = model.agents.new(MyActor, singleton=True)\n\nmy_actor.say_hi()\nprint(model.agents)\n\n# output\n&gt;&gt;&gt; \"Hello, world! I'm a new MyActor!\"\n&gt;&gt;&gt; \"&lt;AgentsContainer: (5)Actor; (1)MyActor&gt;\"\n</code></pre> <p>In the above example, we customize the new breed (1) of actor -<code>MyActor</code>. Then, we created five default <code>Actor</code> instances and one <code>MyActor</code> instance. All of the instances are stored in the <code>AgentsContainer</code> and attached to the model, so that users can access, add, delete, query, and change agents anytime they need through the <code>AgentsContainer</code>.</p> <ol> <li>By default, breed of an agent is just it's class name. User can change this behavior by overriding <code>breed</code> class property.</li> </ol>"},{"location":"home/get_started/#configuration-of-the-model","title":"Configuration of the model","text":"<p>As you would have expected, modeling a real-world SES is far more complex than the example codes above. Luckily, one of the zens of <code>ABSESpy</code> is to separate the configuration and the model logic. As long as we configure it as follows, you will find that the ABSESpy framework is suitable for modeling of any complexity:</p> main.py<pre><code>from abses import MainModel, Actor\n\nclass MyModel(MainModel):\n    \"\"\"Customized model.\"\"\"\n\n    def setup(self):\n        n_agents = self.params.get('init_agents')\n        self.agents.new(Actor, n_agents)\n\n    def step(self):\n        n_agents = self.params.get('n_agents')\n        self.agents.new(Actor, n_agents)\n\n    def end(self):\n        n_agents = len(self.agents)\n        print(f\"In {self.time}, there are {n_agents} actors.\")\n\n# A nested dictionary of parameters\nparameters = {\n    'time': {'start': '2000-01-01', 'end': '2003-03-21', 'months': 8, 'years': 2},\n    'model': {'init_agents': 5, 'n_agents': 1}\n}\n\n# Initialize the model and run it.\nmodel = MyModel(parameters=parameters)\nmodel.run_model()\n</code></pre> <p>Not scared by these parameters, are you? Things are very simple:</p> <ol> <li><code>MainModel</code> accepts a nested dictionary as parameters.</li> <li>In the parameters, <code>time</code> describes the time start/step/end rules, while <code>model</code> provided two parameters which can be parsed by the model.</li> <li>In the <code>time</code> section, <code>start = '2000-01-01'</code> means when the model start to run, it mimic the day on 01th Jan. 2000. Similarly, <code>end = '2003-03-21'</code> means when the model time reach the day on 21th March 2003. Each time step simulates two years and eight months because of two parameters: <code>months = 8</code> and <code>years = 2</code>.</li> <li>According to the the customized functions <code>setup</code>, the model will add some initial actors based on the parameter <code>init_agents</code> provided. Similarly, the customized functions <code>step</code>, the model will add some actors in each step based on the parameters <code>n_agents</code>.</li> <li>Okay! Elementary math time! When will the running model should be end? How many actors will be there when it ends?</li> </ol> <pre><code># output\n&gt;&gt;&gt; \"In &lt;TimeDriver: 2005-05-01 00:00:00&gt;, there are 7 actors.\"\n</code></pre> <p>Tip</p> <p>You don't have to worry about writing a long long nested dictionary for the parameters in practice. <code>ABSESpy</code> allows users to easily manage complex parameters by using configuration files.</p>"},{"location":"home/get_started/#what-to-do-for-the-next","title":"What to do for the next","text":"<p>Congratulations! So far, you have become familiar with the main concepts of the <code>ABSESpy</code> framework and know how to run a model.</p> <p>We encourage you to return to our Guide Checklist, find out the feature or example model which most attractive to you.</p> <p>Once you've decide to develop your own ABM by using <code>ABSESpy</code>, our well-organized API documentation should be a good reference. We also have detailed tutorials for users from different levels, happy coding!</p>"},{"location":"home/guide_checklist/","title":"Guide Checklist","text":""},{"location":"home/guide_checklist/#find-your-start-point-to-use-absespy","title":"Find your start point to use <code>ABSESpy</code>","text":""},{"location":"home/guide_checklist/#is-absespy-my-thing","title":"Is <code>ABSESpy</code> my thing?","text":"<p>For using <code>ABSESpy</code>, you'd better to have basic experience with Python. Then, choose the best description of your knowledge background:</p> <p> I'm familiar with ABM  I'm familiar with SES</p> <p> If you're unfamiliar with ABM or SES, we recommend visiting our wiki pages to gain a basic understanding.</p>"},{"location":"home/license/","title":"license","text":""},{"location":"home/license/#license","title":"License","text":"<p>Copyright 2023, <code>ABSESpy</code> Shuang Song</p> <p>Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at</p> <p>https://www.apache.org/licenses/LICENSE-2.0</p> <p>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.</p> <p><code>ABSESpy</code> bundles portions of <code>Mesa</code>, <code>Mesa-Geo</code>, <code>pandas</code>, <code>NumPy</code>, and <code>Xarray</code>; the full text of these licenses are included in the licenses directory.</p>"},{"location":"paper/paper/","title":"ABSESpy: An agent-based modeling framework for social-ecological systems","text":"","tags":["Python","Agent-based model","Social-ecological system","Geography","Social science"]},{"location":"paper/paper/#summary","title":"Summary","text":"<p><code>ABSESpy</code> is a novel agent-based modeling (ABM) framework that facilitates socio-ecological systems (SES) research. It serves as an extension package of <code>Mesa</code>, the most popular ABM framework, and further enhances agents' interactions with other components, especially grid-like spaces. With a configuration file for managing parameters and an improved data Input/Output system, <code>ABSESpy</code>'s modularity and low-coupling design enable elegant maintenance of large modeling projects. In addition, <code>ABSESpy</code> includes a schedule that aligns models' tick with the calendar time. These innovations position <code>ABSESpy</code> as a valuable tool in fostering more ABMs for real-world SES issues. Its ultimate aim is to become the go-to choice for ABM when working with a human-involved changing world.</p>","tags":["Python","Agent-based model","Social-ecological system","Geography","Social science"]},{"location":"paper/paper/#statement-of-need","title":"Statement of need","text":"<p>Social-ecological systems (SES) are integrated concepts recognizing the complex and interdependent dynamics between human societies and ecological systems <sup>1</sup>. SES consists of decision-making actors (i.e., agents representing people, communities, organizations, and environmental components) capable of following heterogeneous objectives (i.e., agents) <sup>2</sup>. As such, SES has specific needs for research support from agent-based modeling (ABM).</p> <p>However, since few models can effectively represent the real-world SES problem, the potential of ABMs has yet to be fully realized in SES research <sup>3</sup>. One reason is the variability of actors' interaction with each other or geographic spaces, including learning, decision-making, and contagion across social networks <sup>4</sup>. Another reason is the complexity of managing data, parameters, and social and natural processes <sup>5</sup>, which makes it hard to maintain large projects. Therefore, facilitating SES research with ABM requires novel tools <sup>6</sup> to implement the interactions between actors and real-world-like natural processes with manageability and reproducibility.</p> <p>The popular programming language <code>Python</code> is among the first choices for scientists who care about ABM, and <code>Mesa</code> <sup>7</sup> is the most widely used implementation framework. It remains extensible for different domains while providing the core functionality of ABM. Therefore, customizing <code>Mesa</code> by enhancing real-world representation could be a good start for specializing in SES research. It includes expressing decision-making actors' interactions, social-ecological networks, calendar time, raster data, and extensible sub-systems. To this end, <code>ABSESpy</code> is a <code>Mesa</code> package and an advanced framework that fills gaps in SES modeling with these features.</p>","tags":["Python","Agent-based model","Social-ecological system","Geography","Social science"]},{"location":"paper/paper/#design-structures","title":"Design structures","text":"<p><code>ABSESpy</code>'s low-coupling design enables the implementation of maintainable projects by separating the human and natural subsystems within SESs (\\autoref{fig:1}). While the human subsystem manages actors (i.e., agents) and their interactions, the natural submodule typically handles how actors live in, move through, and interact with grid-like patch layers. This architecture also supports adding specialized submodules in each subsystem to represent varying processes with modularity.</p> <p><code>ABSESpy</code> includes the default schedule, data collector, and batch runner utilities, available as a <code>Mesa</code> package but with enhanced functionality. It also introduces a calendar-like time driver and supports configuration management using YAML configuration files. In addition, the packages <code>Xarray</code> <sup>8</sup> and <code>Mesa-Geo</code> <sup>9</sup> are embedded to implement an Input/Output driver for different geographic datasets (<code>.tif</code>, <code>.nc</code>, <code>.json</code>, <code>.shp</code>, and others). The design focuses on two core improvements: (1) handling actors and their interactions and (2) enhancing the reality and manageability of ABMs.</p> <p></p>","tags":["Python","Agent-based model","Social-ecological system","Geography","Social science"]},{"location":"paper/paper/#handling-actors-and-their-interactions","title":"Handling actors and their interactions","text":"<p>Under the context of SES, <code>ABSESpy</code> conceptualizes \"agents\" as <code>Actor</code>s managed within a global <code>ActorsContainer</code> which can be manipulated in batches through any <code>ActorsList</code>. Users can also query, select, or apply a function to a subset of actors by <code>ActorsList</code>. Furthermore, whenever users link some <code>Actor</code>s with others or some <code>PatchCell</code>s, <code>Networkx</code> can automatically convert these linkages into a graph. Thus, it enables actors to interact through social networks or implement a social-ecological network analysis.</p> <p>Since <code>ABSESpy</code> recognizes the centrality of human behavior in SES studies, it also provides a standard workflow based on a popular theoretical framework for decision-making (\\autoref{fig:2}) <sup>10</sup><sup>11</sup>. The following main steps can be implemented seamlessly when working with <code>ABSESpy</code>:</p> <ol> <li>Perceptions:  An <code>Actor</code> holds perceptions of natural and human subsystems by observing global/environmental variables (cognition) or learning from links with others (contagion). <code>ABSESpy</code> helps users dynamically define an expression to update perceptions as <code>Actor</code>s' attributes.</li> <li>Decision-making: <code>Actor</code>s evaluate potential options to determine how to act in the current situation. <code>ABSESpy</code> includes utilities for pre-defined options, thus enabling auto-triggering actions by passing an evaluating function.</li> <li>Response: Some actions may lead to feedback towards human or natural subsystems as a response. Besides many available actions, such as spatial relocation and setting attributes, <code>ABSESpy</code> also includes tools to avoid the feedback that causes a nested loop.</li> </ol> <p></p>","tags":["Python","Agent-based model","Social-ecological system","Geography","Social science"]},{"location":"paper/paper/#enhancing-the-reality-and-manageability-of-abms","title":"Enhancing the reality and manageability of ABMs","text":"<p>To enhance reality, <code>ABSESpy</code> provides an innovative time control mechanism to bridge the gap between the association of ABM and real-world time (\\autoref{fig:3}). In addition to <code>Mesa</code>'s standard tick-based time advancement, users can implement calendar temporal modes to match the diverse scales of SES phenomena with <code>ABSESpy</code>. The model can represent time intervals from minutes to years by defining the calendar time for each simulation step. This flexibility is crucial when modeling real-world events like natural cycles or periodic human activities.</p> <p></p> <p><code>ABSESpy</code> includes utilities for manageability purposes based on the above time control mechanism. The commonly used one is automatically importing and updating temporal time series datasets like monthly or daily weather. Users can also specify time conditions to apply or not apply any model method, such as customizing a \"<code>get_up()</code>\" method to <code>Actor</code> and only calling it at 8:00 am in a one-hour-per-step model. Finally, all parameters can be stored in YAML configuration files with readable expressions. For example, passing parameters <code>{\"start\": '2022-12-31', \"end\": '2024-01-01', \"years\": 1}</code> to the <code>time</code> module means the simulation starts at the end of 2022 and ends when the beginning of 2024 is reached. Since each step represents a year, the model only goes one step.</p>","tags":["Python","Agent-based model","Social-ecological system","Geography","Social science"]},{"location":"paper/paper/#positioning-and-comparison","title":"Positioning and comparison","text":"<p>By translating theoretical constructs into user-friendly, operational components, <code>ABSESpy</code> empowers researchers to bridge the gap between conceptual models and their tangible application in SES. As a specialized <code>Mesa</code> package for the emerging SES field, <code>ABSESpy</code> can take advantage of most of the benefits from the related projects (e.g., model visualization from <code>Mesa</code> and geo-data processing from <code>Mesa-Geo</code>). <code>ABSESpy</code> aims to become the go-to choice for ABM when working with a human-involved, changing world. This vision is similar to the existing <code>ABCE</code> <sup>12</sup>, which aims to provide an economic problem modeling framework (also a <code>Mesa</code> package), but it targets real-world SES problems.</p> <p>Many open-source SES models are published on <code>CoMSES</code> <sup>13</sup> and use <code>NetLogo</code> <sup>14</sup> software. However, users might struggle to maintain its all-in-one structure when data Input/Output and parameters become extensive. The visible advantage of <code>ABSESpy</code> lies in its modularity and low-coupling design, which is suitable for large-scale SES modeling projects. It calls upon vast amounts of actual data for real-world problem modeling. With a separate configuration file, <code>ABSESpy</code> makes it easier to maintain a large project, allowing users to couple sub-modules and maximize <code>Python</code>'s advantages as a \"glue language.\" In <code>Python</code>, another possible competitor is <code>AgentPy</code> <sup>15</sup>, whose goal is a general ABM framework and is thus more concerned with agents (in other words, the \"human\" part). Due to more geographic data processing extensions like <code>Mesa-Geo</code>, <code>ABSESpy</code> allows users to handle grid-like spaces and calendar-like schedules more efficiently. Thus, facing real-world SES problems, building on <code>ABSESpy</code> will require less coding effort to simulate interactions between humans and nature.</p>","tags":["Python","Agent-based model","Social-ecological system","Geography","Social science"]},{"location":"paper/paper/#acknowledgment","title":"Acknowledgment","text":"<p>This research has been supported by the National Natural Science Foundation of China (grant no. 42041007) and the National Natural Science Foundation of China (grant no. U2243601).</p>","tags":["Python","Agent-based model","Social-ecological system","Geography","Social science"]},{"location":"paper/paper/#references","title":"References","text":"<ol> <li> <p>Carl Folke, Stephen R. Carpenter, Brian Walker, Marten Scheffer, Terry Chapin, and Johan Rockstrom. Resilience thinking: integrating resilience, adaptability and transformability. Ecology and Society, 15(4):20, 2010. doi:10.5751/es-03610-150420.\u00a0\u21a9</p> </li> <li> <p>Simon Levin, Tasos Xepapadeas, Anne-Sophie Cr\u00e9pin, Jon Norberg, Aart de Zeeuw, Carl Folke, Terry Hughes, Kenneth Arrow, Scott Barrett, Gretchen Daily, Paul Ehrlich, Nils Kautsky, Karl-G\u00f6ran M\u00e4ler, Steve Polasky, Max Troell, Jeffrey R. Vincent, and Brian Walker. Social-ecological systems as complex adaptive systems: modeling and policy implications. Environment and Development Economics, 18(02):111\u2013132, April 2013. doi:10.1017/S1355770X12000460.\u00a0\u21a9</p> </li> <li> <p>Jule Schulze, Birgit M\u00fcller, J\u00fcrgen Groeneveld, and Volker Grimm. Agent-based modelling of social-ecological systems: achievements, challenges, and a way forward. Journal of Artificial Societies and Social Simulation, 20(2):8, 2017. doi:10.18564/jasss.3423.\u00a0\u21a9</p> </li> <li> <p>Belinda Reyers, Carl Folke, Michele-Lee Moore, Reinette Biggs, and Victor Galaz. Social-ecological systems insights for navigating the dynamics of the Anthropocene. Annual Review of Environment and Resources, October 2018. doi:10.1146/annurev-environ-110615-085349.\u00a0\u21a9</p> </li> <li> <p>Michael R. Davidson, Tatiana Filatova, Wei Peng, Liz Verbeek, and Fikri Kucuksayacigil. Simulating institutional heterogeneity in sustainability science. Proceedings of the National Academy of Sciences, 121(8):e2215674121, February 2024. doi:10.1073/pnas.2215674121.\u00a0\u21a9</p> </li> <li> <p>Maja Schl\u00fcter, Christa Brelsford, Paul J. Ferraro, Kirill Orach, Minghao Qiu, and Martin D. Smith. Unraveling complex causal processes that affect sustainability requires more integration between empirical and modeling approaches. Proceedings of the National Academy of Sciences, 120(41):e2215676120, October 2023. doi:10.1073/pnas.2215676120.\u00a0\u21a9</p> </li> <li> <p>Jackie Kazil, David Masad, and Andrew Crooks. Utilizing Python for agent-based modeling: The Mesa framework. Springer International Publishing, Cham, 2020. ISBN 978-3-030-61255-9.\u00a0\u21a9</p> </li> <li> <p>S. Hoyer and J. Hamman. Xarray: N-D labeled arrays and datasets in Python. Journal of Open Research Software, 2017. URL: https://doi.org/10.5334/jors.148, doi:10.5334/jors.148.\u00a0\u21a9</p> </li> <li> <p>Boyu Wang, Vincent Hess, and Andrew Crooks. Mesa-Geo: a gis extension for the Mesa agent-based modeling framework in Python. In Proceedings of the 5th ACM SIGSPATIAL international workshop on GeoSpatial simulation, GeoSim '22, 1\u201310. New York, NY, USA, 2022. Association for Computing Machinery. doi:10.1145/3557989.3566157.\u00a0\u21a9</p> </li> <li> <p>Maja Schl\u00fcter, Andres Baeza, Gunnar Dressler, Karin Frank, J\u00fcrgen Groeneveld, Wander Jager, Marco A. Janssen, Ryan R. J. McAllister, Birgit M\u00fcller, Kirill Orach, Nina Schwarz, and Nanda Wijermans. A framework for mapping and comparing behavioural theories in models of social-ecological systems. Ecological Economics, January 2017. doi:10.1016/j.ecolecon.2016.08.008.\u00a0\u21a9</p> </li> <li> <p>Brian Beckage, Frances C. Moore, and Katherine Lacasse. Incorporating human behaviour into Earth system modelling. Nature Human Behaviour, 6(11):1493\u20131502, November 2022. doi:10.1038/s41562-022-01478-5.\u00a0\u21a9</p> </li> <li> <p>Davoud Taghawi-Nejad, Rudy H. Tanin, R. Maria Del Rio Chanona, Adri\u00e1n Carro, J. Doyne Farmer, Torsten Heinrich, Juan Sabuco, and Mika J. Straka. ABCE: A Python library for economic agent-based modeling. Springer International Publishing, Cham, 2017. ISBN 978-3-319-67217-5.\u00a0\u21a9</p> </li> <li> <p>Marco A. Janssen, Lilian Na'ia Alessa, Michael Barton, Sean Bergin, and Allen Lee. Towards a community framework for agent-based modelling. Journal of Artificial Societies and Social Simulation, 11(2):6, 2008. URL: https://www.jasss.org/11/2/6.html.\u00a0\u21a9</p> </li> <li> <p>Seth Tisue and Uri Wilensky. NetLogo: a simple environment for modeling complexity. In International conference on complex systems, volume 21, 16\u201321. Citeseer, 2004.\u00a0\u21a9</p> </li> <li> <p>Jo\u00ebl Foramitti. AgentPy: a package for agent-based modeling in Python. Journal of Open Source Software, 6(62):3065, June 2021. doi:10.21105/joss.03065.\u00a0\u21a9</p> </li> </ol>","tags":["Python","Agent-based model","Social-ecological system","Geography","Social science"]},{"location":"tutorial/tutorial/","title":"Tutorial","text":""},{"location":"tutorial/tutorial/#tutorial","title":"Tutorial","text":"<p>Here, we provide a series of tutorials based on Jupyter Notebook, demonstrating the potential needs and solutions when developing with <code>ABSESpy</code> in practice. We expect you to have read through Quick Start guide and that you have assessed whether <code>ABSESpy</code> is the right software for you. Three levels of tutorials are available below:</p> <p>In Progress</p> <p>This document is a work in progress if you see any errors, or exclusions or have any problems, please get in touch with us.</p>"},{"location":"tutorial/tutorial/#beginner-level","title":"Beginner level","text":"<p>You're looking to create and operate a basic model by <code>ABSESpy</code> framework. Wondering what constitutes a \"simple\" model? Explore the NetLogo model repository; you'll find many classic yet easy-to-understand examples there.</p> <p> B01 Welcome to review the quick start in notebook anytime.</p> <p> B02 Organize your model structure with elegance.</p> <p> B03 Keep your model in time with the real world.</p> <p> B04 Separate configuration and model logic with a config file.</p> <p> B05 Manage actors better with different containers.</p> <p> B06 Move your agents in the artificial world.</p> <p> B07 Example of wolf-Sheep predation model, a classic heuristic model<sup>1</sup>.</p> <p> B08 Learn links between <code>Actor</code> and <code>PatchCell</code>.</p> <p> Huh ... More tutorials in this level are coming soon.</p>"},{"location":"tutorial/tutorial/#advanced-level","title":"Advanced level","text":"<p>You have gained a thorough understanding of the agent-based model. Now, you are not just satisfied with heuristic models<sup>1</sup>, you aspire to undertake a larger project to solve real-world SES problems.</p> <p> A01 Including real-world geographic datasets for natural modules.</p> <p> Huh ... More tutorials in this level are coming soon.</p>"},{"location":"tutorial/tutorial/#completing-level","title":"Completing level","text":"<p>You have already established your own model and confirmed that it does not have major logical issues. You need help with batch experiments, data analysis, plotting, parameter sensitivity analysis, and visualization.</p> <p> C01 Batch run with different parameters, a comprehensive example for model viz and experiment.</p> <p> Huh ... More tutorials in this level are coming soon.</p> <ol> <li> <p>Heuristic models are streamlined strategies used to tackle complex issues when precise formulas or solutions aren't feasible. These models rely on heuristic methods, practical tactics that may not always yield the best solution but offer a satisfactory one within an acceptable time limit.\u00a0\u21a9\u21a9</p> </li> </ol>"},{"location":"tutorial/tutorial_guide_from_ABM/","title":"Start from ABM","text":""},{"location":"tutorial/tutorial_guide_from_ABM/#im-familiar-with-abm","title":"I'm familiar with ABM","text":"<p>If you understand the concepts related to ABM and have basic Python programming experience, then using <code>ABSESpy</code> should be relatively easy. Don't be intimidated by the term SES, it's just a theoretical framework for studying human-environment interactions.</p> <p>Note</p> <p>In fact, most published ABMs contain an environmental system, they just don't use the concept of SES.</p> <p>The following table may help you to understand what aspects of using <code>ABSESpy</code> can help improve your development efficiency and which type of agent-based modeling it suits.</p> Check box Related sources  A space for the agents to move around; normally a Grid Space.  Spatial data  The model time corresponds to a concrete real world time. Time control  Agents have decisions to do, like human.  [Human behavior framework]  Data input/output, especially real-world geo-data.  Data management <p>Besides the above specific features, an overall implementation of ABM by using <code>ABSESpy</code> can be found from the get-started tutorial.</p>"},{"location":"tutorial/tutorial_guide_from_SES/","title":"Start from SES","text":""},{"location":"tutorial/tutorial_guide_from_SES/#im-familiar-with-ses","title":"I'm familiar with SES","text":"<p>If you understand the concepts related to SES, you should know that emergence is a very important feature, and the advantage of ABM is that it can reveal and simulate it. Of course, SES has other features, we strongly recommend starting with specific case models to understand how the ABM method can help you identify the specific features of SES.</p> <p>Warning</p> <p>We are actively developing different cases, some of the following examples will be available soon.</p> SES features Related case model  Emergence Fire  Dynamic Predation  Human decision making Hotelling  Real-world policies  Water allocation <p>One more thing, if you have implemented ecological/social processes models using Python, you can easily embed them as submodules into an ABM with <code>ABSESpy</code>. This is because <code>ABSESpy</code>'s framework structure perfectly matches the SES structure and designed for easily coupling.</p>"},{"location":"tutorial/advanced/geodata/","title":"Setup Nature Modules","text":"<p>Create an example <code>xarray.DataArray</code> whose shape is (40 * 50).</p> In\u00a0[1]: Copied! <pre>import xarray as xr\nimport numpy as np\n\n\ndata = xr.DataArray(data=np.arange(2000).reshape((40, 50)), dims=(\"y\", \"x\"))\ndata.plot()\n</pre> import xarray as xr import numpy as np   data = xr.DataArray(data=np.arange(2000).reshape((40, 50)), dims=(\"y\", \"x\")) data.plot() Out[1]: <pre>&lt;matplotlib.collections.QuadMesh at 0x7f41caf7a8d0&gt;</pre> <p>Create an <code>ABSESpy</code> model with 10 * 10 natural patch module.</p> In\u00a0[2]: Copied! <pre>from abses import MainModel\n\nmodel = MainModel()\nmodule = model.nature.create_module(how=\"from_resolution\", shape=(10, 10))\n\nmodel.summary()\n</pre> from abses import MainModel  model = MainModel() module = model.nature.create_module(how=\"from_resolution\", shape=(10, 10))  model.summary() <pre>[14:20:09][WARNING][nature] the nature's CRS has been changed to epsg:4326.\n</pre> <pre>Using ABSESpy version: v0.7.0\n</pre> Out[2]: <pre>name     MainModel\nstate         init\ntick             0\ndtype: object</pre> <p>When apply raster of a <code>xarray.DataArray</code> to natural module, the raster will be automatically reprojected to the natural module's spatial extent.</p> In\u00a0[3]: Copied! <pre>module.apply_raster(\n    data, attr_name=\"test\", cover_crs=True, resampling_method=\"bilinear\"\n)\nax = module.get_xarray(\"test\").plot()\n</pre> module.apply_raster(     data, attr_name=\"test\", cover_crs=True, resampling_method=\"bilinear\" ) ax = module.get_xarray(\"test\").plot() <pre>/home/runner/work/ABSESpy/ABSESpy/.venv/lib/python3.11/site-packages/xarray/plot/utils.py:260: RuntimeWarning: overflow encountered in scalar absolute\n  vlim = max(abs(vmin - center), abs(vmax - center))\n</pre> <p>note: edge effect may exists when re-projecting the raster.</p> <p>Here, we have a demo of how to load climate data and apply it to the natural module. When loading the data, the data will be automatically reprojected to the natural module's spatial extent.</p> In\u00a0[4]: Copied! <pre>from abses import load_data\n\nraster_path = load_data(\"farmland.tif\")\n\ncropland = model.nature.create_module(\n    how=\"from_file\",\n    raster_file=raster_path,\n    apply_raster=True,\n    name=\"cropland\",\n)\n\ncropland.get_xarray().plot()\n</pre> from abses import load_data  raster_path = load_data(\"farmland.tif\")  cropland = model.nature.create_module(     how=\"from_file\",     raster_file=raster_path,     apply_raster=True,     name=\"cropland\", )  cropland.get_xarray().plot() <pre>/home/runner/work/ABSESpy/ABSESpy/abses/nature.py:170: UserWarning: Converting PatchModule from crs EPSG:4326 to the crs of BaseNature - EPSG:4326. Please check your crs settings if this is unintended, or set `GeoSpace.warn_crs_conversion` to `False` to suppress this warning message.\n  self.add_layer(module)\n</pre> Out[4]: <pre>&lt;matplotlib.collections.QuadMesh at 0x7f41a778b190&gt;</pre> In\u00a0[5]: Copied! <pre>data = xr.open_dataset(load_data(\"precipitation.nc\"))\ndata\n</pre> data = xr.open_dataset(load_data(\"precipitation.nc\")) data Out[5]: <pre>&lt;xarray.Dataset&gt; Size: 13MB\nDimensions:  (lat: 400, lon: 700, time: 12)\nCoordinates:\n  * lat      (lat) float32 2kB 15.05 15.15 15.25 15.35 ... 54.75 54.85 54.95\n  * lon      (lon) float32 3kB 70.05 70.15 70.25 70.35 ... 139.8 139.9 140.0\n  * time     (time) datetime64[ns] 96B 2018-01-16T10:30:00 ... 2018-12-16T10:...\nData variables:\n    prec     (time, lat, lon) float32 13MB ...\nAttributes:\n    Conventions:  CF-1.0\n    history:      Created at 2016-04-02 14:55:55 UTC by the ITPCAS Data Fusio...\n    source:       ITPCAS Data Fusion System (Version: 01.02.0240)\n    institution:  Institute of Tibetan Plateau Research, Chinese Academy of S...\n    title:        Monthly mean precipitation rate from the ITPCAS China Meteo...\n    description:  Data from ITPCAS China Meteorological Forcing Dataset (Vers...\n    references:   He, J., and K. Yang, 2011: China Meteorological Forcing Dat...</pre>xarray.Dataset<ul><li>Dimensions:<ul><li>lat: 400</li><li>lon: 700</li><li>time: 12</li></ul></li><li>Coordinates: (3)<ul><li>lat(lat)float3215.05 15.15 15.25 ... 54.85 54.95standard_name :latitudelong_name :latitudeunits :degrees_northaxis :Y<pre>array([15.05    , 15.150001, 15.25    , ..., 54.75    , 54.85    , 54.95    ],\n      dtype=float32)</pre></li><li>lon(lon)float3270.05 70.15 70.25 ... 139.9 140.0standard_name :longitudelong_name :longitudeunits :degrees_eastaxis :X<pre>array([ 70.05   ,  70.15   ,  70.25   , ..., 139.75   , 139.85   , 139.95001],\n      dtype=float32)</pre></li><li>time(time)datetime64[ns]2018-01-16T10:30:00 ... 2018-12-...standard_name :timelong_name :Timeaxis :T<pre>array(['2018-01-16T10:30:00.000000000', '2018-02-14T22:30:00.000000000',\n       '2018-03-16T10:30:00.000000000', '2018-04-15T22:30:00.000000000',\n       '2018-05-16T10:30:00.000000000', '2018-06-15T22:30:00.000000000',\n       '2018-07-16T10:30:00.000000000', '2018-08-16T10:30:00.000000000',\n       '2018-09-15T22:30:00.000000000', '2018-10-16T10:30:00.000000000',\n       '2018-11-15T22:30:00.000000000', '2018-12-16T10:30:00.000000000'],\n      dtype='datetime64[ns]')</pre></li></ul></li><li>Data variables: (1)<ul><li>prec(time, lat, lon)float32...long_name :Precipitation rateunits :mm hr-1<pre>[3360000 values with dtype=float32]</pre></li></ul></li><li>Indexes: (3)<ul><li>latPandasIndex<pre>PandasIndex(Index([15.050000190734863,  15.15000057220459,              15.25,\n       15.350000381469727, 15.449999809265137, 15.550000190734863,\n        15.65000057220459,              15.75, 15.850000381469727,\n       15.949999809265137,\n       ...\n        54.04999923706055, 54.150001525878906,              54.25,\n       54.349998474121094,  54.45000076293945,  54.54999923706055,\n       54.650001525878906,              54.75, 54.849998474121094,\n        54.95000076293945],\n      dtype='float32', name='lat', length=400))</pre></li><li>lonPandasIndex<pre>PandasIndex(Index([ 70.05000305175781,   70.1500015258789,              70.25,\n        70.35000610351562,  70.45000457763672,  70.55000305175781,\n         70.6500015258789,              70.75,  70.85000610351562,\n        70.95000457763672,\n       ...\n        139.0500030517578, 139.14999389648438,             139.25,\n       139.35000610351562, 139.45001220703125,  139.5500030517578,\n       139.64999389648438,             139.75, 139.85000610351562,\n       139.95001220703125],\n      dtype='float32', name='lon', length=700))</pre></li><li>timePandasIndex<pre>PandasIndex(DatetimeIndex(['2018-01-16 10:30:00', '2018-02-14 22:30:00',\n               '2018-03-16 10:30:00', '2018-04-15 22:30:00',\n               '2018-05-16 10:30:00', '2018-06-15 22:30:00',\n               '2018-07-16 10:30:00', '2018-08-16 10:30:00',\n               '2018-09-15 22:30:00', '2018-10-16 10:30:00',\n               '2018-11-15 22:30:00', '2018-12-16 10:30:00'],\n              dtype='datetime64[ns]', name='time', freq=None))</pre></li></ul></li><li>Attributes: (7)Conventions :CF-1.0history :Created at 2016-04-02 14:55:55 UTC by the ITPCAS Data Fusion Systemsource :ITPCAS Data Fusion System (Version: 01.02.0240)institution :Institute of Tibetan Plateau Research, Chinese Academy of Sciences, Beijing, Chinatitle :Monthly mean precipitation rate from the ITPCAS China Meteorological Forcing Datasetdescription :Data from ITPCAS China Meteorological Forcing Dataset (Version: 01.06.0014; Category: B-01: 03hr, 0.10deg)references :He, J., and K. Yang, 2011: China Meteorological Forcing Dataset. Cold and Arid Regions Science Data Center, Lanzhou, Gansu, China, digital media, doi:10.3972/westdc.002.2014.db. [Available online at http://westdc.westgis.ac.cn/data/7a35329c-c53f-4267-aa07-e0037d913a21.]</li></ul> In\u00a0[6]: Copied! <pre>a_month = data.sel(time=\"2013-01\", method=\"nearest\")\na_month[\"prec\"].plot()\n\na_month\n</pre> a_month = data.sel(time=\"2013-01\", method=\"nearest\") a_month[\"prec\"].plot()  a_month Out[6]: <pre>&lt;xarray.Dataset&gt; Size: 1MB\nDimensions:  (lat: 400, lon: 700)\nCoordinates:\n  * lat      (lat) float32 2kB 15.05 15.15 15.25 15.35 ... 54.75 54.85 54.95\n  * lon      (lon) float32 3kB 70.05 70.15 70.25 70.35 ... 139.8 139.9 140.0\n    time     datetime64[ns] 8B 2018-01-16T10:30:00\nData variables:\n    prec     (lat, lon) float32 1MB ...\nAttributes:\n    Conventions:  CF-1.0\n    history:      Created at 2016-04-02 14:55:55 UTC by the ITPCAS Data Fusio...\n    source:       ITPCAS Data Fusion System (Version: 01.02.0240)\n    institution:  Institute of Tibetan Plateau Research, Chinese Academy of S...\n    title:        Monthly mean precipitation rate from the ITPCAS China Meteo...\n    description:  Data from ITPCAS China Meteorological Forcing Dataset (Vers...\n    references:   He, J., and K. Yang, 2011: China Meteorological Forcing Dat...</pre>xarray.Dataset<ul><li>Dimensions:<ul><li>lat: 400</li><li>lon: 700</li></ul></li><li>Coordinates: (3)<ul><li>lat(lat)float3215.05 15.15 15.25 ... 54.85 54.95standard_name :latitudelong_name :latitudeunits :degrees_northaxis :Y<pre>array([15.05    , 15.150001, 15.25    , ..., 54.75    , 54.85    , 54.95    ],\n      dtype=float32)</pre></li><li>lon(lon)float3270.05 70.15 70.25 ... 139.9 140.0standard_name :longitudelong_name :longitudeunits :degrees_eastaxis :X<pre>array([ 70.05   ,  70.15   ,  70.25   , ..., 139.75   , 139.85   , 139.95001],\n      dtype=float32)</pre></li><li>time()datetime64[ns]2018-01-16T10:30:00standard_name :timelong_name :Timeaxis :T<pre>array('2018-01-16T10:30:00.000000000', dtype='datetime64[ns]')</pre></li></ul></li><li>Data variables: (1)<ul><li>prec(lat, lon)float32...long_name :Precipitation rateunits :mm hr-1<pre>[280000 values with dtype=float32]</pre></li></ul></li><li>Indexes: (2)<ul><li>latPandasIndex<pre>PandasIndex(Index([15.050000190734863,  15.15000057220459,              15.25,\n       15.350000381469727, 15.449999809265137, 15.550000190734863,\n        15.65000057220459,              15.75, 15.850000381469727,\n       15.949999809265137,\n       ...\n        54.04999923706055, 54.150001525878906,              54.25,\n       54.349998474121094,  54.45000076293945,  54.54999923706055,\n       54.650001525878906,              54.75, 54.849998474121094,\n        54.95000076293945],\n      dtype='float32', name='lat', length=400))</pre></li><li>lonPandasIndex<pre>PandasIndex(Index([ 70.05000305175781,   70.1500015258789,              70.25,\n        70.35000610351562,  70.45000457763672,  70.55000305175781,\n         70.6500015258789,              70.75,  70.85000610351562,\n        70.95000457763672,\n       ...\n        139.0500030517578, 139.14999389648438,             139.25,\n       139.35000610351562, 139.45001220703125,  139.5500030517578,\n       139.64999389648438,             139.75, 139.85000610351562,\n       139.95001220703125],\n      dtype='float32', name='lon', length=700))</pre></li></ul></li><li>Attributes: (7)Conventions :CF-1.0history :Created at 2016-04-02 14:55:55 UTC by the ITPCAS Data Fusion Systemsource :ITPCAS Data Fusion System (Version: 01.02.0240)institution :Institute of Tibetan Plateau Research, Chinese Academy of Sciences, Beijing, Chinatitle :Monthly mean precipitation rate from the ITPCAS China Meteorological Forcing Datasetdescription :Data from ITPCAS China Meteorological Forcing Dataset (Version: 01.06.0014; Category: B-01: 03hr, 0.10deg)references :He, J., and K. Yang, 2011: China Meteorological Forcing Dataset. Cold and Arid Regions Science Data Center, Lanzhou, Gansu, China, digital media, doi:10.3972/westdc.002.2014.db. [Available online at http://westdc.westgis.ac.cn/data/7a35329c-c53f-4267-aa07-e0037d913a21.]</li></ul> <p>When applying the raster data to an existing module, <code>ABSESpy</code> automatically project match it to the current <code>CRS</code>.</p> In\u00a0[7]: Copied! <pre>cropland.apply_raster(a_month, attr_name=\"prec\", cover_crs=True)\ncropland.get_xarray(\"prec\").plot()\n</pre> cropland.apply_raster(a_month, attr_name=\"prec\", cover_crs=True) cropland.get_xarray(\"prec\").plot() Out[7]: <pre>&lt;matplotlib.collections.QuadMesh at 0x7f41a8ac9d10&gt;</pre> <p>The <code>NetCDF</code> dataset has three dims: 'time', 'x'(longitude), and 'y'(latitude).</p> <p>One benefit of using <code>ABSESpy</code> is to update the dataset by real-world time. Below is an example:</p> In\u00a0[8]: Copied! <pre>def update_precipitation(data, time):\n    return data.sel(time=time.dt, method=\"nearest\")\n\n\ncropland.add_dynamic_variable(\n    name=\"prec\",\n    data=data,\n    function=update_precipitation,\n    cover_crs=True,\n)\n</pre> def update_precipitation(data, time):     return data.sel(time=time.dt, method=\"nearest\")   cropland.add_dynamic_variable(     name=\"prec\",     data=data,     function=update_precipitation,     cover_crs=True, ) In\u00a0[9]: Copied! <pre>cropland.dynamic_var(\"prec\", dtype=\"xarray\").plot()\n</pre> cropland.dynamic_var(\"prec\", dtype=\"xarray\").plot() Out[9]: <pre>&lt;matplotlib.collections.QuadMesh at 0x7f41a5e9d550&gt;</pre> <p>In this example, we will create a <code>PatchModule</code> and geo-agents with a <code>shapefile</code> dataset.</p> In\u00a0[10]: Copied! <pre>import geopandas as gpd\n\ndata_path = load_data(\"YR_cities.zip\")\ngdf = gpd.read_file(data_path)\ngdf.head()\n</pre> import geopandas as gpd  data_path = load_data(\"YR_cities.zip\") gdf = gpd.read_file(data_path) gdf.head() Out[10]: City_ID Ratio area Shaoefile_ Perfecture Province_n geometry 0 100 0.546595 3958.281245 128.0 C100 Henan POLYGON ((113.38580 35.47040, 113.39200 35.464... 1 102 0.385113 15258.027194 170.0 C102 Henan POLYGON ((112.03220 35.04700, 112.03260 35.045... 2 106 0.567869 4273.313471 197.0 C106 Henan POLYGON ((115.19540 36.20580, 115.19700 36.203... 3 107 0.389969 9951.746614 215.0 C107 Henan POLYGON ((111.96140 35.07840, 111.96400 35.076... 4 109 0.601268 8279.739196 290.0 C109 Henan POLYGON ((113.67120 35.83740, 113.67660 35.835... In\u00a0[11]: Copied! <pre># Create a new model, and import the above GeoDataFrame as a patch module.\nmodel = MainModel()\nyr_basin = model.nature.create_module(\n    how=\"from_vector\",\n    vector_file=gdf,\n    resolution=0.1,  # 0.1 degree.\n    major_layer=True,\n    name=\"yellow_river\",\n    attr_name=\"area\",\n    apply_raster=True,\n)\nyr_basin.plot.show(\"area\")\n</pre> # Create a new model, and import the above GeoDataFrame as a patch module. model = MainModel() yr_basin = model.nature.create_module(     how=\"from_vector\",     vector_file=gdf,     resolution=0.1,  # 0.1 degree.     major_layer=True,     name=\"yellow_river\",     attr_name=\"area\",     apply_raster=True, ) yr_basin.plot.show(\"area\") <pre>[14:20:13][WARNING][nature] the nature's CRS has been changed to GEOGCS[\"WGS 84\",DATUM[\"WGS_1984\",SPHEROID[\"WGS 84\",6378137,298.257223563,AUTHORITY[\"EPSG\",\"7030\"]],AUTHORITY[\"EPSG\",\"6326\"]],PRIMEM[\"Greenwich\",0,AUTHORITY[\"EPSG\",\"8901\"]],UNIT[\"degree\",0.0174532925199433,AUTHORITY[\"EPSG\",\"9122\"]],AXIS[\"Latitude\",NORTH],AXIS[\"Longitude\",EAST],AUTHORITY[\"EPSG\",\"4326\"]].\n</pre> <pre>/home/runner/work/ABSESpy/ABSESpy/abses/nature.py:170: UserWarning: Converting PatchModule from crs EPSG:4326 to the crs of BaseNature - EPSG:4326. Please check your crs settings if this is unintended, or set `GeoSpace.warn_crs_conversion` to `False` to suppress this warning message.\n  self.add_layer(module)\n/home/runner/work/ABSESpy/ABSESpy/abses/viz/viz_nature.py:56: UserWarning: No artists with labels found to put in legend.  Note that artists whose label start with an underscore are ignored when legend() is called with no argument.\n  ax.legend(**legend_kwargs)\n</pre> Out[11]: <pre>&lt;Axes: title={'center': 'spatial_ref = 0'}, xlabel='x', ylabel='y'&gt;</pre> In\u00a0[12]: Copied! <pre>def update_precipitation(data, time):\n    return data.sel(time=time.dt, method=\"nearest\")\n\n\nyr_basin.add_dynamic_variable(\n    name=\"prec\",\n    data=data,\n    function=update_precipitation,\n    cover_crs=True,\n)\n</pre> def update_precipitation(data, time):     return data.sel(time=time.dt, method=\"nearest\")   yr_basin.add_dynamic_variable(     name=\"prec\",     data=data,     function=update_precipitation,     cover_crs=True, ) In\u00a0[13]: Copied! <pre>from abses import Actor\n\n\nclass County(Actor):\n    \"\"\"City in the Yellow River Basin.\"\"\"\n\n    marker = \"^\"\n    color = \"#FFFF80\"\n\n\nmodel.agents.new_from_gdf(\n    gdf,\n    unique_id=\"City_ID\",\n    attrs=[\"area\", \"Province_n\"],\n)\nyr_basin.random.new(County, size=50)\n</pre> from abses import Actor   class County(Actor):     \"\"\"City in the Yellow River Basin.\"\"\"      marker = \"^\"     color = \"#FFFF80\"   model.agents.new_from_gdf(     gdf,     unique_id=\"City_ID\",     attrs=[\"area\", \"Province_n\"], ) yr_basin.random.new(County, size=50) Out[13]: <pre>&lt;ActorsList: (50)County&gt;</pre> In\u00a0[14]: Copied! <pre>yr_basin.plot.show(\"prec\")\n</pre> yr_basin.plot.show(\"prec\") Out[14]: <pre>&lt;Axes: title={'center': 'spatial_ref = 0'}, xlabel='x', ylabel='y'&gt;</pre>"},{"location":"tutorial/advanced/geodata/#setup-nature-modules","title":"Setup Nature Modules\u00b6","text":""},{"location":"tutorial/advanced/geodata/#introduction","title":"Introduction\u00b6","text":""},{"location":"tutorial/advanced/geodata/#working-with-real-data","title":"Working with real data\u00b6","text":""},{"location":"tutorial/advanced/geodata/#dynamic-raster-data","title":"Dynamic raster data\u00b6","text":""},{"location":"tutorial/advanced/geodata/#create-module-from-vector-dataset","title":"Create Module from Vector Dataset\u00b6","text":""},{"location":"tutorial/advanced/viz_model/","title":"Vizualized model","text":"<p><code>ABSESpy</code> provides a basic visualization of the model. The visualization is based on the <code>matplotlib</code>, <code>xarray</code>, <code>geopandas</code>, and <code>networkx</code> library. The visualization is not perfect, but it can help to understand the model structure.</p> In\u00a0[1]: Copied! <pre>import abses\n\nmodel = abses.main.MainModel()\nmodule = model.nature.create_module(how=\"from_resolution\", shape=(20, 30))\n</pre> import abses  model = abses.main.MainModel() module = model.nature.create_module(how=\"from_resolution\", shape=(20, 30)) <pre>[14:20:21][WARNING][nature] the nature's CRS has been changed to epsg:4326.\n</pre> In\u00a0[2]: Copied! <pre>from abses import Actor\n\n\nclass Triangle(Actor):\n    color = \"#FF7F3E\"\n    marker = \"^\"\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.test = self.random.normalvariate(60, 20)\n\n\nclass MyUser(Actor):\n    marker = \"o\"\n    color = \"green\"\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.test = self.random.normalvariate(78, 5)\n\n\nnew_agents = module.random.new(Triangle, size=200, replace=True)\nnew_users = module.random.new(MyUser, size=300, replace=True)\n\nmodel.actors.plot.hist(\"test\")\n</pre> from abses import Actor   class Triangle(Actor):     color = \"#FF7F3E\"     marker = \"^\"      def __init__(self, *args, **kwargs):         super().__init__(*args, **kwargs)         self.test = self.random.normalvariate(60, 20)   class MyUser(Actor):     marker = \"o\"     color = \"green\"      def __init__(self, *args, **kwargs):         super().__init__(*args, **kwargs)         self.test = self.random.normalvariate(78, 5)   new_agents = module.random.new(Triangle, size=200, replace=True) new_users = module.random.new(MyUser, size=300, replace=True)  model.actors.plot.hist(\"test\") Out[2]: <pre>&lt;Axes: xlabel='test', ylabel='Count'&gt;</pre> In\u00a0[3]: Copied! <pre>model.actors.plot.positions(\n    alpha=0.9, sizes=(20, 200), hue=\"breed\", size=\"count\"\n)\n</pre> model.actors.plot.positions(     alpha=0.9, sizes=(20, 200), hue=\"breed\", size=\"count\" ) Out[3]: <pre>&lt;Axes: xlabel='x', ylabel='y'&gt;</pre> <p>In this section, we will visualize the real-world map of the model.</p> In\u00a0[4]: Copied! <pre>from abses import MainModel\nfrom abses import load_data\n\nsc = MainModel()\ncropland = sc.nature.create_module(\n    how=\"from_file\",\n    raster_file=load_data(\"farmland.tif\"),\n    apply_raster=True,\n    name=\"cropland\",\n    attr_name=\"test\",\n)\n\n# adding some Triagle actors and then plotting\nactors = cropland.random.new(Triangle, size=100)\ncropland.plot.show(\"test\")\n</pre> from abses import MainModel from abses import load_data  sc = MainModel() cropland = sc.nature.create_module(     how=\"from_file\",     raster_file=load_data(\"farmland.tif\"),     apply_raster=True,     name=\"cropland\",     attr_name=\"test\", )  # adding some Triagle actors and then plotting actors = cropland.random.new(Triangle, size=100) cropland.plot.show(\"test\") <pre>[14:20:23][WARNING][nature] the nature's CRS has been changed to GEOGCS[\"WGS 84\",DATUM[\"WGS_1984\",SPHEROID[\"WGS 84\",6378137,298.257223563,AUTHORITY[\"EPSG\",\"7030\"]],AUTHORITY[\"EPSG\",\"6326\"]],PRIMEM[\"Greenwich\",0,AUTHORITY[\"EPSG\",\"8901\"]],UNIT[\"degree\",0.0174532925199433,AUTHORITY[\"EPSG\",\"9122\"]],AXIS[\"Latitude\",NORTH],AXIS[\"Longitude\",EAST],AUTHORITY[\"EPSG\",\"4326\"]].\n</pre> <pre>/home/runner/work/ABSESpy/ABSESpy/abses/nature.py:170: UserWarning: Converting PatchModule from crs EPSG:4326 to the crs of BaseNature - EPSG:4326. Please check your crs settings if this is unintended, or set `GeoSpace.warn_crs_conversion` to `False` to suppress this warning message.\n  self.add_layer(module)\n</pre> Out[4]: <pre>&lt;Axes: title={'center': 'spatial_ref = 0'}, xlabel='x', ylabel='y'&gt;</pre> <p><code>ABSESpy</code> allows user to create Geo- Agents from GeoDataFrame object.</p> In\u00a0[5]: Copied! <pre>from abses import load_data\nimport geopandas as gpd\n\ndata = gpd.read_file(load_data(\"YR_cities.zip\"))\ndata.head()\n</pre> from abses import load_data import geopandas as gpd  data = gpd.read_file(load_data(\"YR_cities.zip\")) data.head() Out[5]: City_ID Ratio area Shaoefile_ Perfecture Province_n geometry 0 100 0.546595 3958.281245 128.0 C100 Henan POLYGON ((113.38580 35.47040, 113.39200 35.464... 1 102 0.385113 15258.027194 170.0 C102 Henan POLYGON ((112.03220 35.04700, 112.03260 35.045... 2 106 0.567869 4273.313471 197.0 C106 Henan POLYGON ((115.19540 36.20580, 115.19700 36.203... 3 107 0.389969 9951.746614 215.0 C107 Henan POLYGON ((111.96140 35.07840, 111.96400 35.076... 4 109 0.601268 8279.739196 290.0 C109 Henan POLYGON ((113.67120 35.83740, 113.67660 35.835... In\u00a0[6]: Copied! <pre>model2 = MainModel()\ncities = model2.agents.new_from_gdf(\n    data, unique_id=\"City_ID\", attrs={\"area\": \"area\", \"Province_n\": \"province\"}\n)\ncities\n</pre> model2 = MainModel() cities = model2.agents.new_from_gdf(     data, unique_id=\"City_ID\", attrs={\"area\": \"area\", \"Province_n\": \"province\"} ) cities Out[6]: <pre>&lt;ActorsList: (59)Actor&gt;</pre> In\u00a0[7]: Copied! <pre>cities.plot.display(boundary=True)\n</pre> cities.plot.display(boundary=True) Out[7]: <pre>&lt;Axes: &gt;</pre>"},{"location":"tutorial/advanced/viz_model/#vizualized-model","title":"Vizualized model\u00b6","text":""},{"location":"tutorial/advanced/viz_model/#grid-world","title":"Grid world\u00b6","text":""},{"location":"tutorial/advanced/viz_model/#real-world-map","title":"Real-world map\u00b6","text":""},{"location":"tutorial/advanced/viz_model/#shapefile-dataset","title":"Shapefile Dataset\u00b6","text":""},{"location":"tutorial/beginner/actors/","title":"Actors' operation","text":"<p>In progress</p> <p>This document is a work in progress if you see any errors, or exclusions or have any problems, please get in touch with us.</p> In\u00a0[1]: Copied! <pre>from abses import Actor, MainModel\n\n# create a testing model\nmodel = MainModel(name=\"actor_example\", base=\"tests\")\nlayer = model.nature.create_module(how=\"from_resolution\", shape=(3, 3))\n\n# actor creation should be bounded with a model.\nactor = model.agents.new(Actor, singleton=True)\n\n# actor has a class-property, -its breed, class's name.\nactor.breed  # same as `actor.__class__.__name__`\n</pre> from abses import Actor, MainModel  # create a testing model model = MainModel(name=\"actor_example\", base=\"tests\") layer = model.nature.create_module(how=\"from_resolution\", shape=(3, 3))  # actor creation should be bounded with a model. actor = model.agents.new(Actor, singleton=True)  # actor has a class-property, -its breed, class's name. actor.breed  # same as `actor.__class__.__name__` <pre>[14:20:29][WARNING][nature] the nature's CRS has been changed to epsg:4326.\n</pre> Out[1]: <pre>'Actor'</pre> In\u00a0[2]: Copied! <pre># In an initial condition, this actor is not on the earth...\nactor.on_earth\n</pre> # In an initial condition, this actor is not on the earth... actor.on_earth Out[2]: <pre>False</pre> <p>When the model is created, there is a unique <code>AgentsContainer</code> obj bounding. It saves agents by their breeds. In the tutorial above, only one actor is added now.</p> In\u00a0[3]: Copied! <pre>repr(model.agents)\n</pre> repr(model.agents) Out[3]: <pre>'&lt;abses.container._ModelAgentsContainer object at 0x7fa98cb52c90&gt;'</pre> <p>Container makes creating actors much easier:</p> In\u00a0[4]: Copied! <pre># define a new breed of actor\nclass Seller(Actor):\n    name = \"seller\"\n\n\nclass User(Actor):\n    name = \"user\"\n\n\n# You'd better to assign the `singleton=True` when only creating one actor.\n# Otherwise you would get a list of actors (length = 1).\nanother_actor = model.agents.new(Actor, singleton=True)\nseller = model.agents.new(Seller)  # default creating one actor.\nusers = model.agents.new(User, 5)  # creating 5 actors\n\nmodel.agents\n</pre> # define a new breed of actor class Seller(Actor):     name = \"seller\"   class User(Actor):     name = \"user\"   # You'd better to assign the `singleton=True` when only creating one actor. # Otherwise you would get a list of actors (length = 1). another_actor = model.agents.new(Actor, singleton=True) seller = model.agents.new(Seller)  # default creating one actor. users = model.agents.new(User, 5)  # creating 5 actors  model.agents Out[4]: <pre>&lt;abses.container._ModelAgentsContainer at 0x7fa98cb52c90&gt;</pre> <p>While <code>AgentsContainer</code> mainly provides a way to store, most of manipulations for actors are implemented in another data type: <code>ActorsList</code>. <code>AgentsContainer</code> also has many ways to convert existing agents to this data type:</p> In\u00a0[5]: Copied! <pre># select specific breeds.\nmodel.agents.select(agent_type=\"Seller\")\n</pre> # select specific breeds. model.agents.select(agent_type=\"Seller\") Out[5]: <pre>&lt;ActorsList: (1)Seller&gt;</pre> In\u00a0[6]: Copied! <pre>model.agents.select(agent_type=[\"Seller\", \"User\"])\n</pre> model.agents.select(agent_type=[\"Seller\", \"User\"]) Out[6]: <pre>&lt;ActorsList: (2)Actor; (1)Seller; (5)User&gt;</pre> In\u00a0[7]: Copied! <pre>lst = model.agents.select()\nactor = lst[0]  # indexing -&gt; an `Actor`\nfive_actors = lst[:5]  # slice -&gt; another `ActorsList` object\n\nfive_actors  # (2)Actor; (1)Seller; (2)User\n# five_actors contains this actor\nactor in five_actors\n</pre> lst = model.agents.select() actor = lst[0]  # indexing -&gt; an `Actor` five_actors = lst[:5]  # slice -&gt; another `ActorsList` object  five_actors  # (2)Actor; (1)Seller; (2)User # five_actors contains this actor actor in five_actors Out[7]: <pre>True</pre> <p>Convert the list to a dictionary: <code>{breed: ActorsList}</code></p> In\u00a0[8]: Copied! <pre># sort up mixed actors.\nfive_actors.to_dict()\n</pre> # sort up mixed actors. five_actors.to_dict() Out[8]: <pre>{'Actor': &lt;ActorsList: (2)Actor&gt;,\n 'Seller': &lt;ActorsList: (1)Seller&gt;,\n 'User': &lt;ActorsList: (2)User&gt;}</pre> <p>Select by conditions.</p> In\u00a0[9]: Copied! <pre>five_actors.select(selection=\"User\")  # same as .to_dict()['User']\n\n# select the first and the fourth actors\nfive_actors.select(selection=[True, False, False, True, False])\n</pre> five_actors.select(selection=\"User\")  # same as .to_dict()['User']  # select the first and the fourth actors five_actors.select(selection=[True, False, False, True, False]) Out[9]: <pre>&lt;ActorsList: (1)Actor; (1)User&gt;</pre> <p>Actors' attributes are accessible as <code>np.ndarray</code>.</p> In\u00a0[10]: Copied! <pre># get each Actor(object)'s unique id.\nfive_actors.array(\"unique_id\")\n</pre> # get each Actor(object)'s unique id. five_actors.array(\"unique_id\") Out[10]: <pre>array([1, 2, 3, 4, 5])</pre> <p>You can access all actors in this list with <code>id &gt;= 7</code> by:</p> In\u00a0[11]: Copied! <pre>five_actors.update(attr=\"test\", values=[1, 2, 3, 4, 5])\nbetter_guys = five_actors.better(metric=\"test\", than=3)\nbetter_guys\n</pre> five_actors.update(attr=\"test\", values=[1, 2, 3, 4, 5]) better_guys = five_actors.better(metric=\"test\", than=3) better_guys Out[11]: <pre>&lt;ActorsList: (2)User&gt;</pre> <p>Split the list in the second, third places: <code>[1, 2, | 3, | 4, 5]</code></p> In\u00a0[12]: Copied! <pre>five_actors.split([2, 3])\n</pre> five_actors.split([2, 3]) Out[12]: <pre>[&lt;ActorsList: (2)Actor&gt;, &lt;ActorsList: (1)Seller&gt;, &lt;ActorsList: (2)User&gt;]</pre>"},{"location":"tutorial/beginner/actors/#actors-operation","title":"Actors' operation\u00b6","text":""},{"location":"tutorial/beginner/actors/#manipulate-an-individual-actor","title":"Manipulate an individual <code>Actor</code>\u00b6","text":""},{"location":"tutorial/beginner/actors/#manipulate-a-group-of-actors","title":"Manipulate a group of <code>Actors</code>\u00b6","text":"<p><code>ABSESpy</code> provides two different container of actors:</p> <ul> <li><code>AgentsContainer</code>: A unique <code>dictionary</code>-like class where all agents of the model are saving.</li> <li><code>ActorsList</code>: A <code>list</code>-like class where referring some actors temporally.</li> </ul>"},{"location":"tutorial/beginner/actors/#agentscontainer","title":"AgentsContainer\u00b6","text":""},{"location":"tutorial/beginner/actors/#actorslist","title":"<code>ActorsList</code>\u00b6","text":"<p><code>ActorsList</code> is a collection of <code>Actors</code>, facilitate to manipulate them at a batch.</p>"},{"location":"tutorial/beginner/get_started/","title":"Get started in 5 minutes","text":"<p>In progress</p> <p>This document is a work in progress if you see any errors, or exclusions or have any problems, please get in touch with us.</p> <p>Assuming you've successfully installed <code>ABSESpy</code>, along with all its dependencies, and properly configured the environment to import the module into your workspace. Running the first blank model that performs no action is straightforward - simply import, initialize, and run...</p> In\u00a0[1]: Copied! <pre># %pip install abses\n\nfrom abses import MainModel\n</pre> # %pip install abses  from abses import MainModel In\u00a0[2]: Copied! <pre># Initialize a model instance\nmodel = MainModel()\n\n# You can check state of the model by `.summary()`.\nmodel.summary()\n</pre> # Initialize a model instance model = MainModel()  # You can check state of the model by `.summary()`. model.summary() <pre>Using ABSESpy version: v0.7.0\n</pre> Out[2]: <pre>name     MainModel\nstate         init\ntick             0\ndtype: object</pre> In\u00a0[3]: Copied! <pre># run it for 5 steps.\nmodel.run_model(steps=5)\n</pre> # run it for 5 steps. model.run_model(steps=5) <pre>[14:20:33][WARNING][datacollector] No final reporters have been definedreturning empty DataFrame.\n</pre> <p></p> <p>As the name \"socio-ecological system\" suggests, models usually include two basic subsystems (submodules): human and natural. They can be accessed through attributes <code>model.human</code> and <code>model.nature</code>.</p> <p>In the default model <code>MainModel</code> built by <code>ABSESpy</code>, they are <code>BaseNature</code> and <code>BaseHuman</code>.</p> In\u00a0[4]: Copied! <pre>type(model.human)\n</pre> type(model.human) Out[4]: <pre>abses.human.BaseHuman</pre> In\u00a0[5]: Copied! <pre>type(model.nature)\n</pre> type(model.nature) Out[5]: <pre>abses.nature.BaseNature</pre> <p>The default BaseNature and BaseHuman classes can be used to build custom classes that better reflect the needs of a particular application. In order to use a custom module must be passed to the <code>MainModel</code> constructor as keyword arguments <code>human</code> and <code>nature</code>.</p> In\u00a0[6]: Copied! <pre>from abses import BaseNature, BaseHuman\n\n\nclass Nature(BaseNature):\n    \"\"\"A custom Nature module.\"\"\"\n\n    def step(self):\n        print(f\"Nature in the step {self.time.tick}\")\n\n\nclass Human(BaseHuman):\n    \"\"\"A custom Human module.\"\"\"\n\n    def step(self):\n        print(f\"Human in the step  {self.time.tick}\")\n</pre> from abses import BaseNature, BaseHuman   class Nature(BaseNature):     \"\"\"A custom Nature module.\"\"\"      def step(self):         print(f\"Nature in the step {self.time.tick}\")   class Human(BaseHuman):     \"\"\"A custom Human module.\"\"\"      def step(self):         print(f\"Human in the step  {self.time.tick}\") In\u00a0[7]: Copied! <pre>model = MainModel(human_class=Human, nature_class=Nature)\n\nmodel.run_model(steps=3)\n</pre> model = MainModel(human_class=Human, nature_class=Nature)  model.run_model(steps=3) <pre>Nature in the step 1\nHuman in the step  1\nNature in the step 2\nHuman in the step  2\nNature in the step 3\nHuman in the step  3\n</pre> <p>ABSESpy will also log certain messages to allow a better, real-time understanding of the model's progression.</p> In\u00a0[8]: Copied! <pre>from abses import Actor, MainModel\n\n\nclass MyActor(Actor):\n    \"\"\"A customized actor\"\"\"\n\n    def say_hi(self) -&gt; str:\n        print(f\"Hello, world! I'm a new {self.breed}!\")\n\n\nmodel = MainModel()\nactors = model.agents.new(Actor, 5)\nmy_actor = model.agents.new(MyActor, singleton=True)\n\nmy_actor.say_hi()\nprint(model.agents)\n</pre> from abses import Actor, MainModel   class MyActor(Actor):     \"\"\"A customized actor\"\"\"      def say_hi(self) -&gt; str:         print(f\"Hello, world! I'm a new {self.breed}!\")   model = MainModel() actors = model.agents.new(Actor, 5) my_actor = model.agents.new(MyActor, singleton=True)  my_actor.say_hi() print(model.agents) <pre>Hello, world! I'm a new MyActor!\n&lt;Handling [6]Agents for MainModel&gt;\n</pre> In\u00a0[9]: Copied! <pre>from abses import MainModel, Actor\n\n\nclass MyModel(MainModel):\n    \"\"\"Customized model.\"\"\"\n\n    def setup(self):\n        n_agents = self.params.get(\"init_agents\")\n        self.agents.new(Actor, n_agents)\n\n    def step(self):\n        # `p` is a shortcut for `params`\n        n_agents = self.p.get(\"n_agents\")\n        self.agents.new(Actor, n_agents)\n\n    def end(self):\n        n_agents = len(self.agents)\n        print(f\"At step {self.time.tick}, there are {n_agents} actors.\")\n\n\nparameters = {\n    \"time\": {\n        \"start\": \"2000-01-01\",\n        \"end\": \"2003-03-21\",\n        \"months\": 8,\n        \"years\": 2,\n    },\n    \"model\": {\"init_agents\": 5, \"n_agents\": 1},\n}\nmodel = MyModel(parameters=parameters)\nmodel.run_model()\n</pre> from abses import MainModel, Actor   class MyModel(MainModel):     \"\"\"Customized model.\"\"\"      def setup(self):         n_agents = self.params.get(\"init_agents\")         self.agents.new(Actor, n_agents)      def step(self):         # `p` is a shortcut for `params`         n_agents = self.p.get(\"n_agents\")         self.agents.new(Actor, n_agents)      def end(self):         n_agents = len(self.agents)         print(f\"At step {self.time.tick}, there are {n_agents} actors.\")   parameters = {     \"time\": {         \"start\": \"2000-01-01\",         \"end\": \"2003-03-21\",         \"months\": 8,         \"years\": 2,     },     \"model\": {\"init_agents\": 5, \"n_agents\": 1}, } model = MyModel(parameters=parameters) model.run_model() <pre>At step 2, there are 7 actors.\n</pre> In\u00a0[10]: Copied! <pre>model.summary(verbose=True)\n</pre> model.summary(verbose=True) <pre>Using ABSESpy version: v0.7.0\n</pre> Out[10]: <pre>name                            MyModel\nstate                          complete\ntick                                  2\n&lt;class 'abses.actor.Actor'&gt;           7\nmodel_vars                           ()\nagent_vars                           ()\ndtype: object</pre>"},{"location":"tutorial/beginner/get_started/#get-started-in-5-minutes","title":"Get started in 5 minutes\u00b6","text":""},{"location":"tutorial/beginner/get_started/#get-absespy-running","title":"Get <code>ABSESpy</code> running\u00b6","text":""},{"location":"tutorial/beginner/get_started/#absespy-two-basic-modules","title":"ABSESpy two basic modules\u00b6","text":""},{"location":"tutorial/beginner/hotelling_tutorial/","title":"Hotelling Law Model","text":"<p>In progress</p> <p>This document is a work in progress if you see any errors, or exclusions or have any problems, please get in touch with us.</p> <p>For the first time, we are going to use the <code>ABSESpy</code> package to create a model by customizing BOTH the <code>Actor</code> and <code>PatchCell</code> classes</p> <p>The major technics introduced here are including:</p> <ol> <li>link: Linking <code>Actor</code>s and <code>PatchCell</code>s, searching and counting linkages.</li> <li>schedule: Use <code>step()</code> and <code>advance()</code> method to separate decision and action for agents.</li> </ol> <p>We will use the Hotelling Law model as an example. The model is based on the assumption that firms will locate themselves in a way that minimizes the distance to their customers. The model is named after Harold Hotelling, who introduced it in 1929. The counterpart written in NetLogo can be found here.</p> <p>Let's start by sketching some new classes, for grouping the basic functions separately.</p> <ul> <li>The main model class will be a subclass of <code>MainModel</code>, controlling global behaviors as usual.</li> <li>In this case, <code>Actor</code> should be some <code>Shop</code>s, who may adjust its location and price for better revenue (attracted customers and production's price).</li> <li>The <code>PatchCell</code> class simulates customers whose locations decide their preferences to shops.</li> </ul> <pre>from abses import Actor, MainModel, PatchCell\n\n\nclass Customer(PatchCell):\n    \"\"\"\n    Each patch cell represents a customer.\n    Customer prefers to buy from the nearest &amp; cheapest shop.\n    \"\"\"\n\n\nclass Shop(Actor):\n    \"\"\"Shop class, which may adjust location and prices.\"\"\"\n\n\nclass Hotelling(MainModel):\n    \"\"\"Model class for Hotelling's Law.\"\"\"\n</pre> <p>Following the <code>NetLogo</code> implementation, each agent will begin at a random position. It will have a market area or share depending on its price and position. Each cell or patch of the grid is considered a customer with inelastic demand for the product. Each customer will make a choice as to what shop is prefered based on the price and distance to each shop. In the original paper (1929) the distance to the shop introduces transportation costs.</p> <p>We first may wish to work out all the setup: create a grid layer and randomly set shop agents on the layer.</p> <p>Imagine that we have a 10x10 grid where each cell represents a custom. We also placed some shops (based on the <code>num_agents</code> parameter) on the world. We need to calculate the distance between each customer and each shop, and then calculate the preference of each customer to each shop.</p> <p>Therefore, let's add a custom method to the <code>Customer</code> class to calculate the preference of each customer to each shop.</p> In\u00a0[1]: Copied! <pre>import numpy as np\nfrom scipy.spatial.distance import cdist\nfrom abses.patch import PatchCell\n\n\nclass Customer(PatchCell):\n    \"\"\"\n    Each patch cell represents a customer.\n    Customer prefers to buy from the nearest &amp; cheapest shop.\n    \"\"\"\n\n    def find_preference(self):\n        \"\"\"Find the nearest &amp; cheapest shop.\"\"\"\n        self.link.clean()  # clean all existing links\n        stores = self.model.actors\n        # Create a list of all shops\n        prices = stores.array(\"price\")\n        # Create a list of all distances from the customer to each shop\n        distances = cdist(\n            np.array([self.indices]),\n            np.array([shop.at.indices for shop in stores]),\n        )[0]\n        # Pair each shop to its distance &amp; price\n        _pair = dict(zip(stores, distances + prices))\n        prefer_store = min(_pair, key=_pair.get)\n        # let this customer be linked by the nearest &amp; cheapest shop.\n        self.link.by(prefer_store, link_name=\"prefer\")\n        return prefer_store\n</pre> import numpy as np from scipy.spatial.distance import cdist from abses.patch import PatchCell   class Customer(PatchCell):     \"\"\"     Each patch cell represents a customer.     Customer prefers to buy from the nearest &amp; cheapest shop.     \"\"\"      def find_preference(self):         \"\"\"Find the nearest &amp; cheapest shop.\"\"\"         self.link.clean()  # clean all existing links         stores = self.model.actors         # Create a list of all shops         prices = stores.array(\"price\")         # Create a list of all distances from the customer to each shop         distances = cdist(             np.array([self.indices]),             np.array([shop.at.indices for shop in stores]),         )[0]         # Pair each shop to its distance &amp; price         _pair = dict(zip(stores, distances + prices))         prefer_store = min(_pair, key=_pair.get)         # let this customer be linked by the nearest &amp; cheapest shop.         self.link.by(prefer_store, link_name=\"prefer\")         return prefer_store <p>Distance is calculated using the Euclidean distance formula. The preference of each customer to each shop is calculated using the formula $prefer = price + distance$:</p> <p>In the above implementation, we use <code>scipy.spatial.distance</code> module to calculate the distance between each customer and each shop. We also use the <code>numpy</code> module to calculate the preference of each customer to each shop.</p> <p>In progress</p> <p>Calculating distance between cell and actors is not an internal method at the moment, but we are considering becoming the default feature of ABSESpy in the future.</p> <p>For flexibility, we also need another custom method to the <code>MainModel</code> to refresh the preferences globally:</p> In\u00a0[2]: Copied! <pre>from abses import MainModel\n\n\nclass Hotelling(MainModel):\n    \"\"\"\n    Model class for the Hotelling's Law example.\n    \"\"\"\n\n    def setup(self):\n        num_agents = self.params.get(\"n_agents\", 3)\n        # Initialize a grid\n        layer = self.nature.create_module(\n            cell_cls=Customer, how=\"from_resolution\", shape=(10, 10)\n        )\n\n        # Create some agents on random cells\n        shops = self.agents.new(Shop, num_agents)\n        shops.apply(lambda shop: shop.move.to(\"random\", layer=layer))\n\n    def recalculate_preferences(self):\n        \"\"\"Let all customers (PatchCell) find their preferences shop.\"\"\"\n        self.nature.major_layer.select().trigger(\"find_preference\")\n</pre> from abses import MainModel   class Hotelling(MainModel):     \"\"\"     Model class for the Hotelling's Law example.     \"\"\"      def setup(self):         num_agents = self.params.get(\"n_agents\", 3)         # Initialize a grid         layer = self.nature.create_module(             cell_cls=Customer, how=\"from_resolution\", shape=(10, 10)         )          # Create some agents on random cells         shops = self.agents.new(Shop, num_agents)         shops.apply(lambda shop: shop.move.to(\"random\", layer=layer))      def recalculate_preferences(self):         \"\"\"Let all customers (PatchCell) find their preferences shop.\"\"\"         self.nature.major_layer.select().trigger(\"find_preference\") <p>Now, what we've done?</p> <p>We have customers located on different cells of the grid, and initialized some shops. We have calculated the distance between each customer and each shop, and then calculated the preference of each customer to each shop. Finally, we also added a custom method to the <code>MainModel</code> to refresh the preferences globally.</p> <p>Notice that we used <code>link.by()</code> method to link each customer to the shop it prefers. <code>link</code> is a powerful function of <code>ABSESpy</code> to link two agents, cells, or agent and cell. Users can customize the linkages' name by specifying <code>link_name</code> parameter. In this case, we use <code>prefer</code> as the linkage name. Once we've created the links, we can easily access the linked cells from the shops' side, including counting the number of customers who prefer each shop. Let's add a custom method to the <code>Shop</code> class to count the number of customers who prefer each shop to test it.</p> <p>We are prepared to implement the full <code>Shop</code> class now.</p> <p>Besides the <code>area_count</code> property, we are going to take <code>setup</code> method to give our Shop agent the following parameters:</p> attribute description price Shop's current price next_position Position to advance to at the end of this period next_price Price to set at the end of this period <p>The next position and next price are the variables that will be used to store the agent's choices on position and price momentarily and that will take effect at the end of the period. By separating the decision and action in a schedule, we can simulate the shops' decision are made simultaneously.</p> <p>We will want to be able to calculate respective monopoly areas for each shop. Since no single agent can really set this variable for himself, this method must be implement within the scope of the Hotelling model class scope. Essentially, it will iterate through each path or cell and it will define what would be the preferred shop for a customer that sits on that cell. The area for any given Shop is the number of customer that prefer that shop.</p> <p>We are going to need a function to calculate the distance between any two points in the grid. We will use the euclidean distance. We proceed to take this distance as the nominal value of the transportation costs, assuming each unit of distance equates one unit of money.</p> <p>This distance plus the price will define the total costs that a customer incurs when buying from a given shop.</p> <p>The preferred shop will be the cheapest one. That is, the one for which the customer faces less costs for both the product itself and transportation. The method will return a dictionary with the number of customers that prefer each shop.</p> In\u00a0[3]: Copied! <pre>from abses import Actor\n\n\nclass Shop(Actor):\n    \"\"\"\n    Shop agent\n    \"\"\"\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.price = 10\n        self.next_position = None\n        self.next_price = None\n\n    @property\n    def area_count(self) -&gt; int:\n        \"\"\"Return the number of customers in the shop's area.\"\"\"\n        return len(self.link.get(\"prefer\", direction=\"out\"))\n\n    def step(self):\n        self.adjust_price()\n        self.adjust_position()\n\n    def advance(self):\n        self.affect_price()\n        self.affect_position()\n\n    def adjust_price(self):\n        \"\"\"Evaluate the potential revenue for each possible price change.\n        Choose the one with the highest potential revenue.\"\"\"\n        # Save initial price\n        init_price = self.price\n\n        # Build a list of all possible prices\n        _possible_prices = [init_price - 1, init_price, init_price + 1]\n\n        # Pair each possible price change to its potential revenue\n        _potential_revenues = {}\n        for price in _possible_prices:\n            self.price = price\n            self.model.recalculate_preferences()\n            _potential_revenues[price] = self.area_count * price\n        # Check if all potential revenues are 0\n        # if so, decrease price by 1\n        if all(value == 0 for value in _potential_revenues.values()):\n            self.next_price = self.price - 1\n        # Otherwise, choose the price with the highest potential revenue\n        else:\n            self.next_price = max(_potential_revenues, key=_potential_revenues.get)\n\n        # Reset price to initial price\n        self.price = init_price\n\n    def adjust_position(self):\n        \"\"\"Evaluate the potential areas for each possible move.\n        Choose the one with the highest potential area.\"\"\"\n        cell_now = self.at\n        # Get all possible candidates for the next position\n        _possible_moves = self.at.neighboring(moore=True, include_center=False)\n\n        # Pair each possible move to their potential areas\n        _potential_areas = {}\n        for move in _possible_moves:\n            self.move.to(move)\n            self.model.recalculate_preferences()\n            _potential_areas[move] = self.area_count\n\n        # Single out the store with the highest potential area and save it\n        _choice = max(_potential_areas, key=_potential_areas.get)\n        self.next_position = _choice\n\n        # Pull back to initial position if the potential area\n        self.move.to(cell_now)\n\n    def affect_price(self) -&gt; None:\n        \"\"\"Change the price of the shop to the next price.\"\"\"\n        self.price = self.next_price\n\n    def affect_position(self) -&gt; None:\n        \"\"\"Change the position of the shop to the next position.\"\"\"\n        self.move.to(self.next_position)\n</pre> from abses import Actor   class Shop(Actor):     \"\"\"     Shop agent     \"\"\"      def __init__(self, *args, **kwargs):         super().__init__(*args, **kwargs)         self.price = 10         self.next_position = None         self.next_price = None      @property     def area_count(self) -&gt; int:         \"\"\"Return the number of customers in the shop's area.\"\"\"         return len(self.link.get(\"prefer\", direction=\"out\"))      def step(self):         self.adjust_price()         self.adjust_position()      def advance(self):         self.affect_price()         self.affect_position()      def adjust_price(self):         \"\"\"Evaluate the potential revenue for each possible price change.         Choose the one with the highest potential revenue.\"\"\"         # Save initial price         init_price = self.price          # Build a list of all possible prices         _possible_prices = [init_price - 1, init_price, init_price + 1]          # Pair each possible price change to its potential revenue         _potential_revenues = {}         for price in _possible_prices:             self.price = price             self.model.recalculate_preferences()             _potential_revenues[price] = self.area_count * price         # Check if all potential revenues are 0         # if so, decrease price by 1         if all(value == 0 for value in _potential_revenues.values()):             self.next_price = self.price - 1         # Otherwise, choose the price with the highest potential revenue         else:             self.next_price = max(_potential_revenues, key=_potential_revenues.get)          # Reset price to initial price         self.price = init_price      def adjust_position(self):         \"\"\"Evaluate the potential areas for each possible move.         Choose the one with the highest potential area.\"\"\"         cell_now = self.at         # Get all possible candidates for the next position         _possible_moves = self.at.neighboring(moore=True, include_center=False)          # Pair each possible move to their potential areas         _potential_areas = {}         for move in _possible_moves:             self.move.to(move)             self.model.recalculate_preferences()             _potential_areas[move] = self.area_count          # Single out the store with the highest potential area and save it         _choice = max(_potential_areas, key=_potential_areas.get)         self.next_position = _choice          # Pull back to initial position if the potential area         self.move.to(cell_now)      def affect_price(self) -&gt; None:         \"\"\"Change the price of the shop to the next price.\"\"\"         self.price = self.next_price      def affect_position(self) -&gt; None:         \"\"\"Change the position of the shop to the next position.\"\"\"         self.move.to(self.next_position) <p>The above implementation is a bit complicated but don't be daunted. We use the <code>step()</code> method to make decisions and the <code>advance()</code> method to take actions. When making decision, each shop consider all the potential movements and prices, and choose the one that maximizes its revenue. Then, it sets the next position and next price. When taking action, each shop moves to the next position and sets the next price.</p> <p>The price adjustme schedule are part of the <code>Shop</code> class in the Hotelling model. There are two methods that relate to this procedure, namely, <code>adjust_price</code> and <code>adjust_position</code>. Here's a detailed description of how it works:</p> <ol> <li><p>adjust_price: This method is responsible for determining the next price for the shop based on potential revenues.</p> <ul> <li><p>It first saves the current price of the shop in <code>initial_price</code>.</p> </li> <li><p>It then creates a list of possible prices, which are the current price minus 1, the current price, and the current price plus 1.</p> </li> <li><p>For each possible price, it temporarily sets the shop's price to that value and calculates the potential revenue if the shop were to sell at that price. The potential revenue is calculated as the product of the price and the area of the shop's monopoly, which is obtained by calling the <code>recalculate_areas</code> method of the model.</p> </li> <li><p>If all potential revenues are 0, it sets <code>next_price</code> to be the current price minus 1. This means that if the shop cannot make any revenue at any of the possible prices, it will lower its price in the next step.</p> </li> <li><p>If there is at least one possible price that can generate revenue, it sets <code>next_price</code> to be the one that generates the highest potential revenue.</p> </li> <li><p>Finally, it resets the shop's price to the initial price. This is because the actual price change does not occur in the <code>adjust_price</code> method. Instead, the new price is stored in <code>next_price</code> and the price change is applied in the <code>affect_price</code> method.</p> </li> </ul> </li> <li><p>affect_price: This method is responsible for applying the price change that was determined in the <code>adjust_price</code> method.</p> <ul> <li>It simply sets the shop's price to <code>next_price</code>. This is the new price that was determined in the <code>adjust_price</code> method.</li> </ul> </li> </ol> <p>The <code>adjust_price</code> and <code>affect_price</code> methods are called in the <code>step</code> and <code>advance</code> methods of the <code>Shop</code> class, respectively. This allows all shops to make their decisions based on the current state of the model in the <code>step</code> method, and then all decisions are applied simultaneously in the <code>advance</code> method.</p> <p>Next we write the methods relating to the position adjustment schedule. Here's a detailed description of how they work:</p> <ol> <li><p>adjust_position: This method is responsible for determining the next position for the shop based on potential areas.</p> <ul> <li><p>It first saves the current position of the shop in <code>initial_pos</code>.</p> </li> <li><p>It then gets a list of all possible moves the shop can make. This is done by calling the <code>get_neighborhood</code> method of the <code>major_layer</code> attribute of the model, which returns the neighboring cells of the shop's current position. The <code>major_layer</code> is a BaseNature instance that represent one grid of the model.</p> </li> <li><p>For each possible move, it temporarily moves the shop to that position and calculates the potential area of the shop's monopoly if it were to move to that position. The potential area is calculated by calling the <code>recalculate_areas</code> method of the model.</p> </li> <li><p>It then selects the move that results in the largest potential area and stores it in <code>next_position</code>.</p> </li> <li><p>Finally, it moves the shop back to its initial position. This is because the actual move does not occur in the <code>adjust_position</code> method. Instead, the new position is stored in <code>next_position</code> and the move is applied in the <code>affect_position</code> method.</p> </li> </ul> </li> <li><p>affect_position: This method is responsible for applying the move that was determined in the <code>adjust_position</code> method.</p> <ul> <li>It simply moves the shop to <code>next_position</code>. This is the new position that was determined in the <code>adjust_position</code> method.</li> </ul> </li> </ol> <p>The <code>adjust_position</code> and <code>affect_position</code> methods are called in the <code>step</code> and <code>advance</code> methods of the <code>Shop</code> class, respectively. This allows all shops to make their decisions based on the current state of the model in the <code>step</code> method, and then all decisions are applied simultaneously in the <code>advance</code> method.</p> <p>From the previous implementation of the Hotelling model class, we already have cues as to what we should aim for and tackle. We know there must be a step and an advance method. We also know that the agent must make a decision regarding price and position based on the number of customer that prefer buying from them, thus, increasing profits and staying in business. Therefore, we will design the Shop agent class in a way that reflect this. There will be the two methods already mentioned and for each there will be two routines.</p> <p>First, the <code>step</code> method will be called for all agents. In it, there will be two routines regarding the changes in prices and positions respectively. At each step, each agent is going to adjust its price and position, but those changes will only take effect at a later stage. The reason for this is that we want to make sure that all agents have made their decisions before any of them takes effect. This may also be referred to as a synchronous or simultaneous update. In order to do that, we want to save the changes in a variable that will be used to update the agent's attributes at the end of the step. This is the reason behing having the <code>next_price</code> and <code>next_position</code> attributes.</p> <p>Taken together, to make the implementation, we have to change the main model a little bit more:</p> In\u00a0[4]: Copied! <pre>class Hotelling(MainModel):  # noqa: F811\n    \"\"\"\n    Model class for the Hotelling's Law example.\n    \"\"\"\n\n    def setup(self):\n        # intact the previous setup method\n        num_agents = self.params.get(\"n_agents\", 3)\n        # Initialize a grid\n        layer = self.nature.create_module(\n            cell_cls=Customer, how=\"from_resolution\", shape=(10, 10)\n        )\n\n        # Create some agents on random cells\n        shops = self.agents.new(Shop, num_agents)\n        shops.apply(lambda shop: shop.move.to(\"random\", layer=layer))\n\n    def step(self):\n        # recalculate areas and assign them to each agent\n        self.recalculate_preferences()\n\n    def recalculate_preferences(self):\n        \"\"\"Let all customers (PatchCell) find their preferences shop.\"\"\"\n        self.nature.major_layer.select().trigger(\"find_preference\")\n</pre> class Hotelling(MainModel):  # noqa: F811     \"\"\"     Model class for the Hotelling's Law example.     \"\"\"      def setup(self):         # intact the previous setup method         num_agents = self.params.get(\"n_agents\", 3)         # Initialize a grid         layer = self.nature.create_module(             cell_cls=Customer, how=\"from_resolution\", shape=(10, 10)         )          # Create some agents on random cells         shops = self.agents.new(Shop, num_agents)         shops.apply(lambda shop: shop.move.to(\"random\", layer=layer))      def step(self):         # recalculate areas and assign them to each agent         self.recalculate_preferences()      def recalculate_preferences(self):         \"\"\"Let all customers (PatchCell) find their preferences shop.\"\"\"         self.nature.major_layer.select().trigger(\"find_preference\") <p>Super easy, right? We only added two lines:</p> <pre># change the schedule to SimultaneousActivation\nself.schedule = SimultaneousActivation(self)\n</pre> <p>It means, we are going to use the <code>SimultaneousActivation</code> scheduler to make sure all agents make their decisions before any of them takes effect.</p> <p>By default, the model takes three actions in each time tick:</p> <ol> <li>Trigger each <code>step</code> in model, nature, and human in order.</li> <li>Trigger each <code>step</code> for agents.</li> <li>Collecting data.</li> </ol> <p>When we use <code>SimultaneousActivation</code> scheduler, the second action will be changed to:</p> <ol> <li>Trigger each <code>step</code>, and then <code>advance</code> for agents.</li> </ol> <p>It allows us to separate decision and action for agents. Shops make decision about their movements and prices in <code>step</code> method, and then take action in <code>advance</code> method simultaneously.</p> <p>Now, each shop can count the number of customers who prefer it by access the property <code>area_count</code>. We simply add a fixed price for each shop so that customers can calculate their preferences.</p> <p>Let's initialize a model, setup it, and calculate the preferences of each customer to each shop. Then, we can count the number of customers who prefer each shop.</p> In\u00a0[5]: Copied! <pre>model = Hotelling()\nmodel.setup()\nmodel.recalculate_preferences()\n\nassert sum(model.actors.array(\"area_count\")) == 100\nmodel.actors.array(\"area_count\")\n</pre> model = Hotelling() model.setup() model.recalculate_preferences()  assert sum(model.actors.array(\"area_count\")) == 100 model.actors.array(\"area_count\") <pre>[14:20:37][WARNING][nature] the nature's CRS has been changed to epsg:4326.\n</pre> Out[5]: <pre>array([35, 38, 27])</pre> <p>Sum of the three number should be 100, which means each cell on the grid ($10 * 10$ by default) has been linked to the shop it prefers.</p> In\u00a0[6]: Copied! <pre>params = {\n    \"reports\": {\n        \"agents\": {\n            \"Shop\": {  # \u8fd9\u91cc\u6307\u5b9a\u4e86 agent \u7c7b\u578b\u4e3a \"Shop\"\n                \"area\": \"area_count\",\n                \"price\": \"price\",\n            }\n        }\n    },\n    \"time\": {\"end\": 20},\n    \"model\": {\"n_agents\": 2},\n}\n\nmodel = Hotelling(parameters=params)\nmodel.run_model()\n</pre> params = {     \"reports\": {         \"agents\": {             \"Shop\": {  # \u8fd9\u91cc\u6307\u5b9a\u4e86 agent \u7c7b\u578b\u4e3a \"Shop\"                 \"area\": \"area_count\",                 \"price\": \"price\",             }         }     },     \"time\": {\"end\": 20},     \"model\": {\"n_agents\": 2}, }  model = Hotelling(parameters=params) model.run_model() <pre>[14:20:37][WARNING][nature] the nature's CRS has been changed to epsg:4326.\n</pre> <pre>[14:20:37][WARNING][datacollector] No final reporters have been definedreturning empty DataFrame.\n</pre> <p>Once we have a full working and testable version of our model, we instantiate it and run it. The following code block shows how to do this:</p> <ol> <li><p>Define the Parameters</p> <p>The <code>parameters</code> dictionary is defining the parameters for the simulation. In this case, there's only one parameter: <code>end</code>. This parameter is nested under <code>time</code> and is set to <code>20</code>. This means the simulation will run for 100 time steps.</p> </li> <li><p>Instantiate the Model</p> <p>The <code>Hotelling</code> model is being instantiated with <code>n_agents=2</code> and <code>parameters=parameters</code>. This means that the model will start with 2 agents (as specified by <code>N=2</code>) and will use the parameters defined in the <code>parameters</code> dictionary.</p> </li> <li><p>Run the Model</p> <p>The <code>run_model</code> method is called on the <code>model</code> instance. This starts the simulation and runs it until the end time specified in the parameters (in this case, 100 time steps).</p> </li> </ol> <p>The <code>Hotelling</code> model is a type of agent-based model used in economics to simulate competition between two firms (or agents) in a geographical market. The <code>n_agents=2</code> parameter suggests that there are two firms in the simulation. The firms adjust their prices and locations in each time step based on the state of the market, and the simulation tracks these adjustments over time.</p> <p>We now have a working model. The <code>datacollector</code> attribute allows to access data collected during the execution of the model. We mainly want to observe the evolution of key variables that describe model's state. For this example, we want to observe the price of each shop at each time step. We also want to observe the number of customers that prefer each shop at each time step. The following code block shows how to do this:</p> <p>As the Hotelling's Law model would predict, the two shops converge to a lower and similar price. This contributes to our understading of how competitions occurs between firms in a market for two substitute goods. The model can be further developed to include more shops, more dimensions, and more complex decision making processes.</p> <p>We may proceed to add three more shops to our model and evaluate the differences.</p> <p>After extending the model to inlcude 5 shops, we can appretiate how some shops are now able to hold higher prices for longer periods after well advanced time periods. Hotelling (1929) considered that all shops or sellers are a monopoly within the confines of a smaller jurisdiction or area. It is appearently the case that more shops allow for less localised competition and, thus, higher prices in certain areas.</p> <p>We can also explore those relative positions in our grid, the areas of each shop and respective revenues. This example only aims to provide a quick illustration of how to use the ABSESpy package.</p>"},{"location":"tutorial/beginner/hotelling_tutorial/#hotelling-law-model","title":"Hotelling Law Model\u00b6","text":""},{"location":"tutorial/beginner/hotelling_tutorial/#link-customers-with-their-prefer-shop","title":"Link customers with their prefer shop\u00b6","text":""},{"location":"tutorial/beginner/hotelling_tutorial/#schedule-shops-decision-and-action","title":"Schedule shop's decision and action\u00b6","text":""},{"location":"tutorial/beginner/hotelling_tutorial/#data-visualization","title":"Data Visualization\u00b6","text":""},{"location":"tutorial/beginner/hotelling_tutorial/#references","title":"References\u00b6","text":"<p>Hotelling, H. (1929). Stability in competition. The Economic Journal, 39(153), 41-57.</p>"},{"location":"tutorial/beginner/manage_parameters/","title":"Manage parameters","text":"<p>In progress</p> <p>This document is a work in progress if you see any errors, or exclusions or have any problems, please get in touch with us.</p> <p><code>ABSESpy</code> uses <code>hydra-core</code> to manage parameters. <code>hydra-core</code> is a framework for elegantly configuring complex applications. It is installed if you have installed <code>ABSESpy</code> using <code>pip</code>.</p> <p>For the best practice, start with a <code>.yaml</code>, like this:</p> <pre>time:\n    end: 3\nreports:\n    model:\n        var1: 'test'\n        var2: var2\n    agents:\n        Actor:\n            var1: 'test'\n\n        Farmer:\n            var2: 'test'\n    final:\n        var1: 'test'\n</pre> <p>We will dive into the <code>.yaml</code> configurations step by step. First of all, we need to load and parse the configs into a Python object, -specifically, a <code>OmegaConf</code> object.</p> <p>In an interactive environment like Jupyter Notebook, you can use the following code to load the <code>.yaml</code> file:</p> In\u00a0[1]: Copied! <pre>from hydra import compose, initialize\n\n# \u52a0\u8f7d\u9879\u76ee\u5c42\u9762\u7684\u914d\u7f6e\nwith initialize(\n    version_base=None, config_path=\"../../../tests/config\"\n):  # replace with your config path\n    cfg = compose(config_name=\"test_config\")\n\ntype(cfg)\n</pre> from hydra import compose, initialize  # \u52a0\u8f7d\u9879\u76ee\u5c42\u9762\u7684\u914d\u7f6e with initialize(     version_base=None, config_path=\"../../../tests/config\" ):  # replace with your config path     cfg = compose(config_name=\"test_config\")  type(cfg) Out[1]: <pre>omegaconf.dictconfig.DictConfig</pre> <p>In a Python script, this snippet from <code>hydra-core</code>'s documentation would be useful:</p> <pre>import hydra\nfrom omegaconf import DictConfig, OmegaConf\n\n@hydra.main(version_base=None, config_path=\"conf\", config_name=\"config\")\ndef my_app(cfg : DictConfig) -&gt; None:\n    print(OmegaConf.to_yaml(cfg))\n\nif __name__ == \"__main__\":\n    my_app()\n</pre> <p>Let's print the configurations out.</p> In\u00a0[2]: Copied! <pre>from pprint import pprint\n\npprint(cfg)\ncfg.time\n</pre> from pprint import pprint  pprint(cfg) cfg.time <pre>{'time': {'end': 3}, 'reports': {'model': {'var1': 'test', 'var2': 'var2'}, 'agents': {'Actor': {'var1': 'test'}, 'Farmer': {'var2': 'test'}}, 'final': {'var1': 'test'}}, 'param1': 0, 'param2': 'c'}\n</pre> Out[2]: <pre>{'end': 3}</pre> <p>Basically, it's just like a nested dictionary, but you can access the configuration attributes simply by <code>.xxx</code>. Such configurations can be passed to a model build by <code>ABSESpy</code> directly:</p> In\u00a0[3]: Copied! <pre>from abses import MainModel\n\nmodel = MainModel(parameters=cfg)\nmodel.test = 3\n\n# then, the configuration is available in model.settings\nmodel.settings\n</pre> from abses import MainModel  model = MainModel(parameters=cfg) model.test = 3  # then, the configuration is available in model.settings model.settings Out[3]: <pre>{'time': {'end': 3}, 'reports': {'model': {'var1': 'test', 'var2': 'var2'}, 'agents': {'Actor': {'var1': 'test'}, 'Farmer': {'var2': 'test'}}, 'final': {'var1': 'test'}}, 'param1': 0, 'param2': 'c'}</pre> <p>Now, what's the meaning of <code>time</code> and <code>reports</code>?</p> <p>'time' module configures the time settings. When assigned <code>end = 3</code> in time module, it means the simulation will end at the 3rd time step.</p> <p>By default, a running model won't stop unless some configuration tells it. Let's try it out:</p> In\u00a0[4]: Copied! <pre>model.run_model()\nmodel.time\n</pre> model.run_model() model.time Out[4]: <pre>&lt;TimeDriver: tick[3]&gt;</pre> <p>Ok! It works. That's the basic settings of the <code>time</code> module.</p> <p>However, the <code>reports</code> module is a bit more complicated. It has two submodules, <code>model</code> and <code>agents</code>.</p> <p>Remember we assigned an attribute <code>model.test = 3</code> after initialize it. Why?</p> <p>The <code>reports</code> config module is used to configure the model's data collector, which is inherited from the mesa framework. This module is used to collect data from the model at each time step. The <code>model</code> submodule is used to collect data from the model, and the <code>agents</code> submodule is used to collect data from the agents.</p> <p>Talk is cheap, let's see what happened:</p> In\u00a0[5]: Copied! <pre>model.datacollector.get_model_vars_dataframe()\n</pre> model.datacollector.get_model_vars_dataframe() Out[5]: var1 var2 0 3 None 1 3 None 2 3 None <p>It's a bit tricky. The <code>var1</code> and <code>var2</code> are the names of the reports. They were converted into columns' name. Why they are 6 and 3?</p> <p>Notice that the <code>var2</code> was just referring to the <code>test</code> attribute of the model, and the <code>var1</code> was a lambda function. The lambda function takes the model as the input and returns the value of the report. The <code>ABSESpy</code> will evaluate the lambda function at the end of each time step.</p> <p>That means:</p> <p>var2 -&gt; attribute 'test' -&gt; 3</p> <p>var1 -&gt; \":lambda m: m.test * 2\" -&gt; parsed as a function, and the result is 6</p> <p>Tips</p> <p>\":\" before the keyword `lambda` denotes this is an lambda function rather than attribute string..</p> <p>Super useful! You can collect any data from the model and agents by configuring the <code>reports</code> module. You know, complex configurations of an agent-based model is a piece of cake with <code>ABSESpy</code>! Guess what result we would get from the <code>agents</code> submodule?</p> <p>Correct! There wasn't any actor before run. Thus, no values were collected. Let's create a new model with adding some agents and see what happens:</p> In\u00a0[6]: Copied! <pre>from abses import Actor\n\nmodel = MainModel(parameters=cfg)\nmodel.test = \"Final result\"\n\nactors = model.agents.new(Actor, num=2)\nactors[0].test = \"testing\"\nactors[1].test = \"Hello World\"\n</pre> from abses import Actor  model = MainModel(parameters=cfg) model.test = \"Final result\"  actors = model.agents.new(Actor, num=2) actors[0].test = \"testing\" actors[1].test = \"Hello World\" In\u00a0[7]: Copied! <pre>model.run_model()\n</pre> model.run_model() In\u00a0[8]: Copied! <pre>model.datacollector.get_agent_vars_dataframe(\"Actor\")\n</pre> model.datacollector.get_agent_vars_dataframe(\"Actor\") Out[8]: AgentID Step Time var1 0 1 1 2025-02-16 14:20:41.714782 testing 1 2 1 2025-02-16 14:20:41.714782 Hello World 0 1 2 2025-02-16 14:20:41.714782 testing 1 2 2 2025-02-16 14:20:41.714782 Hello World 0 1 3 2025-02-16 14:20:41.714782 testing 1 2 3 2025-02-16 14:20:41.714782 Hello World <p>Final result.</p> In\u00a0[9]: Copied! <pre>model.datacollector.get_final_vars_report(model)\n</pre> model.datacollector.get_final_vars_report(model) Out[9]: <pre>{'var1': 'Final result'}</pre> <p>Super handy, aha. Enjoy coding!</p>"},{"location":"tutorial/beginner/manage_parameters/#manage-parameters","title":"Manage parameters\u00b6","text":""},{"location":"tutorial/beginner/movement/","title":"Movement of actors","text":"<p>In progress</p> <p>This document is a work in progress if you see any errors, or exclusions or have any problems, please get in touch with us.</p> In\u00a0[1]: Copied! <pre>from abses import Actor, MainModel\n\n# create a testing model\nmodel = MainModel(name=\"actor_example\", base=\"tests\")\nlayer = model.nature.create_module(how=\"from_resolution\", shape=(3, 3))\nactor = model.agents.new(Actor, singleton=True)\n</pre> from abses import Actor, MainModel  # create a testing model model = MainModel(name=\"actor_example\", base=\"tests\") layer = model.nature.create_module(how=\"from_resolution\", shape=(3, 3)) actor = model.agents.new(Actor, singleton=True) <pre>[14:20:45][WARNING][nature] the nature's CRS has been changed to epsg:4326.\n</pre> In\u00a0[2]: Copied! <pre># however, we can let it settle down on a specific position of the earth.\npos = (1, 1)\nsettled = actor.move.to(to=pos, layer=layer)\n\nactor.pos  # position of the actor now: (4, 4)\nactor.on_earth  # True\n</pre> # however, we can let it settle down on a specific position of the earth. pos = (1, 1) settled = actor.move.to(to=pos, layer=layer)  actor.pos  # position of the actor now: (4, 4) actor.on_earth  # True Out[2]: <pre>True</pre> <p>Let's see where the actor is located at...</p> <p><code>layer.apply</code> is a useful method when you want to apply a function to all the cells in a layer. As all the cells have a method <code>agents.has()</code> to show how many agents are in the cell, we can use this method to count the number of agents in the layer.</p> In\u00a0[3]: Copied! <pre>import matplotlib.pyplot as plt\n\n\ndef show_position():\n    _, ax = plt.subplots(figsize=(2, 2))\n    ax.imshow(layer.apply(lambda c: c.agents.has()))\n    plt.show()\n\n\nshow_position()\n</pre> import matplotlib.pyplot as plt   def show_position():     _, ax = plt.subplots(figsize=(2, 2))     ax.imshow(layer.apply(lambda c: c.agents.has()))     plt.show()   show_position() <p>Now, we can move the actor to a new location.</p> In\u00a0[4]: Copied! <pre>actor.move.by(\"down right\", distance=1)\n\nfig, ax = plt.subplots(figsize=(2, 2))\nax.imshow(layer.apply(lambda c: c.agents.has()))\nplt.show()\n</pre> actor.move.by(\"down right\", distance=1)  fig, ax = plt.subplots(figsize=(2, 2)) ax.imshow(layer.apply(lambda c: c.agents.has())) plt.show() <p>Good movement!</p> <p>Now, let's move the actor to a new location randomly, with a keyword arg <code>radius=2</code>.</p> In\u00a0[5]: Copied! <pre>actor.move.random(radius=2)\n\nfig, ax = plt.subplots(figsize=(2, 2))\nax.imshow(layer.apply(lambda c: c.agents.has()))\nplt.show()\n</pre> actor.move.random(radius=2)  fig, ax = plt.subplots(figsize=(2, 2)) ax.imshow(layer.apply(lambda c: c.agents.has())) plt.show() <p>As you see! The single agent can be moved very easily to a new location.</p>"},{"location":"tutorial/beginner/movement/#movement-of-actors","title":"Movement of actors\u00b6","text":""},{"location":"tutorial/beginner/organize_model_structure/","title":"The Basic Structure of your Model","text":"<p>In progress</p> <p>This document is a work in progress if you see any errors, or exclusions or have any problems, please get in touch with us.</p> <p>ABSESpy is designed to be flexible and modular. It has grown into a package of considerable size and this notebook aims to help you understand the basic structure of a model. Indeed, one of ABSESpy premises is that individual modules should be easily integrated. We call this the loose coupling of multiple modules.</p> <p>For building your own model, three main components are necessary to be included:</p> <ul> <li><code>MainModel</code>: stores several parameters and global variables.</li> <li><code>BaseHuman</code>: This module focuses on the human aspect of SES, offering insights and simulations related to human behavior, decisions, and interactions.</li> <li><code>BaseNature</code>: As the name suggests, this module is all about the natural environments, allowing for simulations and analyses of different ecological components.</li> </ul> In\u00a0[1]: Copied! <pre>from abses import MainModel, BaseNature, BaseHuman\n\n# without including any parameters, you can init a MainModel\ntest1 = MainModel()\n</pre> from abses import MainModel, BaseNature, BaseHuman  # without including any parameters, you can init a MainModel test1 = MainModel() <p>By default, create a <code>MainModel</code> instance without parameters is possible. However, in a practical case, it requires three optional parameters:</p> <ul> <li><code>parameters</code>: All parameters that should be used in the simulation of model.</li> <li><code>nature_class</code>: The base module of the nature subsystem.</li> <li><code>human_class</code>: The base module of the human subsystem.</li> </ul> <p>When create an instance of <code>MainModel</code>, you also create two instances: <code>BaseNature</code> and <code>BaseHuman</code> and store them as <code>nature</code> and <code>human</code> properties of model.</p> In\u00a0[2]: Copied! <pre># We can pass some parameters.\nparameters = {\"time\": {\"start\": \"2000\", \"freq\": \"Y\"}}\n\n# instance `MainModel`\nmodel = MainModel(parameters=parameters)\n\n# All the primary components have a same property `state`.\nprint(model.state)\nprint(model.human.state)\nprint(model.nature.state)\n</pre> # We can pass some parameters. parameters = {\"time\": {\"start\": \"2000\", \"freq\": \"Y\"}}  # instance `MainModel` model = MainModel(parameters=parameters)  # All the primary components have a same property `state`. print(model.state) print(model.human.state) print(model.nature.state) <pre>init\ninit\ninit\n</pre> <p>The property <code>state</code> is accessible in <code>model</code>, <code>human</code>, and <code>nature</code> for showing the current state of simulation. In the above code, all of the states are \"init\", which means just being instanced without any other operation. More information about modeling flow can be accessible in tutorial of modeling flow.</p> <p>When <code>state = 'init'</code>, it means a default function <code>.initialize()</code> of <code>BaseHuman</code> and <code>BaseNature</code> have been called. When designing a custom model, it's a great way to setup some prerequisites, like loading data...</p> In\u00a0[3]: Copied! <pre># Including more parameters.\nparameters_2 = parameters | {\n    \"human\": {\"test_human\": 1},\n    \"nature\": {\"test_nature\": \"I'm a parameter!\"},\n}\n\n\n# subclass of `BaseNature`\nclass Nature(BaseNature):\n    def initialize(self):\n        print(\"Init natural module.\")\n\n\n# subclass of `BaseHuman`\nclass Human(BaseHuman):\n    def initialize(self):\n        print(\"Init human module.\")\n\n\n# creating an instance\nmodel = MainModel(parameters=parameters_2, nature_class=Nature, human_class=Human)\n</pre> # Including more parameters. parameters_2 = parameters | {     \"human\": {\"test_human\": 1},     \"nature\": {\"test_nature\": \"I'm a parameter!\"}, }   # subclass of `BaseNature` class Nature(BaseNature):     def initialize(self):         print(\"Init natural module.\")   # subclass of `BaseHuman` class Human(BaseHuman):     def initialize(self):         print(\"Init human module.\")   # creating an instance model = MainModel(parameters=parameters_2, nature_class=Nature, human_class=Human) <pre>Init natural module.\nInit human module.\n</pre> <p>In the above codes, by subclassing from <code>BaseHuman</code> and <code>BaseNature</code>, we initialize the model by inputing a custom <code>Human</code> module and <code>Nature</code> module. As inputs of initializing a <code>MainModel</code> instance, their custom function <code>.initialize()</code> were called once, seperately. It means, obviously, the custom classes replaced default <code>BaseNature</code> and <code>BaseHuman</code>. We can also find this fact through accessing the corresponding parameters of them:</p> In\u00a0[4]: Copied! <pre># withdraw the parameter from the human module.\nmodel.human.params.test_human\n</pre> # withdraw the parameter from the human module. model.human.params.test_human Out[4]: <pre>1</pre> In\u00a0[5]: Copied! <pre># withdraw the parameter from the nature module.\nmodel.nature.params.test_nature\n</pre> # withdraw the parameter from the nature module. model.nature.params.test_nature Out[5]: <pre>\"I'm a parameter!\"</pre> <p>For better parameters managment, we have another tutorial of control parameters to demonstrate in detail. So far, what you have to know is that the custom <code>Nature</code> and <code>Human</code> modules can access the parameters input into the model because they mock a structure of parameters like this:</p> <pre>time:\n    start: '2000'  # start simulation since 2000.\n    end: '2005'  # The simulation won't be end until 2005.\n    freq: 'M'  # Each counting tick means 1 month in the real world.\n\nhuman:\n    test_human: 1\n\nnature:\n    test_nature: \"I'm a parameter!\"\n</pre> <p>Each class of the model components has a specific name, i.e., here they are <code>human</code> and <code>nature</code>. The corresponding modules would search the parameters structure of model, then withdraw a specific parameter when necessary. In the next sections, you will find this rule will still be applied for sub-modules and actors (agents).</p> <p>Since a social-ecological system is a typical complex system, our users may find their model will growth super big when simulating a real-world case. Therefore, it would be super useful to split the whole model into several logical functional chunks. Different from the two base modules <code>BaseNature</code> and <code>BaseHuman</code>, submodules should be a subclass of <code>HumanModule</code> or <code>PatchModule</code>.</p> In\u00a0[6]: Copied! <pre>from abses.human import HumanModule\n\n\nclass Society(HumanModule):\n    \"\"\"How agent behaves in a society.\"\"\"\n\n\nclass Economy(HumanModule):\n    \"\"\"Some logics in a economic sub-system.\"\"\"\n\n\n# create the submodule by `create_module` function.\nsociety = model.human.create_module(Society)\neconomy = model.human.create_module(Economy, name=\"economy\")\n\n# added two submodules to the human module.\nmodel.human.modules\n</pre> from abses.human import HumanModule   class Society(HumanModule):     \"\"\"How agent behaves in a society.\"\"\"   class Economy(HumanModule):     \"\"\"Some logics in a economic sub-system.\"\"\"   # create the submodule by `create_module` function. society = model.human.create_module(Society) economy = model.human.create_module(Economy, name=\"economy\")  # added two submodules to the human module. model.human.modules Out[6]: <pre>&lt;abses._bases.modules._ModuleFactory at 0x7fce7e78b590&gt;</pre> In\u00a0[7]: Copied! <pre>economy.name\n</pre> economy.name Out[7]: <pre>'economy'</pre> <p>Since we assigned the name of sub-module <code>Economy</code>, of cause its name is \"economy\". At the same time, if we don't assign the name of submodule, it's name will be lowercase <code>__class__.__name__</code>. Therefore, module name of <code>Society</code> should be 'society'. The module names are very important for searching the corresponding parameters.</p> In\u00a0[8]: Copied! <pre>society.name\n</pre> society.name Out[8]: <pre>'society'</pre> <p>Submodules don't have property of 'state'. In stead, they can be turned off or turned on. By default, a new module will be opened, we can turn it off in some cases.</p> In\u00a0[9]: Copied! <pre>print(society.opening)\n\n# turn it off\nsociety.opening = False\nprint(society.opening)\n</pre> print(society.opening)  # turn it off society.opening = False print(society.opening) <pre>True\nFalse\n</pre> <p>There are two properties in a model:</p> <ul> <li><code>agents</code>: A container of all agents in the model.</li> <li><code>glob_vars</code>: A list of all global parameters, which can be accesiible by all components and actors (agents).</li> </ul> <p><code>agents</code> is a unique signleton instance of <code>AgentsContainer</code> for a specific model where all agents are stored. You can operate the agents here by refering this agents operation tutorial. Now, let us try to create some agents for showing how the global variables work.</p> In\u00a0[10]: Copied! <pre>model.glob_vars\n</pre> model.glob_vars Out[10]: <pre>[]</pre> In\u00a0[11]: Copied! <pre>model.agents\n</pre> model.agents Out[11]: <pre>&lt;abses.container._ModelAgentsContainer at 0x7fce7e87c8d0&gt;</pre> In\u00a0[12]: Copied! <pre>from abses import Actor\n\nactors = model.agents.new(Actor, 3)\n\n# Now the container has three actors.\nmodel.agents\n</pre> from abses import Actor  actors = model.agents.new(Actor, 3)  # Now the container has three actors. model.agents Out[12]: <pre>&lt;abses.container._ModelAgentsContainer at 0x7fce7e87c8d0&gt;</pre> In\u00a0[13]: Copied! <pre>model.test_glob = \"I'm a global variable!\"\n\nmodel.add_glob_vars(\"test_glob\")\n\n# let us choose an agent randomly.\nagent = model.agents.select().random.choice()\n\nagent.test_glob\n</pre> model.test_glob = \"I'm a global variable!\"  model.add_glob_vars(\"test_glob\")  # let us choose an agent randomly. agent = model.agents.select().random.choice()  agent.test_glob Out[13]: <pre>\"I'm a global variable!\"</pre> <p>Since they are variable, they may be changed sometimes and you need notify any change to the observers.</p> In\u00a0[14]: Copied! <pre># change a variable and notify all the observers.\nmodel.test_glob = \"variable is ... variable, change it if you want.\"\n\n# notify any change to the observers.\nmodel.notify()\n\nagent.test_glob\n</pre> # change a variable and notify all the observers. model.test_glob = \"variable is ... variable, change it if you want.\"  # notify any change to the observers. model.notify()  agent.test_glob Out[14]: <pre>'variable is ... variable, change it if you want.'</pre> <p>And since it's called a global variable, it's not just the actors can access them, but also the components (modules and sub-modules).</p> In\u00a0[15]: Copied! <pre># Module can access the global variable\nmodel.nature.test_glob\n</pre> # Module can access the global variable model.nature.test_glob Out[15]: <pre>'variable is ... variable, change it if you want.'</pre>"},{"location":"tutorial/beginner/organize_model_structure/#the-basic-structure-of-your-model","title":"The Basic Structure of your Model\u00b6","text":""},{"location":"tutorial/beginner/organize_model_structure/#main-components","title":"Main components\u00b6","text":""},{"location":"tutorial/beginner/organize_model_structure/#create-extensible-sub-modules","title":"Create extensible sub-modules\u00b6","text":""},{"location":"tutorial/beginner/organize_model_structure/#global-variable-and-its-observers","title":"Global variable and its observers\u00b6","text":""},{"location":"tutorial/beginner/predation_tutorial/","title":"Predator-Prey Dynamics Model","text":"In\u00a0[1]: Copied! <pre>from abses import Actor, MainModel, PatchCell\nfrom abses.cells import raster_attribute\n</pre> from abses import Actor, MainModel, PatchCell from abses.cells import raster_attribute <p>As is it usual with a heuristic model, we want to place our agents in an virtual environment. ABSESpy offers the posibility to create a grid by means of the create_module method of the BaseNature class. It is often not necessary to import this class, nor other classes that support it, as the main class, MainModel, will create an instance of it at the moment of its creation. However, here we will import the PatchCell class to creating a subclass that will suit the needs of the model. Namely, we want our patch cells to contain grass for the sheep to eat.</p> <p>We will pass this new class to the create_module method as a parameter. That will make it the default patch cell for the model.</p> <p>The class Grass will be fundamentally the same as its parent class, PatchCell, except for the added property empty that will be used to determine whether there is grass on the cell currently or not. We will also need to method to regrow the grass after it has been consumed.</p> In\u00a0[2]: Copied! <pre>class Grass(PatchCell):\n    \"\"\"Custom patch cell class\"\"\"\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.empty = False\n        self._countdown = 1\n\n    def grow(self):\n        \"\"\"Grow some grass on the cell every 5 ticks.\"\"\"\n        # countdown on brown patches: if you reach 0, grow some grass\n        if self.empty is True:\n            if self._countdown &lt;= 0:\n                self.empty = False\n                self._countdown = 1\n            else:\n                self._countdown -= 1\n\n    @raster_attribute\n    def empty(self) -&gt; bool:\n        \"\"\"Return True if the cell is empty, False otherwise.\"\"\"\n        return self._empty\n\n    @empty.setter\n    def empty(self, value: bool) -&gt; None:\n        \"\"\"Set the empty status of the cell.\"\"\"\n        self._empty = value\n</pre> class Grass(PatchCell):     \"\"\"Custom patch cell class\"\"\"      def __init__(self, *args, **kwargs):         super().__init__(*args, **kwargs)         self.empty = False         self._countdown = 1      def grow(self):         \"\"\"Grow some grass on the cell every 5 ticks.\"\"\"         # countdown on brown patches: if you reach 0, grow some grass         if self.empty is True:             if self._countdown &lt;= 0:                 self.empty = False                 self._countdown = 1             else:                 self._countdown -= 1      @raster_attribute     def empty(self) -&gt; bool:         \"\"\"Return True if the cell is empty, False otherwise.\"\"\"         return self._empty      @empty.setter     def empty(self, value: bool) -&gt; None:         \"\"\"Set the empty status of the cell.\"\"\"         self._empty = value In\u00a0[3]: Copied! <pre>from abses.actor import alive_required\n\n\nclass Animal(Actor):\n    \"\"\"Custom animal\"\"\"\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.energy = 5\n\n    def step(self):\n        self.eat()\n        self.reproduce()\n        try:\n            self.move(\"random\")\n        except Exception as e:\n            raise ValueError(\n                f\"{self}, layer is {self.layer}, move failed at {self.model.time}\"\n            ) from e\n        self.update()\n\n    def update(self):\n        \"\"\"Update the animal's state.\"\"\"\n        # consume energy\n        self.energy -= 1\n        if self.energy &lt;= 0:\n            self.die()\n\n    @alive_required\n    def reproduce(self):\n        \"\"\"Reproduce if there's enough energy.\"\"\"\n        if self.random.random() &lt; self.params.rep_rate:\n            self.energy /= 2\n            self.at.agents.new(self.__class__)\n</pre> from abses.actor import alive_required   class Animal(Actor):     \"\"\"Custom animal\"\"\"      def __init__(self, *args, **kwargs):         super().__init__(*args, **kwargs)         self.energy = 5      def step(self):         self.eat()         self.reproduce()         try:             self.move(\"random\")         except Exception as e:             raise ValueError(                 f\"{self}, layer is {self.layer}, move failed at {self.model.time}\"             ) from e         self.update()      def update(self):         \"\"\"Update the animal's state.\"\"\"         # consume energy         self.energy -= 1         if self.energy &lt;= 0:             self.die()      @alive_required     def reproduce(self):         \"\"\"Reproduce if there's enough energy.\"\"\"         if self.random.random() &lt; self.params.rep_rate:             self.energy /= 2             self.at.agents.new(self.__class__) <p>At each step, both sheep and wolves will move randomly to a new neighboring cell. Then, they will eat if there is food avaiable to them. Given a certain probability, they will reproduce. That probability is determined by the rep_rate property. Finally, they will be lose some energy.</p> In\u00a0[4]: Copied! <pre>class Wolf(Animal):\n    \"\"\"Custom wolf.\"\"\"\n\n    marker = \"^\"\n\n    def eat(self):\n        \"\"\"If there is a sheep in the cell, eat it and gain energy.\"\"\"\n        sheep_here = self.at.agents.select(agent_type=Sheep)\n        if a_sheep := sheep_here.random.choice(when_empty=\"return None\"):\n            a_sheep.die()\n            self.energy += 5\n\n\nclass Sheep(Animal):\n    \"\"\"Custom sheep.\"\"\"\n\n    def eat(self):\n        \"\"\"If there is grass in the cell, eat it and gain energy.\"\"\"\n        if self.get(\"empty\", target=\"cell\") is False:\n            self.energy += 5\n            self.set(\"empty\", True, target=\"cell\")\n</pre> class Wolf(Animal):     \"\"\"Custom wolf.\"\"\"      marker = \"^\"      def eat(self):         \"\"\"If there is a sheep in the cell, eat it and gain energy.\"\"\"         sheep_here = self.at.agents.select(agent_type=Sheep)         if a_sheep := sheep_here.random.choice(when_empty=\"return None\"):             a_sheep.die()             self.energy += 5   class Sheep(Animal):     \"\"\"Custom sheep.\"\"\"      def eat(self):         \"\"\"If there is grass in the cell, eat it and gain energy.\"\"\"         if self.get(\"empty\", target=\"cell\") is False:             self.energy += 5             self.set(\"empty\", True, target=\"cell\") In\u00a0[5]: Copied! <pre>class WolfSheepModel(MainModel):\n    \"\"\"Wolf-Sheep predation tutorial model.\"\"\"\n\n    @property\n    def n_sheep(self):\n        return self.agents.has(Sheep)\n\n    @property\n    def n_wolves(self):\n        return self.agents.has(\"Wolf\")\n\n    def setup(self):\n        # initialize a grid\n        grassland = self.nature.create_module(\n            how=\"from_resolution\",\n            shape=self.params.shape,\n            name=\"grassland\",\n            cell_cls=Grass,\n        )\n\n        # add sheep and wolves\n        grassland.random.choice(self.params.n_wolves).apply(\n            lambda c: c.agents.new(Wolf)\n        )\n        grassland.random.choice(self.params.n_sheep).apply(\n            lambda c: c.agents.new(Sheep)\n        )\n        for agent in self.agents:\n            assert agent.layer is grassland\n\n    def step(self):\n        self.nature.grassland.apply(lambda c: c.grow())\n        self.agents.shuffle_do(\"step\")\n        self.check_end()\n        self.datacollector.collect(self)\n\n    def check_end(self):\n        \"\"\"Check if the model should stop.\"\"\"\n        # end model\n        if not self.agents.has(Sheep):\n            self.running = False\n        elif not self.agents.has(\"Wolf\"):\n            self.running = False\n        elif self.agents.has(Sheep) &gt;= 1200:\n            self.running = False\n\n    @property\n    def n_grass(self):\n        \"\"\"Return the number of grass patches.\"\"\"\n        empty = self.nature.grassland.get_raster(\"empty\")\n        return empty.size - empty.sum()\n</pre> class WolfSheepModel(MainModel):     \"\"\"Wolf-Sheep predation tutorial model.\"\"\"      @property     def n_sheep(self):         return self.agents.has(Sheep)      @property     def n_wolves(self):         return self.agents.has(\"Wolf\")      def setup(self):         # initialize a grid         grassland = self.nature.create_module(             how=\"from_resolution\",             shape=self.params.shape,             name=\"grassland\",             cell_cls=Grass,         )          # add sheep and wolves         grassland.random.choice(self.params.n_wolves).apply(             lambda c: c.agents.new(Wolf)         )         grassland.random.choice(self.params.n_sheep).apply(             lambda c: c.agents.new(Sheep)         )         for agent in self.agents:             assert agent.layer is grassland      def step(self):         self.nature.grassland.apply(lambda c: c.grow())         self.agents.shuffle_do(\"step\")         self.check_end()         self.datacollector.collect(self)      def check_end(self):         \"\"\"Check if the model should stop.\"\"\"         # end model         if not self.agents.has(Sheep):             self.running = False         elif not self.agents.has(\"Wolf\"):             self.running = False         elif self.agents.has(Sheep) &gt;= 1200:             self.running = False      @property     def n_grass(self):         \"\"\"Return the number of grass patches.\"\"\"         empty = self.nature.grassland.get_raster(\"empty\")         return empty.size - empty.sum() In\u00a0[6]: Copied! <pre>parameters = {\n    \"time\": {\"end\": 100},\n    \"reports\": {\n        \"model\": {\n            \"n_sheep\": \"n_sheep\",\n            \"n_wolves\": \"n_wolves\",\n            \"n_grass\": \"n_grass\",\n        }\n    },\n    \"model\": {\n        \"shape\": (12, 12),\n        \"n_sheep\": 100,\n        \"n_wolves\": 5,\n    },\n    \"wolf\": {\"rep_rate\": 0.05, \"min_energy\": 10},\n    \"sheep\": {\"rep_rate\": 0.10, \"min_energy\": 6},\n}\n\nmodel = WolfSheepModel(parameters=parameters)\nmodel.run_model()\n</pre> parameters = {     \"time\": {\"end\": 100},     \"reports\": {         \"model\": {             \"n_sheep\": \"n_sheep\",             \"n_wolves\": \"n_wolves\",             \"n_grass\": \"n_grass\",         }     },     \"model\": {         \"shape\": (12, 12),         \"n_sheep\": 100,         \"n_wolves\": 5,     },     \"wolf\": {\"rep_rate\": 0.05, \"min_energy\": 10},     \"sheep\": {\"rep_rate\": 0.10, \"min_energy\": 6}, }  model = WolfSheepModel(parameters=parameters) model.run_model() <pre>[14:20:53][WARNING][nature] the nature's CRS has been changed to epsg:4326.\n</pre> <pre>[14:20:57][WARNING][datacollector] No final reporters have been definedreturning empty DataFrame.\n</pre> In\u00a0[7]: Copied! <pre>model.agents.get(\"unique_id\")\n</pre> model.agents.get(\"unique_id\") Out[7]: <pre>[5,\n 445,\n 539,\n 604,\n 693,\n 791,\n 1161,\n 1214,\n 1220,\n 1237,\n 1260,\n 1302,\n 1379,\n 1385,\n 1430,\n 1441,\n 1498,\n 1502,\n 1515,\n 1577,\n 1744,\n 1772,\n 1775,\n 1793,\n 1796,\n 1798,\n 1800,\n 1803,\n 1804,\n 1805,\n 1807,\n 1808,\n 1809,\n 1810,\n 1811,\n 1812,\n 1813,\n 1814,\n 1815,\n 1816]</pre> In\u00a0[8]: Copied! <pre>for agent in model.agents:\n    if agent.unique_id == 44:\n        print(agent.layer)\n</pre> for agent in model.agents:     if agent.unique_id == 44:         print(agent.layer) <p>Let's simply plot the current agents. For more comprehensive visualization tutorials, please refer to the viz model tutorial in this repository.</p> In\u00a0[9]: Copied! <pre>model.nature.major_layer.plot.show()\n</pre> model.nature.major_layer.plot.show() Out[9]: <pre>&lt;Axes: title={'center': 'spatial_ref = 0'}, xlabel='longitude [degrees_east]', ylabel='latitude [degrees_north]'&gt;</pre> <p>In this single run, the results show diverging populations. At first, the sheep population declines and the wolf population increases. Then, the wolf population declines and the sheep population increases. All wolves disappear and the sheep population reaches the carrying capacity of the environment.</p> In\u00a0[10]: Copied! <pre>model.plot.lineplot([\"n_sheep\", \"n_wolves\", \"n_grass\"])\n</pre> model.plot.lineplot([\"n_sheep\", \"n_wolves\", \"n_grass\"]) Out[10]: <pre>&lt;Axes: &gt;</pre>"},{"location":"tutorial/beginner/predation_tutorial/#predator-prey-dynamics-model","title":"Predator-Prey Dynamics Model\u00b6","text":""},{"location":"tutorial/beginner/predation_tutorial/#introduction","title":"Introduction\u00b6","text":"<p>The following tutorial aims to describe a more dynamic model using the <code>ABSESpy</code>. It consists of an implementation of the Lotka-Volterra model which presents a simple ecosystem with two species: predators and preys. This model was originally proposed as a system of first-order, non-linear differential equations and has found its computation, individual-based simulation counterparts.</p> <p>This introductory tutorial illustrates:</p> <ol> <li>Converting a property of <code>PatchCell</code> to raster attribute.</li> <li>Managing different breeds of <code>Actor</code> and their parameters.</li> <li>Implement randomly actions of <code>Actor</code>.</li> </ol> <p>The model aims to capture the dynamical evolution of the population of wolves and the population of sheep. It recreates a simple food chain where wolves feed on sheep and, in turn, sheep feed on grass. Both sheep and wolves have energy levels that are invariable affected by their movement. A move costs energy that can only be replenish by eating.</p>"},{"location":"tutorial/beginner/predation_tutorial/#the-grass-patchcell","title":"The Grass Patchcell\u00b6","text":""},{"location":"tutorial/beginner/predation_tutorial/#agents-classes","title":"Agents Classes\u00b6","text":"<p>We need at least two custom classes. One to represent wolves and another to represent sheep. Across these two classes there is common functionality that can be abstracted into a parent class. In particular, we may want to define a shared method for movement, reproduction and energy consumption. From there, a class Wolf can be define to handle how the wolves will feed on sheep and a class Sheep to handle how the sheep will feed on grass.</p> <p>The parent class Animal will have the following properties:</p> <ul> <li>energy: the amount of energy the animal has. It will be used to determine whether the animal can move or reproduce.</li> <li>rep_rate: the rate at which the animal reproduces. It will be used to determine whether the animal can reproduce. There will be methods defined for this class to handle agents' movement, reproduction and death.</li> </ul>"},{"location":"tutorial/beginner/predation_tutorial/#the-model","title":"The Model\u00b6","text":"<p>Our model consists of two components. One initialization method and a step method. Most of the complexity of the model lies in interaction between agents and the added feature of the grass patch cells.</p> <p>The WolfSheepModel class is a subclass of MainModel and represents a simulation model for a predator-prey system involving wolves and sheep. In the constructor (init), the model initializes a grid with cells represented by the Grass class. It then creates a list of all cells in the grid. The model creates a specified number of Wolf and Sheep agents with given reproduction rates. These agents are then placed randomly on the grid. A DataCollector instance is also initialized to track the populations of wolves and sheep in the model.</p> <p>The step method represents a single time step in the simulation. In each time step, the step method of all Sheep and Wolf agents is triggered, allowing them to perform their actions. Then, the grow_grass method is called for each cell in the grid, simulating the growth of grass. The model checks if the populations of sheep and wolves are empty or if the population of sheep has reached 400, in which case it stops the simulation by setting self.running to False. Finally, the collect method of the DataCollector is called to collect data for the current time step.</p>"},{"location":"tutorial/beginner/predation_tutorial/#simulations","title":"Simulations\u00b6","text":"<p>We are now able to run simulations. We instantiate a model to run for 100 steps. It will have a ratio of 4 sheep for every wolf. We keep the reproduction rates low. We will then plot the resulting evolution in the populations of wolves and sheep.</p>"},{"location":"tutorial/beginner/time_control/","title":"Real-world SES modeling enhancements","text":"<p>In progress</p> <p>This document is a work in progress if you see any errors, or exclusions or have any problems, please get in touch with us.</p> <p>In Socio-Ecological Systems (SES) modeling, a real-world event's natural or human-induced duration can range from seconds to centuries. Recognizing the importance of time in modeling real-world problems, ABSESpy introduces a superior time control mechanism that stands out from traditional agent-based modeling frameworks.</p> <p>The same as traditional agent-based modeling framework and, by default, <code>ABSESpy</code> records each simulating step as an increment of counting ticker.</p> In\u00a0[1]: Copied! <pre>from abses import MainModel\n\n# create a tick mode model.\nmodel = MainModel()\n\nmodel.time.ticking_mode\n</pre> from abses import MainModel  # create a tick mode model. model = MainModel()  model.time.ticking_mode Out[1]: <pre>'tick'</pre> <p><code>TimeDriver</code> is the major class where most time-related functions are implementationed. For detailed usage, please check out the API documentation.</p> <p>Under this simplest and most-popular mode, let's try to go 5 steps. Notice that <code>tick</code> of time went from <code>0</code> to <code>5</code>.</p> In\u00a0[2]: Copied! <pre>model.time\n\nmodel.time.go(5)\n\n# Counter\nmodel.time\n</pre> model.time  model.time.go(5)  # Counter model.time Out[2]: <pre>&lt;TimeDriver: tick[5]&gt;</pre> <p>Another important property of <code>TimeDriver</code>, the <code>start_dt</code> stores when the <code>TimeDriver</code> was run firstly under the 'tick' mode.</p> In\u00a0[3]: Copied! <pre>model.time.start_dt\n</pre> model.time.start_dt Out[3]: <pre>DateTime(2025, 2, 16, 14, 21, 1, 383927)</pre> <p>However, by introducing a feature what we named as a Duration Mode, <code>ABSESpy</code> makes much easier to simulate the actual progression of time. Bellow is a simple implementation of yearly-step model:</p> In\u00a0[4]: Copied! <pre>parameters = {\n    \"time\": {\n        \"years\": 1,\n    }\n}\n\nmodel = MainModel(parameters=parameters)\n\n# Another ticking model.\nmodel.time.ticking_mode\n</pre> parameters = {     \"time\": {         \"years\": 1,     } }  model = MainModel(parameters=parameters)  # Another ticking model. model.time.ticking_mode Out[4]: <pre>'duration'</pre> <p>By introducing a param of <code>years = 1</code> under the 'time' session, our model ticking-mode changed to 'duration'. Which means whenever the model goes a step, the simulation is like one year of real-world time.</p> In\u00a0[5]: Copied! <pre>model.time\n\n# go six years... ...\nmodel.time.go(6)\n\nmodel.time\n</pre> model.time  # go six years... ... model.time.go(6)  model.time Out[5]: <pre>&lt;TimeDriver: 2031-02-16 14:21:01&gt;</pre> <p>As you could see, the real-time counted from a start of the current time, we can change the behaviors by inputing different parameters of 'time' session. See this parameters management tutorial to learn how to make full use of this feature. Bellow is the possible parameters table:</p> <p><code>TimeDriver</code> accepts below parameters:</p> Parameter Name Expected Data Type Default Value Description start str, None None If None: use the current time, else: should be a string which can be parsed by <code>pendulum.parse()</code>. end str, int, None None If it's a string that can be parsed into datetime the model should end until achieving this time; if int: the model should end in that tick; if None no auto-end. irregular bool False If False: not dive into an irregular mode (tick-mode); if True, the model will solve as an irregular mode. years int 0 Time duration in years for the duration mode. months int 0 Time duration in months for the duration mode. weeks int 0 Time duration in weeks for the duration mode. days int 0 Time duration in days for the duration mode. hours int 0 Time duration in hours for the duration mode. minutes int 0 Time duration in minutes for the duration mode. seconds int 0 Time duration in seconds for the duration mode. <p>This is a highly customisable mode, but accordingly, it is not commonly used and requires more code to be written by the user, so it is only briefly described here. To enable this mode, make sure that the <code>record</code> parameter of the time module is turned on, and that there can't be any parameters that trigger the <code>duration</code> mode (e.g. <code>years</code>, <code>months</code>, <code>days</code>, <code>hours</code>, <code>minutes</code> and <code>seconds</code>)</p> In\u00a0[6]: Copied! <pre>parameters = {\"time\": {\"irregular\": True, \"start\": \"2020-01-01\", \"end\": \"2022-01-01\"}}\n\nmodel = MainModel(parameters=parameters)\nmodel.time.go(years=1)\nmodel.time.go(ticks=0, months=5)\nmodel.time.go(ticks=3, days=100)\n</pre> parameters = {\"time\": {\"irregular\": True, \"start\": \"2020-01-01\", \"end\": \"2022-01-01\"}}  model = MainModel(parameters=parameters) model.time.go(years=1) model.time.go(ticks=0, months=5) model.time.go(ticks=3, days=100) In\u00a0[7]: Copied! <pre>model.time\nmodel.time.end_dt\n\nmodel.time.should_end\n</pre> model.time model.time.end_dt  model.time.should_end Out[7]: <pre>False</pre> <p>Of the most important reasons to use real-world data and time is dynamically loading and updating time-series datasets.</p> <p>For testing this feature, let's create a time-series data by pandas.</p> In\u00a0[8]: Copied! <pre>import pandas as pd\n\ndt_index = pd.date_range(\"2000-01-01\", \"2020-01-01\", freq=\"Y\")\ndata_1 = pd.Series(data=range(len(dt_index)), index=dt_index.year)\n\ndata_1\n</pre> import pandas as pd  dt_index = pd.date_range(\"2000-01-01\", \"2020-01-01\", freq=\"Y\") data_1 = pd.Series(data=range(len(dt_index)), index=dt_index.year)  data_1 <pre>/tmp/ipykernel_2515/3255829277.py:3: FutureWarning: 'Y' is deprecated and will be removed in a future version, please use 'YE' instead.\n  dt_index = pd.date_range(\"2000-01-01\", \"2020-01-01\", freq=\"Y\")\n</pre> Out[8]: <pre>2000     0\n2001     1\n2002     2\n2003     3\n2004     4\n2005     5\n2006     6\n2007     7\n2008     8\n2009     9\n2010    10\n2011    11\n2012    12\n2013    13\n2014    14\n2015    15\n2016    16\n2017    17\n2018    18\n2019    19\ndtype: int64</pre> <p>For selecting the data from a corresponding year dynamically, we need to define a <code>_DynamicVariable</code>. In the belowing testing model</p> In\u00a0[9]: Copied! <pre>parameters = {\n    \"time\": {\n        \"start\": \"2000-12-31\",\n        \"years\": 5,  # Notice this, each step corresponds to 5 real-world years.\n    }\n}\n\n# setup a testing model.\nmodel = MainModel(parameters=parameters)\n\n\n# define a function to solve the data_1.\ndef withdraw_data(data, time):\n    \"\"\"Function for dynamic data withdraw\"\"\"\n    return data.loc[time.year]\n\n\n# define the dyanamic data, storing `withdrawing function` and the `data source`.\nmodel.human.add_dynamic_variable(name=\"data_1\", data=data_1, function=withdraw_data)\n</pre> parameters = {     \"time\": {         \"start\": \"2000-12-31\",         \"years\": 5,  # Notice this, each step corresponds to 5 real-world years.     } }  # setup a testing model. model = MainModel(parameters=parameters)   # define a function to solve the data_1. def withdraw_data(data, time):     \"\"\"Function for dynamic data withdraw\"\"\"     return data.loc[time.year]   # define the dyanamic data, storing `withdrawing function` and the `data source`. model.human.add_dynamic_variable(name=\"data_1\", data=data_1, function=withdraw_data) <p>Since we store a time-series data withdrawing rule, we can access the data dyanamically in the future whenever the time goes by.</p> In\u00a0[10]: Copied! <pre>model.human.dynamic_var(\"data_1\")\n</pre> model.human.dynamic_var(\"data_1\") Out[10]: <pre>0</pre> <p>Next selection should be 5 (because the real-world time goes 5 years per step).</p> In\u00a0[11]: Copied! <pre>model.time.go()\nmodel.human.dynamic_var(\"data_1\")\n</pre> model.time.go() model.human.dynamic_var(\"data_1\") Out[11]: <pre>5</pre> <p>Then, 10... and so on</p> In\u00a0[12]: Copied! <pre># should be 10\nmodel.time.go()\nmodel.human.dynamic_var(\"data_1\")\n\n# should be 15\nmodel.time.go()\nmodel.human.dynamic_var(\"data_1\")\n</pre> # should be 10 model.time.go() model.human.dynamic_var(\"data_1\")  # should be 15 model.time.go() model.human.dynamic_var(\"data_1\") Out[12]: <pre>15</pre> <p>Dynamic data may be beneficial because modeling the real-world SES problem often requires various datasets as inputs. You won't want to re-calculate the data in each step... So! Just define them as dynamic variables when initializing or setting up a module by uploading a <code>withdraw data function</code> and a <code>data source</code>. It should also be applied to spatial datasets! Like selecting a raster data through some withdrawing function like <code>xarray.DataArray.sel(time=...)</code>.</p> <p>Triggering some function based on a specific condition is another advanced application and highlight advantage of using real-world time. In <code>ABSESpy</code> we provide a decorator named <code>time_condition</code> to do so. The below use case is intuitive: our custom <code>Actor</code> class <code>TestActor</code> has a function but we only want to use it on the day of the beginning of a year. Therefore, we define a condition dictionary <code>{'month': 1, 'day': 1}</code>. Therefore, in the 10 times run, the function is called only once.</p> In\u00a0[13]: Copied! <pre>from abses.time import time_condition\nfrom abses import Actor\n\n\nclass TestActor(Actor):\n    @time_condition(condition={\"month\": 1, \"day\": 1}, when_run=True)\n    def happy_new_year(self):\n        print(\"Today is 1th, January, Happy new year!\")\n\n\nparameters = {\"time\": {\"start\": \"1996-12-24\", \"days\": 1}}\n\n\nmodel = MainModel(parameters=parameters)\nagent = model.agents.new(TestActor, 1, singleton=True)\n\nfor _ in range(10):\n    print(f\"Time now is {model.time}\")\n    model.time.go()\n    agent.happy_new_year()\n</pre> from abses.time import time_condition from abses import Actor   class TestActor(Actor):     @time_condition(condition={\"month\": 1, \"day\": 1}, when_run=True)     def happy_new_year(self):         print(\"Today is 1th, January, Happy new year!\")   parameters = {\"time\": {\"start\": \"1996-12-24\", \"days\": 1}}   model = MainModel(parameters=parameters) agent = model.agents.new(TestActor, 1, singleton=True)  for _ in range(10):     print(f\"Time now is {model.time}\")     model.time.go()     agent.happy_new_year() <pre>Time now is &lt;TimeDriver: 1996-12-24 00:00:00&gt;\nTime now is &lt;TimeDriver: 1996-12-25 00:00:00&gt;\nTime now is &lt;TimeDriver: 1996-12-26 00:00:00&gt;\nTime now is &lt;TimeDriver: 1996-12-27 00:00:00&gt;\nTime now is &lt;TimeDriver: 1996-12-28 00:00:00&gt;\nTime now is &lt;TimeDriver: 1996-12-29 00:00:00&gt;\nTime now is &lt;TimeDriver: 1996-12-30 00:00:00&gt;\nTime now is &lt;TimeDriver: 1996-12-31 00:00:00&gt;\nToday is 1th, January, Happy new year!\nTime now is &lt;TimeDriver: 1997-01-01 00:00:00&gt;\nTime now is &lt;TimeDriver: 1997-01-02 00:00:00&gt;\n</pre> <p>It should be called again in the next year beginning (i.e., <code>1998-01-01</code>) if we run this model longer... It means, the function will be called when the condition is fully satisfied. However, we can setup an opposite case by setting parameter <code>when_run = False</code>:</p> In\u00a0[14]: Copied! <pre>class TestActor_2(Actor):\n    @time_condition(condition={\"month\": 1, \"day\": 6}, when_run=False)\n    def working(self):\n        print(\"I have to work today \ud83d\ude2d!\")\n\n\nagent_2 = model.agents.new(TestActor_2, 1, singleton=True)\nfor _ in range(5):\n    print(f\"Time now is {model.time}\")\n    model.time.go()\n    agent_2.working()\n</pre> class TestActor_2(Actor):     @time_condition(condition={\"month\": 1, \"day\": 6}, when_run=False)     def working(self):         print(\"I have to work today \ud83d\ude2d!\")   agent_2 = model.agents.new(TestActor_2, 1, singleton=True) for _ in range(5):     print(f\"Time now is {model.time}\")     model.time.go()     agent_2.working() <pre>Time now is &lt;TimeDriver: 1997-01-03 00:00:00&gt;\nI have to work today \ud83d\ude2d!\nTime now is &lt;TimeDriver: 1997-01-04 00:00:00&gt;\nI have to work today \ud83d\ude2d!\nTime now is &lt;TimeDriver: 1997-01-05 00:00:00&gt;\nTime now is &lt;TimeDriver: 1997-01-06 00:00:00&gt;\nI have to work today \ud83d\ude2d!\nTime now is &lt;TimeDriver: 1997-01-07 00:00:00&gt;\nI have to work today \ud83d\ude2d!\n</pre> <p>In the above case, the <code>agent_2</code> didn't have to work on 6th, January (as we set in the condition dictionary) \ud83d\ude04!</p> <p>This ensures that certain actions or events only occur at the right moments in your simulation, mirroring real-world occurrences with higher fidelity.</p>"},{"location":"tutorial/beginner/time_control/#real-world-ses-modeling-enhancements","title":"Real-world SES modeling enhancements\u00b6","text":""},{"location":"tutorial/beginner/time_control/#real-world-time-configurations","title":"Real-world time configurations\u00b6","text":""},{"location":"tutorial/beginner/time_control/#tick-mode","title":"'Tick' mode\u00b6","text":""},{"location":"tutorial/beginner/time_control/#duration-mode","title":"'duration' mode\u00b6","text":""},{"location":"tutorial/beginner/time_control/#irregular-mode","title":"'Irregular' mode\u00b6","text":""},{"location":"tutorial/beginner/time_control/#auto-update-dynamic-variables","title":"Auto-update Dynamic Variables\u00b6","text":""},{"location":"tutorial/beginner/time_control/#conditional-time-based-triggering","title":"Conditional Time-based Triggering\u00b6","text":""},{"location":"tutorial/completing/fire_tutorial/","title":"Fire Spread Simulation","text":"In\u00a0[1]: Copied! <pre>from matplotlib import pyplot as plt\n\nfrom abses.cells import PatchCell, raster_attribute\nfrom abses.main import MainModel\nfrom abses.nature import PatchModule\nfrom abses.sequences import ActorsList\n</pre> from matplotlib import pyplot as plt  from abses.cells import PatchCell, raster_attribute from abses.main import MainModel from abses.nature import PatchModule from abses.sequences import ActorsList <p>As usual, the basis of any ABSESpy model are the MainModel. For these specific model we won't use the <code>Actor</code> class. Instead, we will rely heavily on the capabilities of the <code>PatchCell</code> class, part of the ABSESpy library.</p> <p>We must implement a class that will control, contain and manage global level variables and objects such as the grid of the cells. That is the task the <code>Forest</code> class which will inherit from the <code>MainModel</code> class. Then, we also need the implementation of our agents. That is the task of the <code>Tree</code> class, which will inherit from the <code>PatchCell</code> class.</p> <pre>class Tree(PatchCell):\n    (...)\n\nclass Forest(MainModel):\n    (...)\n</pre> In\u00a0[2]: Copied! <pre>class Tree(PatchCell):\n    \"\"\"\n    Breed `Tree` is a subclass of `PatchCell`.\n    It has four different states:\n    0: empty, i.e., no tree is located on the patch.\n    1: has an intact tree.\n    2: the tree here is burning now.\n    3: the three here is burned and now scorched -cannot be burned again.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self._state = 0\n\n    def burning(self):\n        \"\"\"If the tree is burning, it ignites the neighboring trees.\"\"\"\n        if self._state == 2:\n            neighbors = self.neighboring(moore=False, radius=1)\n            # apply to all neighboring patches: trigger ignite method\n            neighbors.select({\"state\": 1}).trigger(\"ignite\")\n            # after then, it becomes scorched and cannot be burned again.\n            self._state = 3\n\n    def grow(self) -&gt; None:\n        \"\"\"Grows the tree here.\"\"\"\n        self._state = 1\n\n    def ignite(self) -&gt; None:\n        \"\"\"Ignite this tree.\"\"\"\n        if self._state == 1:\n            self._state = 2\n\n    @raster_attribute\n    def state(self) -&gt; int:\n        \"\"\"Return the state code.\"\"\"\n        return self._state\n</pre> class Tree(PatchCell):     \"\"\"     Breed `Tree` is a subclass of `PatchCell`.     It has four different states:     0: empty, i.e., no tree is located on the patch.     1: has an intact tree.     2: the tree here is burning now.     3: the three here is burned and now scorched -cannot be burned again.     \"\"\"      def __init__(self, *args, **kwargs):         super().__init__(*args, **kwargs)         self._state = 0      def burning(self):         \"\"\"If the tree is burning, it ignites the neighboring trees.\"\"\"         if self._state == 2:             neighbors = self.neighboring(moore=False, radius=1)             # apply to all neighboring patches: trigger ignite method             neighbors.select({\"state\": 1}).trigger(\"ignite\")             # after then, it becomes scorched and cannot be burned again.             self._state = 3      def grow(self) -&gt; None:         \"\"\"Grows the tree here.\"\"\"         self._state = 1      def ignite(self) -&gt; None:         \"\"\"Ignite this tree.\"\"\"         if self._state == 1:             self._state = 2      @raster_attribute     def state(self) -&gt; int:         \"\"\"Return the state code.\"\"\"         return self._state In\u00a0[3]: Copied! <pre>import numpy as np\n\nCOLORS = {\n    0: \"#54473F\",\n    1: \"#859F3D\",\n    2: \"#FD8B51\",\n    3: \"#FF4545\",\n}\n\n\nclass Forest(MainModel):\n    \"\"\"\n    Forest model where fire\n    \"\"\"\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        # setup a grid space.\n        grid: PatchModule = self.nature.create_module(\n            how=\"from_resolution\",\n            name=\"forest\",\n            shape=self.p.shape,\n            cell_cls=Tree,\n            major_layer=True,\n        )\n        # random choose some patches to setup trees\n        chosen_patches = grid.random.choice(self.num_trees, replace=False)\n        # create trees on the selected patches.\n        chosen_patches.trigger(\"grow\")\n        # ignite the trees in the leftmost column.\n        ActorsList(self, grid.array_cells[:, 0]).trigger(\"ignite\")\n\n    def step(self):\n        for tree in self.nature.forest:\n            tree.burning()\n\n    @property\n    def burned_rate(self) -&gt; float:\n        \"\"\"The burned trees in ratio.\"\"\"\n        state = self.nature.get_raster(\"state\")\n        return np.squeeze(state == 3).sum() / self.num_trees\n\n    @property\n    def num_trees(self) -&gt; int:\n        \"\"\"Number of trees\"\"\"\n        shape = self.params.shape\n        return int(shape[0] * shape[1] * self.params.density)\n\n    def plot_state(self):\n        \"\"\"Plot the state of trees.\"\"\"\n        cmap = plt.cm.colors.ListedColormap([COLORS[i] for i in sorted(COLORS)])\n        data = self.nature.get_xarray(\"state\")\n        data.plot(cmap=cmap)\n        plt.show()\n</pre> import numpy as np  COLORS = {     0: \"#54473F\",     1: \"#859F3D\",     2: \"#FD8B51\",     3: \"#FF4545\", }   class Forest(MainModel):     \"\"\"     Forest model where fire     \"\"\"      def __init__(self, *args, **kwargs):         super().__init__(*args, **kwargs)         # setup a grid space.         grid: PatchModule = self.nature.create_module(             how=\"from_resolution\",             name=\"forest\",             shape=self.p.shape,             cell_cls=Tree,             major_layer=True,         )         # random choose some patches to setup trees         chosen_patches = grid.random.choice(self.num_trees, replace=False)         # create trees on the selected patches.         chosen_patches.trigger(\"grow\")         # ignite the trees in the leftmost column.         ActorsList(self, grid.array_cells[:, 0]).trigger(\"ignite\")      def step(self):         for tree in self.nature.forest:             tree.burning()      @property     def burned_rate(self) -&gt; float:         \"\"\"The burned trees in ratio.\"\"\"         state = self.nature.get_raster(\"state\")         return np.squeeze(state == 3).sum() / self.num_trees      @property     def num_trees(self) -&gt; int:         \"\"\"Number of trees\"\"\"         shape = self.params.shape         return int(shape[0] * shape[1] * self.params.density)      def plot_state(self):         \"\"\"Plot the state of trees.\"\"\"         cmap = plt.cm.colors.ListedColormap([COLORS[i] for i in sorted(COLORS)])         data = self.nature.get_xarray(\"state\")         data.plot(cmap=cmap)         plt.show() In\u00a0[4]: Copied! <pre>cfg = {\"model\": {\"density\": 0.6, \"shape\": (100, 100)}, \"time\": {\"end\": 25}}\n\n# Instantiate the model and set it up.\nmodel = Forest(parameters=cfg, seed=42)\n# Run and plot final state\nmodel.run_model()\nmodel.plot_state()\n</pre> cfg = {\"model\": {\"density\": 0.6, \"shape\": (100, 100)}, \"time\": {\"end\": 25}}  # Instantiate the model and set it up. model = Forest(parameters=cfg, seed=42) # Run and plot final state model.run_model() model.plot_state() <pre>[14:21:05][WARNING][nature] the nature's CRS has been changed to epsg:4326.\n</pre> <pre>[14:21:06][WARNING][datacollector] No final reporters have been definedreturning empty DataFrame.\n</pre> In\u00a0[5]: Copied! <pre>cfg = {\n    \"model\": {\"density\": 0.4, \"shape\": (100, 100)},\n    \"time\": {\"end\": 25},\n    \"reports\": {\"final\": {\"burned\": \"burned_rate\"}},\n}\n\n# Instantiate the model and set it up.\nmodel = Forest(parameters=cfg, seed=42)\n# Run and plot final state\nmodel.run_model()\nmodel.plot_state()\n</pre> cfg = {     \"model\": {\"density\": 0.4, \"shape\": (100, 100)},     \"time\": {\"end\": 25},     \"reports\": {\"final\": {\"burned\": \"burned_rate\"}}, }  # Instantiate the model and set it up. model = Forest(parameters=cfg, seed=42) # Run and plot final state model.run_model() model.plot_state() <p>In this session, we are going explore how the key parameter \"density\" of trees in the forest affects the spread of the fire. We will run simulations with different values of the density parameter and observe the speed of fire spread in each case.</p> In\u00a0[6]: Copied! <pre>from abses import Experiment\n\nexp = Experiment(Forest, cfg=cfg)\n</pre> from abses import Experiment  exp = Experiment(Forest, cfg=cfg) <p>First of all, we import the <code>Experiment</code> object from the <code>ABSESpy</code> library for batch run.</p> <p>Since the <code>Forest</code> model is defined in this notebook, we cannot use multiple processing to run the simulations. We will use the <code>Experiment</code> object to run the simulations sequentially.</p> In\u00a0[7]: Copied! <pre>exp.batch_run(repeats=10, parallels=1)\n</pre> exp.batch_run(repeats=10, parallels=1) <p>Next, we would try to use different parameters of <code>model.density</code>.</p> In\u00a0[8]: Copied! <pre>exp.batch_run(\n    repeats=10,\n    parallels=5,\n    overrides={\"model.density\": np.arange(0.1, 1.01, 0.1)},\n)\n</pre> exp.batch_run(     repeats=10,     parallels=5,     overrides={\"model.density\": np.arange(0.1, 1.01, 0.1)}, ) <pre>[14:21:13][WARNING][nature] the nature's CRS has been changed to epsg:4326.\n[14:21:13][WARNING][nature] the nature's CRS has been changed to epsg:4326.\n[14:21:13][WARNING][nature] the nature's CRS has been changed to epsg:4326.\n[14:21:13][WARNING][nature] the nature's CRS has been changed to epsg:4326.\n</pre> <pre>[14:21:14][WARNING][nature] the nature's CRS has been changed to epsg:4326.\n</pre> <pre>/home/runner/work/ABSESpy/ABSESpy/.venv/lib/python3.11/site-packages/joblib/externals/loky/process_executor.py:752: UserWarning: A worker stopped while some jobs were given to the executor. This can be caused by a too short worker timeout or by a memory leak.\n  warnings.warn(\n</pre> <pre>[14:21:47][WARNING][nature] the nature's CRS has been changed to epsg:4326.\n</pre> <pre>[14:21:48][WARNING][nature] the nature's CRS has been changed to epsg:4326.\n</pre> <pre>[14:21:51][WARNING][nature] the nature's CRS has been changed to epsg:4326.\n</pre> <pre>[14:21:53][WARNING][nature] the nature's CRS has been changed to epsg:4326.\n</pre> <pre>[14:21:56][WARNING][nature] the nature's CRS has been changed to epsg:4326.\n</pre> In\u00a0[9]: Copied! <pre>import seaborn as sns\n\n\ndef plot_exp_result(df):\n    grouped = df.groupby(\"model.density\")[\"burned\"].agg([\"mean\", \"std\"])\n    sns.lineplot(grouped, x=grouped.index, y=\"mean\", err_style=\"band\")\n    plt.fill_between(\n        grouped.index,\n        grouped[\"mean\"] - grouped[\"std\"],\n        grouped[\"mean\"] + grouped[\"std\"],\n        color=\"blue\",\n        alpha=0.2,\n    )\n    plt.show()\n\n\nplot_exp_result(exp.summary())\n</pre> import seaborn as sns   def plot_exp_result(df):     grouped = df.groupby(\"model.density\")[\"burned\"].agg([\"mean\", \"std\"])     sns.lineplot(grouped, x=grouped.index, y=\"mean\", err_style=\"band\")     plt.fill_between(         grouped.index,         grouped[\"mean\"] - grouped[\"std\"],         grouped[\"mean\"] + grouped[\"std\"],         color=\"blue\",         alpha=0.2,     )     plt.show()   plot_exp_result(exp.summary()) <p>As we can see, since the model was imported from an outside script, we are now able to use multiple processes for faster batch run.</p> In\u00a0[10]: Copied! <pre>from abses import Experiment\n\nexp = Experiment.new(Forest, cfg=cfg)\n</pre> from abses import Experiment  exp = Experiment.new(Forest, cfg=cfg) In\u00a0[11]: Copied! <pre>exp.batch_run(parallels=3, repeats=100)\nexp.summary()\n</pre> exp.batch_run(parallels=3, repeats=100) exp.summary() <pre>/home/runner/work/ABSESpy/ABSESpy/.venv/lib/python3.11/site-packages/joblib/externals/loky/process_executor.py:752: UserWarning: A worker stopped while some jobs were given to the executor. This can be caused by a too short worker timeout or by a memory leak.\n  warnings.warn(\n</pre> <pre>[14:22:10][WARNING][nature] the nature's CRS has been changed to epsg:4326.\n</pre> <pre>[14:22:12][WARNING][nature] the nature's CRS has been changed to epsg:4326.\n</pre> <pre>[14:22:14][WARNING][nature] the nature's CRS has been changed to epsg:4326.\n</pre> <pre>[14:22:19][WARNING][nature] the nature's CRS has been changed to epsg:4326.\n</pre> Out[11]: job_id repeat_id burned 0 0 1 0.02475 1 0 2 0.03225 2 0 3 0.02275 3 0 4 0.02475 4 0 5 0.03125 ... ... ... ... 95 0 96 0.02325 96 0 97 0.03050 97 0 98 0.03425 98 0 99 0.02400 99 0 100 0.04975 <p>100 rows \u00d7 3 columns</p> <p>Despite we used a dictionary of parameters to run the previous simulation, <code>ABSESpy</code> always encourage users to save the configurations in a <code>YAML</code> file for better organization and reusability. We will use the <code>YAML</code> file to store the parameters for the later simulations.</p> <pre>exp:\n  name: fire_spread\n  repeats: 100\n\nreports:\n  final:\n    burned: \"burned_rate\"\n\n\nmodel:\n  density: 0.45\n  shape:\n    - 100\n    - 100\n\ntime:\n  end: 25\n</pre> <p>Furthermore, for multiple-processes run, it's also good to save the model <code>Forest</code> in a <code>.py</code> script and import it in <code>Notebook</code> or <code>CLI</code>.</p> <p>This is our working tree:</p> In\u00a0[12]: Copied! <pre># Now, we use the configurations from the `yaml` settings file.\nCONFIG_PATH = r\"../../../examples/fire_spread/config.yaml\"\n\nExperiment.new(Forest, cfg=CONFIG_PATH)\n\n# Just simply pass it as the cfg.\nexp.batch_run()\nexp.summary()\n</pre> # Now, we use the configurations from the `yaml` settings file. CONFIG_PATH = r\"../../../examples/fire_spread/config.yaml\"  Experiment.new(Forest, cfg=CONFIG_PATH)  # Just simply pass it as the cfg. exp.batch_run() exp.summary() Out[12]: job_id repeat_id burned 0 0 1 0.0255 In\u00a0[13]: Copied! <pre>exp = Experiment.new(Forest, cfg=CONFIG_PATH)\n\n\ndef test_hook(m: MainModel, repeat_id: int, job_id: int):\n    if repeat_id == 5:\n        print(f\"Repeat {repeat_id} of job {job_id}, {m.name} is running.\")\n\n\nexp.add_hooks(test_hook)\nexp.batch_run(\n    parallels=5,\n    overrides={\"model.density\": np.arange(0.1, 1.01, 0.1)},\n)\nexp.summary()\n</pre> exp = Experiment.new(Forest, cfg=CONFIG_PATH)   def test_hook(m: MainModel, repeat_id: int, job_id: int):     if repeat_id == 5:         print(f\"Repeat {repeat_id} of job {job_id}, {m.name} is running.\")   exp.add_hooks(test_hook) exp.batch_run(     parallels=5,     overrides={\"model.density\": np.arange(0.1, 1.01, 0.1)}, ) exp.summary() <pre>[14:22:23][WARNING][nature] the nature's CRS has been changed to epsg:4326.\n</pre> <pre>[14:22:25][WARNING][nature] the nature's CRS has been changed to epsg:4326.\n</pre> Out[13]: job_id repeat_id model.density burned 0 0 1 0.1 0.008000 1 1 1 0.2 0.010000 2 2 1 0.3 0.017667 3 3 1 0.4 0.017750 4 4 1 0.5 0.051000 5 5 1 0.6 0.471333 6 6 1 0.7 0.979714 7 7 1 0.8 0.997125 8 8 1 0.9 0.999889 9 9 1 1.0 1.000000 In\u00a0[14]: Copied! <pre>plot_exp_result(exp.summary())\n</pre> plot_exp_result(exp.summary())"},{"location":"tutorial/completing/fire_tutorial/#fire-spread-simulation","title":"Fire Spread Simulation\u00b6","text":""},{"location":"tutorial/completing/fire_tutorial/#introduction","title":"Introduction\u00b6","text":"<p>This notebook is based on the <code>fire</code> model implementation with NetLogo. You can find the original implementation at https://ccl.northwestern.edu/netlogo/models/Fire. This model aims to showcase basic methods that allow interactions between agents.</p> <p>The model simulates the spread of a fire in a forest. The fire spreads from tree to nearby trees. The model consist of a grid of any given size, where each cell may contain either one or no tree. The fire spreads to nearby trees only. The state of each tree is then represented graphically by the color of the cell. Untouched trees appear on green patches, burning trees appear on red patches, and burnt trees appear on orange patches. Whenever there is no tree on a patch, the patch is colored black.</p>"},{"location":"tutorial/completing/fire_tutorial/#the-tree-class","title":"The <code>Tree</code> class\u00b6","text":"<p>The <code>Tree</code> class, which inherits from the <code>PatchCell</code> class, will contain the logic for all trees. A tree will consist of a full cell and, thus, it will not have agency but will rather be affected by its immediate environment. The indicator for how a tree is being affected consist of the state the tree is in. The state of a tree can be one of the following:</p> <ul> <li>0: Empty patch cell</li> <li>1: Healthy tree</li> <li>2: Burning tree</li> <li>3: Scorched tree</li> </ul> <p>The <code>Tree</code> class will contain the logic for the spread of the fire. The spread of the fire will be determined by the state of the tree and the state of the neighboring trees. This process will follow simple, heuristic rules. Any tree that is burning will spread the fire to any neighboring tree that is healthy. A neighbor is defined as those tree standing on the cells at most 1 unit distance away.</p>"},{"location":"tutorial/completing/fire_tutorial/#the-forest-mainmodel-class","title":"The <code>Forest</code> MainModel Class\u00b6","text":"<p>The forest class will contain the grid of tree cells. The forest class is also responsible for setting up the initial configuration of the model as well as activate the rules for the spread of the fire. As usual, the <code>Forest</code> class will inherit from the <code>MainModel</code> class and we need to specify what the setup and step methods will be.</p> <p>The setup method in the Forest class is responsible for creating the initial state of the forest. It's like the stage director setting the scene before the play begins. This method sets up the grid that represents the forest and populates it with trees. The placement and characteristics of these trees are determined by the initial configuration parameters of the model. Once the setup method has run, the forest is ready for the simulation to begin.</p> <p>The step method in the Forest class is like the director calling \"Action!\" on a movie set. It's responsible for advancing the state of the forest by one time step.</p> <p>In the context of a forest fire simulation, the step method would typically iterate over all the trees in the forest and update their state based on the rules of the simulation. For example, if a tree is on fire, it might spread the fire to its neighboring trees. If a tree has been burning for a certain amount of time, it might turn into ash.</p> <p>The step method is called repeatedly to simulate the passage of time and the spread of the fire through the forest. Each call to the step method represents a new moment in time in the life of the forest.</p> <p>Besides those two methods, we want another one that will allow us to visualize the current state of the forest. It will serve the purpose of letting us have a glimpse of the macro state emerging from the simple, micro interactions of the trees.</p>"},{"location":"tutorial/completing/fire_tutorial/#simulations-and-discussion","title":"Simulations and Discussion\u00b6","text":"<p>In this section, we will be using the Forest and Tree classes to simulate forest fires and study their behavior under different conditions. Our primary focus will be on understanding the relationship between the density of the forest and the speed at which the fire spreads.</p> <p>The Forest class represents a forest in which a fire can spread. Each tree in the forest is represented by an instance of the Tree class, which can be in one of four states: empty, intact, burning, or scorched.</p> <p>Our hypothesis is that the density of the forest will have a significant impact on the speed of fire spread. Specifically, we expect that a less dense forest will slow down the fire spread due to the larger gaps between trees. Conversely, in a denser forest, we expect the fire to spread more quickly due to the closer proximity of trees.</p> <p>To test this hypothesis, we will run simulations with different forest densities and observe the speed of fire spread in each case. We will use the Forest class to set up the forest and the Tree class to simulate the behavior of individual trees. The density of the forest will be controlled by the density parameter of the Forest class..</p>"},{"location":"tutorial/completing/fire_tutorial/#60-tree-population-density","title":"60% Tree Population Density\u00b6","text":"<p>For this level of the density parameter, we expect the forest to be relatively dense, with trees close to each other. We expect the fire to spread quickly due to the close proximity of trees.</p> <p>Our suspicion is confirmed in that, by the final step of the simulation, the fire has spread to cover most of the populated area of the forest. More over, the fire has not stopped spreading.</p>"},{"location":"tutorial/completing/fire_tutorial/#40-tree-population-density","title":"40% Tree Population Density\u00b6","text":"<p>This level of the density parameter represents a less dense forest, with more space between trees. We expect the fire to spread more slowly than in the previous case, due to the larger gaps between trees. Nonetheless, it is not considerable low.</p> <p>Not a quarter of the forest is covered by the fire. The fire has stopped spreading by the final step of the simulation.</p>"},{"location":"tutorial/completing/fire_tutorial/#experiment-for-different-parameters","title":"Experiment for different parameters\u00b6","text":""},{"location":"tutorial/completing/fire_tutorial/#call-experiment-in-cli","title":"Call experiment in CLI\u00b6","text":""},{"location":"tutorial/completing/linking_actors/","title":"Network of links between actors","text":"<p>This tutorial will show you how to work with social-ecological network with <code>ABSESpy</code>.</p> In\u00a0[1]: Copied! <pre>from abses import MainModel\n\nmodel = MainModel()\n\nagents = model.agents.new(num=10)\nagents\n</pre> from abses import MainModel  model = MainModel()  agents = model.agents.new(num=10) agents Out[1]: <pre>&lt;ActorsList: (10)Actor&gt;</pre> In\u00a0[2]: Copied! <pre>agents.random.link(link=\"test\", p=0.6, mutual=False)\nagents.plot.graph(\"test\");\n</pre> agents.random.link(link=\"test\", p=0.6, mutual=False) agents.plot.graph(\"test\"); In\u00a0[3]: Copied! <pre>import numpy as np\nimport networkx as nx\n\nrng = np.random.default_rng()\na = rng.integers(low=0, high=2, size=(10, 10))\nDG = nx.from_numpy_array(a, create_using=nx.DiGraph)\n\nnx.draw(DG, arrows=True)\n</pre> import numpy as np import networkx as nx  rng = np.random.default_rng() a = rng.integers(low=0, high=2, size=(10, 10)) DG = nx.from_numpy_array(a, create_using=nx.DiGraph)  nx.draw(DG, arrows=True) In\u00a0[4]: Copied! <pre>nx.to_dict_of_lists(DG)\n</pre> nx.to_dict_of_lists(DG) Out[4]: <pre>{0: [1, 5],\n 1: [2, 4, 6, 7],\n 2: [0, 1, 2, 4, 7],\n 3: [0, 2, 4],\n 4: [0, 3, 4, 6, 8, 9],\n 5: [1, 2, 3],\n 6: [0, 1, 2, 4, 8],\n 7: [0, 1, 3, 4, 7, 8],\n 8: [2, 3, 6],\n 9: [0, 2, 4, 9]}</pre> In\u00a0[5]: Copied! <pre>from abses import Actor\n\n\nclass NodeActor(Actor):\n    marker = \"^\"\n\n\nnodes = model.agents.new_from_graph(DG, \"imported\", actor_cls=NodeActor)\nnodes\n</pre> from abses import Actor   class NodeActor(Actor):     marker = \"^\"   nodes = model.agents.new_from_graph(DG, \"imported\", actor_cls=NodeActor) nodes Out[5]: <pre>&lt;ActorsList: (10)NodeActor&gt;</pre> In\u00a0[6]: Copied! <pre>nodes.plot.graph(\"imported\")\n</pre> nodes.plot.graph(\"imported\") Out[6]: <pre>&lt;Axes: &gt;</pre>"},{"location":"tutorial/completing/linking_actors/#network-of-links-between-actors","title":"Network of links between actors\u00b6","text":""},{"location":"tutorial/completing/linking_actors/#import-graph-to-create-agents","title":"Import Graph to create agents\u00b6","text":""},{"location":"tutorial/completing/random_seed/","title":"Random Seed to Control Experiment","text":"In\u00a0[1]: Copied! <pre>from abses import MainModel, Experiment\n\n\nclass RandomAddingMod(MainModel):\n    \"\"\"\u6d4b\u8bd5\u7c7b\"\"\"\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.test_var = 0\n\n    def random_step(self):\n        \"\"\"\u6d4b\u8bd5\u6b65\u9aa4\"\"\"\n        return self.random.randint(0, 10)\n\n    def step(self):\n        \"\"\"\u6d4b\u8bd5\u6b65\u9aa4\"\"\"\n        self.test_var += self.random_step()\n\n\ncfg = {\n    \"reports\": {\"final\": {\"test_var\": \"test_var\"}},\n    \"time\": {\"end\": 10},\n}\n\nexp = Experiment.new(RandomAddingMod, cfg=cfg, seed=42)\nexp.batch_run()\nexp.summary()\n</pre> from abses import MainModel, Experiment   class RandomAddingMod(MainModel):     \"\"\"\u6d4b\u8bd5\u7c7b\"\"\"      def __init__(self, *args, **kwargs):         super().__init__(*args, **kwargs)         self.test_var = 0      def random_step(self):         \"\"\"\u6d4b\u8bd5\u6b65\u9aa4\"\"\"         return self.random.randint(0, 10)      def step(self):         \"\"\"\u6d4b\u8bd5\u6b65\u9aa4\"\"\"         self.test_var += self.random_step()   cfg = {     \"reports\": {\"final\": {\"test_var\": \"test_var\"}},     \"time\": {\"end\": 10}, }  exp = Experiment.new(RandomAddingMod, cfg=cfg, seed=42) exp.batch_run() exp.summary() Out[1]: job_id repeat_id seed test_var 0 0 1 165578901 58 In\u00a0[2]: Copied! <pre>exp2 = Experiment(RandomAddingMod, cfg=cfg, seed=42)\nexp2._job_id = 1\nexp2.batch_run()\nexp2.summary()\n</pre> exp2 = Experiment(RandomAddingMod, cfg=cfg, seed=42) exp2._job_id = 1 exp2.batch_run() exp2.summary() Out[2]: job_id repeat_id seed test_var 0 0 1 165578901 58 1 1 1 1561874393 57 <p>We include another experiment with the same model and config, but different seed. exp3 = Experiment(RandomAddingMod, cfg=cfg, seed=43)</p> In\u00a0[3]: Copied! <pre>exp3 = Experiment(RandomAddingMod, cfg=cfg, seed=43)\nexp3.batch_run()\nexp3.summary()\n</pre> exp3 = Experiment(RandomAddingMod, cfg=cfg, seed=43) exp3.batch_run() exp3.summary() Out[3]: job_id repeat_id seed test_var 0 0 1 3702419103 35 1 1 1 1561874393 57"},{"location":"tutorial/completing/random_seed/#random-seed-to-control-experiment","title":"Random Seed to Control Experiment\u00b6","text":""},{"location":"wiki/about/","title":"about","text":""},{"location":"wiki/about/#what-is-an-agent-based-model-abm","title":"What is an Agent-based Model (ABM)","text":"<p>Definition</p> <p>An agent-based model (often called ABM) comprises diverse autonomous agents interacting with one another and their environment**.</p> <p>ABM is simulated over time: agents make decisions and act based on their attributes and/or in response or anticipation of other agents\u2019 behaviors or changes in the environment at each time step or event. Many agents' micro-level actions and interactions give rise to macro-level patterns and dynamics, typically the focus of analysis. The agents thus respond diversely to the contexts (usually depicted by the model's parameters and variables) they jointly created, and their actions' outcomes then lead to an emergence of the macro pattern.</p>"},{"location":"wiki/about/#what-are-social-ecological-systems-sess","title":"What are Social-ecological Systems (SESs)","text":"<p>Definition</p> <p>\u2018Social-ecological systems\u2019 (SES) is a concept for understanding the intertwined nature of human and natural systems in an interconnected and interdependent way ^<sup>1</sup>.</p> <p>SESs are not merely social plus ecological systems, but cohesive, integrated systems characterised by strong connections and feedbacks within and between social and ecological components that determine their overall dynamics ^<sup>2</sup>. As such, SES are a type of complex adaptive system, and studying SESs often requires the methods or the applications to cover the social domains, ecological domains, and the emergence from their dynamic interdependence ^<sup>3</sup>.</p>"},{"location":"wiki/about/#abm-is-an-essential-method-in-studying-ses","title":"ABM is an essential method in studying SES","text":"<p>Several characteristics of ABM make it an essential method for SES research:</p> <ol> <li>It focuses on the change of an SES over time from mutual adaptations of agents and their environments.</li> <li>It can lead to emergence, -system-level outcomes from micro-level interactions and macro-level feedback.</li> <li>its ability to represent the diversity and heterogeneity of human and non-human actors and the spatial characteristics of an SES.</li> <li>its capacity serves as a virtual laboratory in which researchers and stakeholders can experiment with an SES to explore possible consequences of interventions.</li> </ol>"},{"location":"wiki/about/#when-and-how-abm-to-study-ses","title":"When and How ABM to Study SES","text":"<p>Agent-based models of SES are often developed for one of the following purposes ^<sup>1</sup>:</p> <ul> <li>Exploring or explaining the emergence of social-ecological outcomes and understanding the SES's evolution over time.</li> <li>Assessing the impact of a new policy or disturbance on an SES that is understood as a complex adaptive system, including potential unintended consequences.</li> <li>Supporting a participatory process that aims to enhance problem understanding.</li> </ul>"},{"location":"wiki/about/#references","title":"References","text":"<ol> <li> <p>Reinette Biggs, Rika Preiser, Alta de Vos, Maja Schl\u00fcter, Kristine Maciejewski, and Hayley Clements. The Routledge Handbook of Research Methods for Social-Ecological Systems. Routledge, London, 1 edition, July 2021. ISBN 978-1-00-302133-9. doi:10.4324/9781003021339.\u00a0\u21a9\u21a9</p> </li> <li> <p>Carl Folke, Stephen R. Carpenter, Brian Walker, Marten Scheffer, Terry Chapin, and Johan Rockstrom. Resilience thinking: integrating resilience, adaptability and transformability. Ecology and Society, 15(4):20, 2010. doi:10.5751/es-03610-150420.\u00a0\u21a9</p> </li> <li> <p>Carl Folke, Reinette Biggs, Albert V. Norstr\u00f6m, Belinda Reyers, and Johan Rockstr\u00f6m. Social-ecological resilience and biosphere-based sustainability science. Ecology and Society, 21(3):art41, 2016. doi:10.5751/ES-08748-210341.\u00a0\u21a9</p> </li> </ol>"},{"location":"wiki/concepts/","title":"Concepts","text":"<p> Emergence</p> <p> Complex Adaptive System</p> <p> CCR Framework</p> <p> Huh ... If you want to know any specific concept, tell us.</p>"},{"location":"wiki/materials/","title":"Materials","text":""},{"location":"wiki/materials/#reading-materials-introductory-tutorials","title":"Reading materials &amp; introductory tutorials","text":""},{"location":"wiki/materials/#agent-based-model","title":"Agent-based model","text":"<ul> <li>Introduction of Agent-based Modeling</li> </ul>"},{"location":"wiki/materials/#developers","title":"Developers","text":"<ul> <li><code>Pytest</code> awesome plugins</li> </ul>"},{"location":"wiki/wiki/","title":"wikipedia","text":"<p>The concepts of ABM and SES involve very specialized specific fields, with few researchers venturing into both at the same time. To illustrate why <code>ABSESpy</code> combines these two, or to help scholars interested in this method familiarize themselves with some concepts in these two fields, we have created this encyclopedia page.</p> <p>In Progress</p> <p>The author team refers to publicly published, peer-reviewed papers, striving for simplicity and factual accuracy. We sincerely hope that scholars in related fields are willing to participate in the co-construction of this encyclopedia page. If any errors are found, please contact us promptly.</p> <p> Concepts Introduction of basic related concepts</p> <p> Materials Useful links for learning the background</p> <p> Refers Some awesome academic refers that the <code>ABSESpy</code> used</p> <p> Paper A paper introduces how <code>ABSESpy</code> helps this realm</p>"},{"location":"wiki/concepts/CCR/","title":"CCR","text":""},{"location":"wiki/concepts/CCR/#ccr-human-behaviour-framework","title":"CCR Human Behaviour Framework","text":"<p>Quote</p> <pre><code>&gt; This framework allows for biases, habituation and other cognitive processes that shape human perception of climate change and the influence of social norms, social learning and other social processes on spreading information and factors that shape decision-making and behaviour ^[^beckage2022].\n</code></pre> <p>We applied the framework for representing human behaviour that consists of cognition, contagion and behavioural response (CCR framework) ^<sup>1</sup>:</p> CognitionContagionResponse <p>Cognition represents the human processing of information around the ecological system.</p> <p>Contagion represents spreading information, beliefs and behaviour through social networks.</p> <p>Response is the resultant behaviour or action.</p> <p>The <code>ABSESpy</code> fully embedded the three aspects of human behaviour in a different part of the model:</p> <ol> <li>Cognition: developed as an essential feature of each <code>Actor</code>.</li> <li>Contagion: human model can automatically generate SEN for modelling this.</li> <li>Response: customised by users under the IAD framework ^<sup>2</sup>.</li> </ol> <ol> <li> <p>Brian Beckage, Frances C. Moore, and Katherine Lacasse. Incorporating human behaviour into Earth system modelling. Nature Human Behaviour, 6(11):1493\u20131502, November 2022. doi:10.1038/s41562-022-01478-5.\u00a0\u21a9</p> </li> <li> <p>Elinor Ostrom. Understanding Institutional Diversity. Princeton University Press, Princeton, illustrated edition edition, September 2005. ISBN 978-0-691-12238-0.\u00a0\u21a9</p> </li> </ol>"},{"location":"wiki/concepts/complex_adaptive_systems/","title":"Complex adaptive systems","text":""},{"location":"wiki/concepts/complex_adaptive_systems/#complex-adaptive-systems-cas","title":"Complex Adaptive Systems (CAS)","text":"<p>The social-ecological systems (SES) literature now widely recognises that SES can be characterised as intertwined complex adaptive systems (CAS) ^<sup>1</sup>. It means system-level patterns or behaviours cannot be explained by the individual components alone but arise from interactions among agents who adapt and learn about their environment.</p> <p>Meanwhile, the conceptual foundation of agent-based modelling is complex adaptive systems theory ^<sup>2</sup>. Six principles present a typology of characteristics that allows us to discern the qualities of CAS and offer suggestions on the practical implications of CAS-based approaches for assessing and applying appropriate methods to study ^<sup>1</sup>:</p> Constituted relationallyAdaptiveDynamicRadically openContextualComplex causality and emergence <p>Complex adaptive systems are constituted relationally, meaning that complex behaviour and structures emerge as a result of the recursive and aggregate patterns of relations between the component parts of systems.</p> <p>Complex adaptive systems have adaptive capacities and self-organise and coevolve about contextual changes.</p> <p>Dynamic relations characterise complex adaptive systems. In other words, the relationships in a system are constantly changing in rich and unexpected ways.</p> <p>Complex adaptive systems are radically open. In other words, the system's activity in relation to the environment constitutes the system itself.</p> <p>Complex adaptive systems are context-dependent, meaning CAS's function(s) are contingent on context.</p> <p>Complex adaptive systems are characterised by complex causality and emergence. Cause-and-effect interactions in CAS are not unidirectional or linear, but are marked by complex recursive causal pathways that are non-linear and dynamic.</p> <ol> <li> <p>Reinette Biggs, Rika Preiser, Alta de Vos, Maja Schl\u00fcter, Kristine Maciejewski, and Hayley Clements. The Routledge Handbook of Research Methods for Social-Ecological Systems. Routledge, London, 1 edition, July 2021. ISBN 978-1-00-302133-9. doi:10.4324/9781003021339.\u00a0\u21a9\u21a9</p> </li> <li> <p>W. Brian Arthur. The Economy as an Evolving Complex System II. CRC Press, 1 edition, May 2018. ISBN 978-0-429-49663-9. doi:10.1201/9780429496639.\u00a0\u21a9</p> </li> </ol>"},{"location":"wiki/concepts/emergence/","title":"Emergence","text":""},{"location":"wiki/concepts/emergence/#emergence-or-emergent","title":"Emergence (or emergent)","text":"<p>Definition</p> <p>Since simple rules produce complex behaviour in hard-to-predict ways, the macroscopic behavior of such systems is sometimes called emergent ^<sup>1</sup>.</p> <p>To be more specific, there are four types of emergencies:</p> Simple EmergenceWeak EmergenceMultiple EmergenceStrong Emergence <p>!(https://songshgeo-picgo-1302043007.cos.ap-beijing.myqcloud.com/uPic/CleanShot%202023-01-17%20at%2011.29.48@2x.png){:style=\"height:130px; width:200px\" align='right'}</p> <p>Without any bottom-top feedback, each component uniquely determines the state at the next moment. This form of emergence is characterised by fragility, where the destruction of a single component can cause the system to stop working.</p> <p>If the macro pattern can only be simulated from the micro components' dynamics, then he is weakly emergent. It can be made stable (e.g., ants foraging) or non-stable (e.g., financial markets, subordination).</p> <p>Both negative feedback that makes the system stable and positive feedback that makes the system non-stable. Many complex patterns are emergent as a result.</p> <p>Emergent systems that emerge at a higher level of organisation or complexity, such as culture, language and writing systems, life, and geographic zoning...</p> <ol> <li> <p>Melanie Mitchell. Complexity: A guided tour. Oxford University Press, Oxford [England] ; New York, 2009. ISBN 978-0-19-512441-5.\u00a0\u21a9</p> </li> </ol>"}]}